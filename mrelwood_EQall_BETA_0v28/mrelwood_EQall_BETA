desc: EQall BETA  [mrelwood]


TODO:

CHANGELOG:

.28
- Option to disable auto-reordering (in node menu)

.27
- Fixed "Last touched parameter"
- Fixed: Resizing jumps analyzer scale

.26
- Fixed dragging prevented while automation active
- Fixed Top bar had partial priority over node mouse capture
- Experimental option to decrease automation noise ("autobrake")

.25
- Fixed loading presets

.24
- Small drawing fixes
- Small marquee removal behavior improvements

.23
- Small fixes

.22
- Fixed frequency limits
- Fixed disappearing analyzer db ruler
- Cleaning up

.21
- Help didn't close in analyzer mode
- Disable volume drag when opening top bar menu
- Help title changed to "EQall".
- Small help, graphics, and focus fixes

.20
- Encode and @ser each whole variable to a 10-digit code for faster playback start.

.10
- Renaming from LinkEQ (0.94) to EQall (0.10) !!!



//Built from gfxanalyser from REAPER 5.70
//tags: analysis FFT meter spectrum
//author: Cockos
/*
Copyright (C) 2007 Cockos Incorporated
License: LGPL - http://www.gnu.org/licenses/lgpl.html
*/


slider1:100<40,20000,1>-Freq 1
slider2:0<-24,24,0.1>-Gain 1
slider3:1<0.01,6,0.01>-Width 1
slider4:1<0,1,0.01>-Link Scale 1

slider5:800<40,20000,1>-Freq 2
slider6:0<-24,24,0.1>-Gain 2
slider7:1<0.01,6,0.01>-Width 2
slider8:1<0,1,0.01>-Link Scale 2

slider9:3500<40,20000,1>-Freq 3
slider10:0<-24,24,0.1>-Gain 3
slider11:1<0.01,6,0.01>-Width 3
slider12:1<0,1,0.01>-Link Scale 3

slider13:10000<40,20000,1>-Freq 4
slider14:0<-24,24,0.1>-Gain 4
slider15:1<0.01,6,0.01>-Width 4
slider16:1<0,1,0.01>-Link Scale 4

slider17:350<40,20000,1>-Freq 5
slider18:0<-24,24,0.1>-Gain 5
slider19:1<0.01,6,0.01>-Width 5
slider20:1<0,1,0.01>-Link Scale 5

slider21:2000<40,20000,1>-Freq 6
slider22:0<-24,24,0.1>-Gain 6
slider23:1<0.01,6,0.01>-Width 6
slider24:1<0,1,0.01>-Link Scale 6

slider25:7000<40,20000,1>-Freq 7
slider26:0<-24,24,0.1>-Gain 7
slider27:1<0.01,6,0.01>-Width 7
slider28:1<0,1,0.01>-Link Scale 7

slider29:200<40,20000,1>-Freq 8
slider30:0<-24,24,0.1>-Gain 8
slider31:1<0.01,6,0.01>-Width 8
slider32:1<0,1,0.01>-Link Scale 8

slider33:1200<40,20000,1>-Freq 9
slider34:0<-24,24,0.1>-Gain 9
slider35:1<0.01,6,0.01>-Width 9
slider36:1<0,1,0.01>-Link Scale 9

slider37:5000<40,20000,1>-Freq 10
slider38:0<-24,24,0.1>-Gain 10
slider39:1<0.01,6,0.01>-Width 10
slider40:1<0,1,0.01>-Link Scale 10

slider41:.75<-1.5,1.5,.25>-Auto-Vol
slider42:0<-12,12,0.1>-Volume
slider43:0<0,2,1{-,Bypass,Bypass All}>-Bypass

slider44:0<-1,6,.01>-
slider45:1<.1,6,.01>-
slider46:1<.1,6,.01>-
slider47:.5<0,1,.05>-Graph peak decay

slider48:1<-1,1,0.02>-Gmem Link Volume
slider49:0<0,2,1{Single,Master,Slave}>-Master Mode

slider50:1<0,1,1{Off,Enable}>-Analyzer Enable
slider51:3<0,5,1{1024,2048,4096,8192,16384,32768}>-FFT Size
slider52:102.85<26,171,6>-Analyzer Zoom
slider53:0<0,0,0>-
slider54:3<0,3,1{rectangular,hamming,blackman-harris,blackman}>-FFT Type
slider55:500<0,2500,.5>-Averaging Time (ms) 
slider56:0<0,1,1{Off,Link}>-Link Ruler Zooms
slider57:0<0,0,0>-
slider58:0<0,2,1{-,This/Group,All}>-Reset

slider59:0<0,4,1{Stereo,Mid,Side,L,R}>-Stereo mode
slider60:0<-1,1,0.01>-Roof slide
slider61:1<0,1,1>-Auto reorder
slider62:0<-1,1,0.01>-Vertical Zoom factor
slider63:-1<-1,8,1>-Points
slider64:15<6,30,0.1>-EQ Zoom

// 65: - , This/Group , All (Reset)
// 66: - , Group , All (To Single)

// SLI 57 = TEMP GMASTER SLIDER
// SLI 58 = TEMP DATA SLIDER

in_pin:in L
in_pin:in R
out_pin:Out L
out_pin:Out R

options:gmem=LinkEQ_mrelwood

@init


autobrake = 0;  //  Should reduce automation helicopter noise. Off = 0 ... 1 = max.




/*  PROJECT LOAD ORDER:
1. init, sliders @0
2. slider, sliders @default
3. serialize
4. slider: saved slider1, saved slider2, ...
5. serialize
*/

ver = 0.28;
sprintf(vers,"%.2f",ver);

devmode = 0;
codec = 0;

ext_noinit = 1;
gfx_ext_retina=1.0;
ext_nodenorm=1;
recpos=0;
max_fft_size=32768;
fftsize=max_fft_size;
//gfx_clear=-1; 
windowtype=-1;
fftidx=-1;
pi = 3.14159265358;
spacing = 1.7;
slope = 3;
octcenter = 1000;
poimoupad = 6;

histsize=max_fft_size + (max_fft_size*0.5 - 1);
window=histsize;
fftworkspace=window+(max_fft_size*0.5 + 1);
integrate_buf = fftworkspace + max_fft_size*2;

otherbufs = integrate_buf + max_fft_size*4 +1;

maxpoints = 10;
maxpoles = 6;
grange = 60;
gmasterbypass = 3;

// BUFFERS 
buff = otherbufs ;
bufg = buff + maxpoints*8 +1;
bufw = bufg + maxpoints +1;
bufm = bufw + maxpoints +1;
bufl = bufm + maxpoints +1;
buflm = bufl + maxpoints +1;
bufdynena = buflm + maxpoints +1;
bufdynsol = bufdynena + maxpoints +1;
bufdynknee = bufdynsol + maxpoints +1;
bufdynatt = bufdynknee + maxpoints +1;
bufdynrel = bufdynatt + maxpoints +1;
bufdynthr = bufdynrel + maxpoints +1;
thrdb = bufdynthr + maxpoints +1;
attms = thrdb + maxpoints +1;
relms = attms + maxpoints +1;
compg = relms + maxpoints +1;

bufshape = compg + maxpoints +1;
shapeold = bufshape + maxpoints +1;
shapemold = shapeold + maxpoints +1;
slidold = shapemold + maxpoints +1;
bufbyp = slidold + maxpoints +1;
tmpf = bufbyp + maxpoints +1;
tmpg = tmpf +1;
tmpw = tmpg +1;
tmpm = tmpw +1;
tmpl = tmpm +1;
tmps = tmpl +1;
tmpbyp = tmps +1;

multiselect = tmpbyp +1;

bufvol = multiselect + maxpoints +1;
buflink = bufvol +1;
bufperc = buflink +1;

x1buf = bufperc +1;
x2buf = x1buf + maxpoints+1;
y1buf = x2buf + maxpoints+1;
y2buf = y1buf + maxpoints+1;

xpos = y2buf + maxpoints +1;
ypos = xpos + maxpoints +1;
startx = ypos + maxpoints +1;
startnoteoct = startx + maxpoints +1;
startnote = startnoteoct + 12;
bufstartx = startnote + 20;
bufstartg = bufstartx + maxpoints +1;
bufstartw3 = bufstartg + maxpoints +1;
buf_pk = bufstartw3 + maxpoints +1;
buf_slo = buf_pk + window;

noob == 0 ? memset(buf_slo,-100,fftsize/2);

wsc == 0 ? (
  gfx_wlim = 1000;
  wsc = wscmou = (gfx_wlim/log(1+480))+gfx_wlim* 0.0149142;
);
 



/*
eq1.mem_lp = bufpoles + maxpoints +1;
eq1.mem_hp = eq1.mem_lp + 6 * maxpoles +1;
eq2.mem_lp = eq1.mem_hp + 6 * maxpoles +1;
eq2.mem_hp = eq2.mem_lp + 6 * maxpoles +1;
eq3.mem_lp = eq2.mem_hp + 6 * maxpoles +1;
eq3.mem_hp = eq3.mem_lp + 6 * maxpoles +1;
eq4.mem_lp = eq3.mem_hp + 6 * maxpoles +1;
eq4.mem_hp = eq4.mem_lp + 6 * maxpoles +1;
eq5.mem_lp = eq4.mem_hp + 6 * maxpoles +1;
eq5.mem_hp = eq5.mem_lp + 6 * maxpoles +1;
eq6.mem_lp = eq5.mem_hp + 6 * maxpoles +1;
eq6.mem_hp = eq6.mem_lp + 6 * maxpoles +1;
eq7.mem_lp = eq6.mem_hp + 6 * maxpoles +1;
eq7.mem_hp = eq7.mem_lp + 6 * maxpoles +1;
eq8.mem_lp = eq7.mem_hp + 6 * maxpoles +1;
eq8.mem_hp = eq8.mem_lp + 6 * maxpoles +1;
*/

/*
eqf = 70 + otherbufs;
eqg = 80 + otherbufs;
eqw = 90 + otherbufs;
*/

// TMP:
//memset(shapeold,-1,maxpoints+1);


floorstart = slider52;
bypass = slider43;

noob == 0 && gmem[color*100] > 0 ? (
  gmaster = slider49 = 0;
):(
  gmaster = slider49;
);

gmasterold = 0;

gainmax = slider64;
scaleg = gfx_h*0.5 /gainmax;
precise = 1;

clip = 0;
//tlt_gain = 0;
sr3 = 3*srate;
gfactor = 4;
n = 0;
//g_reset = 1;
e10 = 10^-10;
mv = 2^(-0.2/6);
/*
g_meter = gr_meter = 1;
gr_meter_decay = exp(1/(1*srate));
*/
sqrt2 = sqrt(2);
s2 = sqrt2/2;

//roofgain = 1;

freqmin = 20;
freqmax = 20000;
//frange = freqmax-freqmin;
wmin = 0.01;
wmax = 6;
wminhplp = 1;
wmaxhplp = 6;

wrange = wmax-wmin;







function automate(first last)
  instance(as)(
  as = first;
  loop(last-first+1,
    slider_automate(slider(as));
    as += 1;
  );
  first == 1 && last == 40 ? willautomate = 61;
);

function encode(buf id)
  instance()(

  buf == "byp" ? (
    codebyp = floor(codebyp / 10^(11-id) ) * (10^(11-id)) + (codebyp-floor(codebyp/(10^(10-id)))*10^(10-id) )
    + bufbyp[id] * 10^(10-id) ;
  ) :
  buf == "shape" ? (
    codeshape = floor(codeshape / 10^(11-id) ) * (10^(11-id)) + (codeshape-floor(codeshape/(10^(10-id))) *10^(10-id) )
    + bufshape[id] * 10^(10-id) ;
  ) :
  buf == "st" ? (
    codest = floor(codest / 10^(11-id) ) * (10^(11-id)) + (codest-floor(codest/(10^(10-id)))*10^(10-id) )
    + bufm[id] * 10^(10-id) ;
  ) :
  buf == "sel" ? (
    codesel = floor(codesel / 10^(11-id) ) * (10^(11-id)) + (codesel-floor(codesel/(10^(10-id)))*10^(10-id) )
    + multiselect[id] * 10^(10-id) ;
  ) :
  buf == "dynena" ? (
    codedynena = floor(codedynena / 10^(11-id) ) * (10^(11-id)) + (codedynena-floor(codedynena/(10^(10-id)))*10^(10-id) )
    + bufdynena[id] * 10^(10-id) ;
  ) :
  buf == "dynknee" ? (
    codedynknee = floor(codedynknee / 10^(11-id) ) * (10^(11-id)) + (codedynknee-floor(codedynknee/(10^(10-id)))*10^(10-id) )
    + bufdynknee[id] * 10^(10-id) ;
  ) :
  buf == "dynsol" ? (
    codedynsol = floor(codedynsol / 10^(11-id) ) * (10^(11-id)) + (codedynsol-floor(codedynsol/(10^(10-id)))*10^(10-id) )
    + bufdynsol[id] * 10^(10-id) ;
  );
);

function encode_all(buf)
  instance(n len)(
  
  len = points;
  
  buf == "byp" ? (
    codebyp = 0;
    n = 1;
    loop(len,
      codebyp += bufbyp[n] * 10^(10-n);
      n += 1;
    );
  ) :
  buf == "shape" ? (
    codeshape = 0;
    n = 1;
    loop(len,
      codeshape += bufshape[n] * 10^(10-n);
      n += 1;
    );
  ) :
  buf == "st" ? (
    codest = 0;
    n = 1;
    loop(len,
      codest += bufm[n] * 10^(10-n);
      n += 1;
    );
  ) :
  buf == "sel" ? (
    codesel = 0;
    n = 1;
    loop(len,
      codesel += multiselect[n] * 10^(10-n);
      n += 1;
    );
  ) :
  buf == "dynena" ? (
    codedynena = 0;
    n = 1;
    loop(len,
      codedynena += bufdynena[n] * 10^(10-n);
      n += 1;
    );
  ) :
  buf == "dynknee" ? (
    codedynknee = 0;
    n = 1;
    loop(len,
      codedynknee += bufdynknee[n] * 10^(10-n);
      n += 1;
    );
  ) :
  buf == "dynsol" ? (
    codedynsol = 0;
    n = 1;
    loop(len,
      codedynsol += bufdynsol[n] * 10^(10-n);
      n += 1;
    );
  );
);

function encode_all_all()(
  encode_all("byp");
  encode_all("shape");
  encode_all("st");
  encode_all("sel");
  encode_all("dynena");
  encode_all("dynknee");
  encode_all("dynsol");
  
  1;
);

function decode(buf id)
  instance(val)(

  buf == "byp" ? val = floor( (codebyp-floor(codebyp/(10^(11-id)))*10^(11-id) )/10^(10-id) ) :
  buf == "shape" ? val = floor( (codeshape-floor(codeshape/(10^(11-id)))*10^(11-id) )/10^(10-id) ) :
  buf == "st" ? val = floor( (codest-floor(codest/(10^(11-id)))*10^(11-id) )/10^(10-id) ) :
  buf == "sel" ? val = floor( (codesel-floor(codesel/(10^(11-id)))*10^(11-id) )/10^(10-id) ) :
  buf == "dynena" ? val = floor( (codedynena-floor(codedynena/(10^(11-id)))*10^(11-id) )/10^(10-id) ) :
  buf == "dynknee" ? val = floor( (codedynknee-floor(codedynknee/(10^(11-id)))*10^(11-id) )/10^(10-id) ) :
  buf == "dynsol" ? val = floor( (codedynsol-floor(codedynsol/(10^(11-id)))*10^(11-id) )/10^(10-id) );
  
  val;
);

function decode_all(buf)
  instance(n len)(
  len = points;

  buf == "byp" ? (
    n = 1;
    loop(len,
      bufbyp[n] = decode("byp",n);
      n += 1;
    );
  ) :
  buf == "shape" ? (
    n = 1;
    loop(len,
      bufshape[n] = decode("shape",n);
      n += 1;
    );
  ) :
  buf == "st" ? (
    n = 1;
    loop(len,
      bufm[n] = decode("st",n);
      n += 1;
    );
  ) :
  buf == "sel" ? (
    n = 1;
    loop(len,
      multiselect[n] = decode("sel",n);
      n += 1;
    );
  ) :
  buf == "dynena" ? (
    n = 1;
    loop(len,
      bufdynena[n] = decode("dynena",n);
      n += 1;
    );
  ) :
  buf == "dynknee" ? (
    n = 1;
    loop(len,
      bufdynknee[n] = decode("dynknee",n);
      n += 1;
    );
  ) :
  buf == "dynsol" ? (
    n = 1;
    loop(len,
      bufdynsol[n] = decode("dynsol",n);
      n += 1;
    );
  );
);

function decode_all_all()(
  decode_all("byp");
  decode_all("shape");
  decode_all("st");
  decode_all("sel");
  decode_all("dynena");
  decode_all("dynknee");
  decode_all("dynsol");
  
  1;
);

  

function upbufs()
  instance(nupb)(
  nupb = 1;
  loop(maxpoints,
    buff[nupb] = slider(1+(nupb-1)*4);
    bufg[nupb] = slider(2+(nupb-1)*4);
    bufw[nupb] = slider(3+(nupb-1)*4);
//    importing.84 < 1 && verold < .845 ? bufm[nupb] = slider(32+nupb);
//    bufm[nupb] = slider(32+nupb);
    bufl[nupb] = slider(4+(nupb-1)*4);
    nupb += 1;
  );
);
//upbufs();

function xpos(f)
  instance(tmp)(
  tmp = (log(1.0+(f/old_srate*2.0)*400)*wsc)  - wsc*0.2;
  tmp;
);


function freqmax(id)
  instance(tgt z diro dir)(
  
  dir = sign(mou);
  mouse_capold == 0 || dir != diro ? (
    multiedit == 1 || id == 0 ? (
      hi_id = hi_f = lo_id = 0;
      lo_f = 20000;
      z = 1;
      loop(points,
        multiselect[z] == 1 ? (
          buff[z] > hi_f ? (hi_id = z; hi_f = buff[z]; );
          buff[z] < lo_f ? (lo_id = z; lo_f = buff[z]; );
        );
        z += 1;
      );
    ):(
      hi_id = lo_id = id;
      hi_f = lo_f = buff[id];
    );
    bufshape[hi_id] == 0 ? freqmax = srate * .3 :
    bufshape[hi_id] == 5 ? freqmax = srate * .35 :
    freqmax = srate * .4;
    freqmin = 20;
  );
  diro = dir;
  
/*  
  buff[hi_id] > freqmax ? (
    buff[hi_id] = freqmax;
    dragstop = 2;
    fstop = 1;
    maxinc = 0;
  ) :
  buff[lo_id] < freqmin ? (
    buff[lo_id] = freqmin;
    dragstop = 1;
    fstop = 1;
    mininc = 0;
  ) : (
*/
//    maxinc = freqmax/buff[tgt];
//    maxinc = min(maxinc, xpos(freqmax) - xpos[tgt] );
    maxinc = max(0, (xpos(freqmax) - xpos[hi_id]) );
    mininc = min(0, (xpos(freqmin) - xpos[lo_id]) );
//  );
  
  dragstop = 0;
  buff[id];
  
);






function upsliders()
  instance(nsl)(
  nsl = 1;
  loop(points,
    removing == 0 ? freqmax(nsl);
    buff[nsl] > freqmax ? buff[nsl] = freqmax;
    buff[nsl] < freqmin ? buff[nsl] = freqmin;
    bufg[nsl] > grange ? bufg[nsl] = grange;
    bufg[nsl] < -grange ? bufg[nsl] = -grange;
    bufw[nsl] > wmax ? bufw[nsl] = wmax;
    bufw[nsl] < wmin ? bufw[nsl] = wmin;
    bufm[nsl] > 4 ? bufm[nsl] = 4;
    bufm[nsl] < 0 ? bufm[nsl] = 0;
    bufl[nsl] > 1 ? bufl[nsl] = 1;
    bufl[nsl] < -1 ? bufl[nsl] = -1;
    
    slider(1+(nsl-1)*4) = buff[nsl];
    slider(2+(nsl-1)*4) = bufg[nsl];
    slider(3+(nsl-1)*4) = bufw[nsl];
//    slider(32+nsl) = bufm[nsl];
    slider(4+(nsl-1)*4) = bufl[nsl];
    
    nsl += 1;
  );
  automate(1,40);
  
  
);

function nozerof()(
  buff[1] == 0 ? buff[1] = 100;
  buff[2] == 0 ? buff[2] = 800;
  buff[3] == 0 ? buff[3] = 3500;
  buff[4] == 0 ? buff[4] = 10000;
  buff[5] == 0 ? buff[5] = 350;
  buff[6] == 0 ? buff[6] = 2000;
  buff[7] == 0 ? buff[7] = 7000;
  buff[8] == 0 ? buff[8] = 200;
  buff[9] == 0 ? buff[9] = 50;
  buff[10] == 0 ? buff[10] = 550;
  
  upsliders();
);

/*
n = 1;
loop(points,
  bufw[n] == 0 ? bufw[n] = 1;
  n += 1;
);
*/

function compini( thr1 att1 rel1 id)
  instance(atts attmul fmul rels relmul thr thr5)(
  
//  afmul = (1-(log10(this.f)-1.3)/3); // (1.3 -4.3)
  fmul = (1-(log10(buff[id])-1.3)/3); // (1.3 -4.3)
  
//  attms[id] = (.1 + 5*fmul^2) + att1^(2-fmul) * (30 + 70*fmul^1);
  attms[id] = (.1 + 5*fmul^2) + att1^(3- 2.1*fmul^.3) * (30 + 70*fmul^1);
  atts = ceil( (attms[id]/1000)*srate );
  attmul = 1/atts;
  bufdynknee[id] == 1 ? attmul = attmul^1;
  relms[id] = (5 + fmul*6) + rel1^2 * (280 + fmul * 300);
  rels = (relms[id]/1000)*srate;
  relmul = 1/rels;
//  relmul5 = relmul^.25;
  
  holdspls = srate/1000 * 1;
  
  this.thr1 = thr1;
  
//  thr = 2^((thrdb[id] = (1-thr1)^(1+.3*fmul^1.5) * -60 )/6);
//  thr = 2^((thrdb[id] = (1-thr1)^(1+.3*fmul^1.5) * (-70 +15*fmul^1.5) )/6);
  thr = 2^((thrdb[id] = (1-thr1)^(1+.5*fmul^1.5) * (-70 +15*fmul^1.5) )/6);
  thr5 = thr^.5;
  

);

function compini_1(id)
  instance()(
  
  id == 1 ? eq1.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id) :
  id == 2 ? eq2.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id) :
  id == 3 ? eq3.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id) :
  id == 4 ? eq4.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id) :
  id == 5 ? eq5.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id) :
  id == 6 ? eq6.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id) :
  id == 7 ? eq7.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id) :
  id == 8 ? eq8.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id) :
  id == 9 ? eq9.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id) :
  id == 10 ? eq10.compini(bufdynthr[id],bufdynatt[id],bufdynrel[id],id);
);


function compini_all()
  instance()(
  
  points > 0 ? eq1.compini( bufdynthr[1],bufdynatt[1],bufdynrel[1],1 );  
  points > 1 ? eq2.compini( bufdynthr[2],bufdynatt[2],bufdynrel[2],2 );  
  points > 2 ? eq3.compini( bufdynthr[3],bufdynatt[3],bufdynrel[3],3 );  
  points > 3 ? eq4.compini( bufdynthr[4],bufdynatt[4],bufdynrel[4],4 );  
  points > 4 ? eq5.compini( bufdynthr[5],bufdynatt[5],bufdynrel[5],5 );  
  points > 5 ? eq6.compini( bufdynthr[6],bufdynatt[6],bufdynrel[6],6 );  
  points > 6 ? eq7.compini( bufdynthr[7],bufdynatt[7],bufdynrel[7],7 );  
  points > 7 ? eq8.compini( bufdynthr[8],bufdynatt[8],bufdynrel[8],8 );  
  points > 8 ? eq9.compini( bufdynthr[9],bufdynatt[9],bufdynrel[9],9 );  
  points > 9 ? eq10.compini( bufdynthr[10],bufdynatt[10],bufdynrel[10],10 );
);


function eqini(f ga w)
  instance(g gain w1 dampening c a2 fa1 fa0 fk Q frequency ble gdb
//        foff wsteep wshal flow fhigh rl rh fmul
//         fgap  f0 cl ch
        gmul g1 g2 w1 w2 wmul f1 f2 fmul w6 ftmp wtmp gtmp w6
        alpha gexp omega sinf cosf beta a0 b0 b1 b2 a1 a2 ca0 cb0 cb1 cb2 ca1 ca2
        b0a0 b1a0 b2a0 a1a0 a2a0 cb0a0 cb1a0 cb2a0 ca1a0 ca2a0 cQ
        alpha_ gexp_ omega_ sinf_ cosf_ beta_ a0_ b0_ b1_ b2_ a1_ a2_
  )(
  
//  eqreset = 1;
  
//  bufdynena[nei] == 1 ? this.compini_1(nei );
  bufdynena[nei] == 1 ? compini_1(nei);
  
  
  gdb = ga;
  
  bufshape[nei] == 0 || bufshape[nei] == 5 ? (    // HIGH PASS , LOW PASS
  
    w1 = max(1,w);
//    wmin = 1;

    bufshape[nei] == 5 ? ( // LP
      f /= this..ftmp = .9 - .2 * ((w1-1)/5)^2 + .25 * max(0,2.5-w1);
      f *= 1 + .3 *(1-(w1-1)/5) *(1- abs((w1-floor(w1)) -.5) *2)^.5;
    ) :
    bufshape[nei] == 0 ? ( // HP
      f /= 1 + (.2 - .15*(w1/5)^.5) * (1- abs(w1-floor(w1)-.5)*2)^.2;
      f *= (1.4 -.6 *((w1-1)/5)^.35 );
    );
    Q = .7;
  
    this.poles = ceil(w);
    ble = .5;
    this.blend1 = min(1,w)^ble;
    this.blend2 = min(1,max(0,w-1))^ble;
    this.blend3 = min(1,max(0,w-2))^ble;
    this.blend4 = min(1,max(0,w-3))^ble;
    this.blend5 = min(1,max(0,w-4))^ble;
  
    omega = 2*pi*f/srate;
    
    sinf   = sin(omega);
    cosf   = cos(omega);
    
    alpha = sinf/(2*Q);                                   //  (if Q is specified)

    bufshape[nei] == 0 ? ( // HP 
      b0 =  (1 + cosf)/2;
      b1 = -(1 + cosf);
      b2 =  (1 + cosf)/2;
      a0 =   1 + alpha;
      a1 =  -2*cosf;
      a2 =   1 - alpha;
    ) :
  
    bufshape[nei] == 5 ? ( // LP 
      b0 =  (1 - cosf)/2;
      b1 =  (1 - cosf);
      b2 =  (1 - cosf)/2;
      a0 =   1 + alpha;
      a1 =  -2*cosf;
      a2 =   1 - alpha;
    );
  ) : (


    this.blend1 = 1;
//    wmin = .01;
    
  
    bufshape[nei] == 3 ? (    // FLAT TOP
      ga = min(30,max(-30,ga));
/*  
      gmul = 1 + max(0,f-9000) / 40000;
      gmul2 = w^2 * .005 +1;
      g2 = ga *.6 *gmul *gmul2;
      g1 = ga *.6 /gmul *gmul2;
      w1 = w /10;
      w2 = w1;
*/  
      
//      wmul = min(2, 1+ w * ( ABS(w-1.3)/(sqrt(ga)*5) + (0.21-(ga)^2 /10000) ));
      mul = 1.4;
//      w_ = w/mul;
//      gmul = gmul2 = g1 = g2 = ga * slider45;
//      wmul = 1/w_;


      ftmp = (log(f)-3) / 6.9;
      w6 = w/6;
//      wmul = (0.83-w6)*1 + .65 *w6^1.5;
      wmul = (0.83-w6)*1 + .65 *w6^1.6  +1* max(0,(ftmp^.7-.9)/.1)^2 +0*.1*ftmp^3*w6;
      w1 = w2 = w* 1* max(.001 , wmul);
//      fmul = 1.03 - .06* (f/freqmax) + (1 -.8 * (f/freqmax)^1) * w6^1.05 + slider44;
//      fmul = 1.035 - .025*ftmp + (1.1-.8*ftmp - .1* (1-ftmp)^10 + .5*ftmp - .6*max(0,(ftmp-.9)/.1)^1   )*w6 ;
      fmul = 1.035 - .02*ftmp^2 + (1.1 -.4*ftmp - .1* (1-ftmp)^10 - .3*max(0,(ftmp-.9)/.1)^2   )*w6 ;
      
      f1 = f / fmul;
      f2 = f * fmul;
      gmul = 2^( ga*.5 * (.67 -.5*(w6) + .6*(w6)^1.2) /6);
//      gmul = ga;
      
      /*
      10k 
          w.0: 1.02 .67 ...
          w.1: 1.04 .67 .83
          w.5: 1.08 .63 .8
          w1: 1.14 0.66 .7
          w2: 1.25 .66 .64
          w3: 1.39 .66 .66
          w4: 1.6 .74 .68
          w5: 1.74 .74 .7
          w6: 1.88 .74 .77
      */
      
      f2 > freqmax ? (
        f2 = freqmax;
        f = f2/fmul;
        f1 = f/fmul;
      );
      f1 < freqmin ? (
        f1 = freqmin;
        f = f1*fmul;
        f2 = f*fmul;
      );
  
//      gmul = 10^(g1/40);
      omega = 2*pi*f1/srate;
      sinf = sin(omega);
      cosf = cos(omega);
//      alpha = sinf*sin( log(2)/2 * w1 * omega/sinf ) *10;   //(if bandwidth is specified)

      Q = 1.5/(w1+.1);
      alpha = sinf/(2* Q );
      
  
      b0 =   1 + alpha*gmul;
      b1 =  -2*cosf;
      b2 =   1 - alpha*gmul;
      a0 =   1 + alpha/gmul;
      a1 =  -2*cosf;
      a2 =   1 - alpha/gmul;

//      this.flat.gmul = 10^(g2/40);
      this.flat.gmul = gmul;
      this.flat.omega = 2*pi*f2/srate;
      this.flat.cosf = cos(this.flat.omega);
      this.flat.sinf = sin(this.flat.omega);
//      this.flat.alpha = this.flat.sinf*sin( log(2)/2 * w2 * this.flat.omega/this.flat.sinf ) *(10);   //(if bandwidth is specified)
      this.flat.alpha = this.flat.sinf/(2* (1.5/(w2+.1)) );
  
      this.flat.b0 =   1 + this.flat.alpha*this.flat.gmul;
      this.flat.b1 =  -2*this.flat.cosf;
      this.flat.b2 =   1 - this.flat.alpha*this.flat.gmul;
      this.flat.a0 =   1 + this.flat.alpha/this.flat.gmul;
      this.flat.a1 =  -2*this.flat.cosf;
      this.flat.a2 =   1 - this.flat.alpha/this.flat.gmul;


      omega = 2*pi*f/srate;   // Cookbook "w0"
      sinf   = sin(omega);
      cosf   = cos(omega);
      cQ = 15/(w*1.2 +1);
//      cQ = 15/(wmul*.7 +1);
      alpha = sinf/(2* cQ );
      
      cb0 =   alpha;
      cb1 =   0;
      cb2 =   -alpha;
      ca0 =   1 + alpha;
      ca1 =  -2*cosf;
      ca2 =   1 - alpha;

      
      
    ) : (     // PEAK
    
      omega = 2*pi*f/srate;   // Cookbook "w0"
      
      sinf   = sin(omega);
      cosf   = cos(omega);

      //alpha = sinf/(2*Q);                                   //  (if Q is specified)
//      alpha = sinf*sin( log(2)/2 * w * omega/sinf );   //(if bandwidth is specified)
//      alpha = max(0,alpha);
      
//      Q = 1.5/(w/(2-abs(ga)/30)+.01);
      
      /*
      g must affect q
      more precise graph for peak
      comfirm flat top for new q
      */
      
      bufshape[nei] == 2 ? (    // PEAK
        ga = min(40,max(-40,ga));
      
//        wmin = .01;
        wmul = w * (1+ (2.5-w*.15) * max(0,(log10(buff[nei])-3.9)/.4)^4 );
        Q = 1.5/(wmul+.1);
        alpha = sinf/(2* Q );

        ga *= min(1, 40/(abs(ga) ) );
        gmul = sqrt( 10^(ga/20) );
        
      
        b0 =   1 + alpha*gmul;
        b1 =  -2*cosf;
        b2 =   1 - alpha*gmul;
        a0 =   1 + alpha/gmul;
        a1 =  -2*cosf;
        a2 =   1 - alpha/gmul;
        
        
        cQ = 15/(wmul*.7 +1);
        alpha = sinf/(2* cQ );
        
        cb0 =   alpha;
        cb1 =   0;
        cb2 =   -alpha;
        ca0 =   1 + alpha;
        ca1 =  -2*cosf;
        ca2 =   1 - alpha;

        
  
        
        
      ) :
      
    
    
    
      bufshape[nei] == 1 || bufshape[nei] == 4 ? (    // SHELVES
        ga = min(30,max(-30,ga));
      
//        wmin = .01;
        w = max(w , max(.01, .2 + .05*(abs(ga)-20) ));
        this._wid = w;
        gmax = 30;
//        abs(ga) > 20 ? ga *= 20/abs(ga);
        w1 = 1/ ((w-1)/2+1);
    
        gexp = 10^(ga/40);
        beta  = sqrt(gexp)*sqrt( (gexp + 1/gexp)*(1/w1 - 1) + 2 );    // (if shelf slope is specified)
    //    beta  = sqrt(gexp)/qval;                                     //(for shelving EQ filters only)       
    
        gmul = sqrt( 10^(ga/20) );
        
        
        
        bufshape[nei] == 1 ? (  // LSF
          b0 =    gmul*( (gmul+1) - (gmul-1)*cosf + beta*sinf );
          b1 =  2*gmul*( (gmul-1) - (gmul+1)*cosf            );
          b2 =    gmul*( (gmul+1) - (gmul-1)*cosf - beta*sinf );
          a0 =        (gmul+1) + (gmul-1)*cosf + beta*sinf;
          a1 =   -2*( (gmul-1) + (gmul+1)*cosf            );
          a2 =        (gmul+1) + (gmul-1)*cosf - beta*sinf;
          
          omega = 2*pi* max(30, f*.7 / (1+w *.1) )/srate;
//          omega = 2*pi* max(30, f*.7  )/srate;
          sinf   = sin(omega);
          cosf   = cos(omega);
          cQ = .8 / (1+ w/6);
//          cQ = .4;
          alpha = sinf/(2*cQ);                                   //  (if Q is specified)
          
          cb0 =  (1 - cosf)/2;
          cb1 =  (1 - cosf);
          cb2 =  (1 - cosf)/2;
          ca0 =   1 + alpha;
          ca1 =  -2*cosf;
          ca2 =   1 - alpha;
          
        ) :

        bufshape[nei] == 4 ? (  // HSF
          b0 =    gmul*( (gmul+1) + (gmul-1)*cosf + beta*sinf );
          b1 = -2*gmul*( (gmul-1) + (gmul+1)*cosf            );
          b2 =    gmul*( (gmul+1) + (gmul-1)*cosf - beta*sinf );
          a0 =        (gmul+1) - (gmul-1)*cosf + beta*sinf;
          a1 =    2*( (gmul-1) - (gmul+1)*cosf            );
          a2 =        (gmul+1) - (gmul-1)*cosf - beta*sinf;
          
          omega = 2*pi* min(f+3000, f*1.5 * (1+ w*.1) )/srate;
          sinf   = sin(omega);
          cosf   = cos(omega);
          cQ = .8 / (1+ w/6);
          alpha = sinf/(2*cQ);                                   //  (if Q is specified)
          
          cb0 =  (1 + cosf)/2;
          cb1 = -(1 + cosf);
          cb2 =  (1 + cosf)/2;
          ca0 =   1 + alpha;
          ca1 =  -2*cosf;
          ca2 =   1 - alpha;
          
        );
      );
    );
  );
  
  
  flushspd = 1/(1 + autobrake * (srate/4) );
  
  autobrake > 0 && this.flush <= 0 ? (
    this.flush = 1;

    this.b0a0_o = b0a0;
    this.b1a0_o = b1a0;
    this.b2a0_o = b2a0;
    this.a1a0_o = a1a0;
    this.a2a0_o = a2a0;
/*
  ):(
    
    this.b0a0_o += (b0a0-this.b0a0_o) * (1-this.flush);
    this.b1a0_o += (b1a0-this.b1a0_o) * (1-this.flush);
    this.b2a0_o += (b2a0-this.b2a0_o) * (1-this.flush);
    this.a1a0_o += (a1a0-this.a1a0_o) * (1-this.flush);
    this.a2a0_o += (a2a0-this.a2a0_o) * (1-this.flush);
*/
  );  
  
  
/*  
  this.b0a0_o = b0a0;
  this.b1a0_o = b1a0;
  this.b2a0_o = b2a0;
  this.a1a0_o = a1a0;
  this.a2a0_o = a2a0;
*/

  b0a0 = b0/a0;
  b1a0 = b1/a0;
  b2a0 = b2/a0;
  a1a0 = a1/a0;
  a2a0 = a2/a0;
  
  cb0a0 = cb0/ca0;
  cb1a0 = cb1/ca0;
  cb2a0 = cb2/ca0;
  ca1a0 = ca1/ca0;
  ca2a0 = ca2/ca0;
  
  this.shape = bufshape[nei];
  this.f = f;
  this.w = w;
  
);




function eqpole(in id)
  instance(in1 in2 out out1 out2 cin1 cin2 cout cout1 cout2 b0 b1 b2 a0 a1 a2 eqout
  outo flushing flushc)(
  
  
  bufdynena[id] == 1 ? (
    cout = (this...cb0a0)*in + (this...cb1a0)*cin1 + (this...cb2a0)*cin2
     - (this...ca1a0)*cout1 - (this...ca2a0)*cout2;
    cin2 = cin1;
    cin1 = in;
    cout2 = cout1;
    cout1 = cout;
  );
  
  this...flush > 0 ? (
    this...b0a0_o += (this...b0a0 - this...b0a0_o) *flushspd;
    this...b1a0_o += (this...b1a0 - this...b1a0_o) *flushspd;
    this...b2a0_o += (this...b2a0 - this...b2a0_o) *flushspd;
    this...a1a0_o += (this...a1a0 - this...a1a0_o) *flushspd;
    this...a2a0_o += (this...a2a0 - this...a2a0_o) *flushspd;
    
    out = (this...b0a0_o)*in + (this...b1a0_o)*in1 + (this...b2a0_o)*in2
     - (this...a1a0_o)*out1 - (this...a2a0_o)*out2;
    
  ):(
    this.flush = 0;
    out = (this...b0a0)*in + (this...b1a0)*in1 + (this...b2a0)*in2
     - (this...a1a0)*out1 - (this...a2a0)*out2 ;

  );

  in2 = in1;
  in1 = in;
  out2 = out1;
  out1 = out;
  
  
  
//  eqout = out = in+out * (0-1);
  eqout = out;
);
function eqpoleFP(flatin)
  instance(flatin1 flatin2 flatout flatout1 flatout2 eqout)(
  
  flatout = (this...flat.b0/this...flat.a0)*flatin + (this...flat.b1/this...flat.a0)*flatin1 + (this...flat.b2/this...flat.a0)*flatin2
   - (this...flat.a1/this...flat.a0)*flatout1 - (this...flat.a2/this...flat.a0)*flatout2;
  flatin2 = flatin1;
  flatin1 = flatin;
  flatout2 = flatout1;
  flatout1 = flatout;

  eqout = flatout;
);
function eqpoleFP2(in_)
  instance(in1_ in2_ out_ out1_ out2_ b0_ b1_ b2_ a0_ a1_ a2_ eqout_)(
  
//  this...reset == 1 ? (
//    in1_ = in2_ = out1_ = out2_ = out_ = 0;
//  ):(
 
    out_ = (this...b0_/this...a0_)*in_ + (this...b1_/this...a0_)*in1_ + (this...b2_/this...a0_)*in2_
     - (this...a1_/this...a0_)*out1_ - (this...a2_/this...a0_)*out2_;
    in2_ = in1_;
    in1_ = in_;
    out2_ = out1_;
    out1_ = out_;
//  );
  eqout_ = out_;
);

 /*
function eq_(in)
  instance(out)(
  
  

  out = in * (1-this...blend1) + this...blend1 *  this..p1.eqpole(in) ;
  
  this...shape == 3 ? out = this..flat.eqpoleFP(out) :  // FLAT TOP
    
  this...shape == 0 || this...shape == 5 ? (  // LP & HP
    this...poles > 1 ? out = out * (1-this...blend2) + this...blend2 *  this..p2.eqpole(out) ;
    this...poles > 2 ? out = out * (1-this...blend3) + this...blend3 *  this..p3.eqpole(out) ;
    this...poles > 3 ? out = out * (1-this...blend4) + this...blend4 *  this..p4.eqpole(out) ;
    this...poles > 4 ? out = out * (1-this...blend5) + this...blend5 *  this..p5.eqpole(out) ;
  );
  
//  this...reset = 0;
  out;
//  in;
);
*/

function comp_oldest(in id)
  instance(cina tgt cg out attc relc)(
  
  cina = abs(in) * cg;
  
//  (cina = abs(in) *cg)  > this...thr ? tgt = this...thr/ina : tgt = 1;
  cina > this...thr ? tgt = this...thr/cina : tgt = 1;
//  tgt = min(1, this...thr/(cina) );

  tgt > cg ? (
    relc += 1;
    attc = 0;
//    cg += (1-cg) * (1-(cina)/thr) * this...relmul;
//    cg += min(tgt-cg, ( (1-cg) * min(1,relc/holdspls) * this...relmul ));
    cg += min(tgt-cg, ( (1-cg) * this...relmul ));
//    cg += (1-cg) * min(1,c/this...rels) this...relmul;
//    cg += min(1-cg , this...relmul );
  ) :
//    g /= (tgtr/g -1) * this...attmul +1;
  tgt < cg ? (
    relc = 0;
    attc += 1;
//    cg -= min( cg-tgt , this...attmul);
//    cg -= ( cg-tgt) * cg * this...attmul;
//    cg -= ( cg-tgt) * min(1,attc/holdspls) * this...attmul;
    cg -= ( cg-tgt) * this...attmul;
  );
  
  compg[id] = cg;
);

function comp_prev(in id)
  instance(cina tgt cg out relc)(
  
  cina = abs(in) ;
  
//  (cina = abs(in) *cg)  > this...thr ? tgt = this...thr/ina : tgt = 1;
  cina > this...thr ? tgt = this...thr/cina : tgt = 1;
//  tgt = min(1, this...thr/(cina) );

  tgt > cg ? (
    relc += 1;
//    attc = 0;
//    cg += (1-cg) * (1-(cina)/thr) * this...relmul;
    cg += min(tgt-cg, 1-cg) * min(1,relc/holdspls) * this...relmul ;
//    cg += min(tgt-cg,  1-cg) * this...relmul ;
//    cg += (1-cg) * min(1,c/this...rels) this...relmul;
//    cg += min(1-cg , this...relmul );
  ) :
//    g /= (tgtr/g -1) * this...attmul +1;
  tgt < cg ? (
    relc = 0;
//    attc += 1;
//    cg -= min( cg-tgt , this...attmul);
//    cg -= ( cg-tgt) * cg * this...attmul;
//    cg -= ( cg-tgt) * min(1,attc/holdspls) * this...attmul;
    cg -= ( cg-tgt) * this...attmul;
  );
  
  compg[id] = cg;
);


function comp_voca(in id) // VocaStrip
  instance(ina tgt tmp inabg flt fltg g gt relbo c)(
  
  (ina = abs(in) ) ;
  
  ina > flt ? (
    flt += (ina-flt) * (this...attmul ) *2;
    c = 0;
  ):(
    c += 1;
//    flt -= flt * ((srate*.0000000001) + (c+(1-att2)^2 *10000)/(srate*10) * (flt-ina) ) * this...relmul;
//    flt -= flt * ((srate*.0000000001) + (c+(1-attms[id]/50)^2 *10000)/(srate*10) * (flt-ina) ) * this...relmul;
    flt -= flt * ((srate*.0000000001) + (c)/(srate*.01) * (flt-ina) ) * this...relmul;
  );

  tgt = (tmp = flt*1.8 /this...thr ) / (1+tmp) *this...thr +.1 ; // Clean

  g == 0 ? g = 1;
  
  (fltg = flt*g) > tgt ? (
//    g /= max(0, fltg/tgt -1) * this...attmul +1;
    g /= max(0, fltg/tgt -1) * 1 +1;
    relbo = 0;
  ):(
    g += relbo * ( ( tgt-fltg )  * this...relmul) ;
//    relbo += .0001  + relbo*relbo *(1-g)*(1-relbo)*.01;
    relbo += this...relmul  + relbo*relbo *(1-g)*(1-relbo)*.1;
  );

  
  g = min(1,g) ;

  
  compg[id] = g;
   
);

function compsoft_(in id) // VocaStrip, EQall default
  instance(ina tgt tmp inabg flt fltg g gt relbo c)(
  
  (ina = abs(in) ) ;
  
  ina > flt ? (
    flt += (ina-flt) * (this...attmul ) *2;
    c = 0;
  ):(
    c += 1;
//    flt -= flt * ((srate*.0000000001) + (c+(1-att2)^2 *10000)/(srate*10) * (flt-ina) ) * this...relmul;
//    flt -= flt * ((srate*.0000000001) + (c+(1-attms[id]/50)^2 *10000)/(srate*10) * (flt-ina) ) * this...relmul;
    flt -= flt * ((srate*.0000000001) + (c)/(srate*.01) * (flt-ina) ) * this...relmul;
  );

  (fltg = flt *g) < this...thr ? (
//    g += (1-g) * (this...thr-fltg +.1) * this...relmul;
    g += ((1-g)^2 *10 * (this...thr5-fltg )) * this...relmul;
//    g += (1-g) * this...relmul5 + (this...thr-fltg ) * this...relmul;
  );
  (fltg = flt *g) > this...thr ? (
//    g *= (this...thr/fltg -1) * this...attmul +1;
    g *= (this...thr/fltg );
  );
    
  
  g = min(1,g) ;

  
  compg[id] = g;
   
);

function compsoft(in id) // New Soft
  instance(ina flt fc rc thr2 ran tgt fltg g tmp)(
  
  (ina = abs(in) ) ;
  
  ina > flt ? (
//    flt += (ina-flt) * (this...attmul ) *2;
//    flt += (ina-flt)^2 ;
    flt += (ina-flt)^1 ;
    fc = 0;
  ):(
    fc += 1;
    flt -= flt * ((srate*.000000001) + (fc)/(srate*.01) * (flt-ina) ) * this...relmul +.000000001;
  );
  
  thr2 = this...thr * .25;
  ran = this...thr-thr2;
//  flt > thr2 ? tgt = (thr2 + ran * atan( (flt-thr2)/ran )  );
  flt > thr2 ? tgt = (thr2 + ran * ((tmp= (flt-thr2)/ran ) / (1+tmp))  ) : tgt = 1;
//  flt > thr2 ? tgt = (thr2 + ran * ( sin(min(1.57,1.57*(flt-thr2)/ran)) )  );

  (fltg = flt *g) < tgt ? (
//    g += ((1-g)^2 *10 * (tgt-fltg )) * this...relmul;
//    g += ((1-g)^2  ) * this...relmul;

    rc = min(this...rels , rc += 1);
    g += ((1-g)^2 + .015) *this...relmul *(rc/this...rels ) ;

  );
  (fltg = flt *g) > tgt ? (
    rc = 0;
  
    g *= (tgt/fltg -1) * this...attmul +1;
  );
    
  
  g = min(1,g) ;

  sp2 = flt;
  sp3 = g;
  
  compg[id] = g;
   
);

function comphard(in id)  // DynaStrip
  instance(ina inag g_ g rc fc flt cin)(

  thr = this...thr;

  inag = (ina = abs( in )) *g;

  ina > flt ? (
    flt += (ina-flt);
    fc = 0;
  ):(
    fc += 1;
    flt -= flt * ((srate*.0000000001) + (fc)/(srate*.01) * (flt-ina) ) * this...relmul;
  );
  
  cin = flt *g;

  cin < thr ? (
//    rc = min(this...rels , rc += 1);
//    g_ += (1-g_)^1 *this...relmul *(rc/this...rels) ;
    g_ += ((1-g)^1  ) * this...relmul *.5;

  );  
  cin > thr ? (
//    g_ *= (thr/cin -1) * (.001 + this...attmul) +1;
    g_ *= (thr/cin -1) * (2* this...attmul) +1;
//    rc = 0;
  );

  
  g_ > 1 ? g_ = 1;
  g_ < .01 ? g_ = .01;
  
  sp2 = flt;
  sp3 = g;
  
  compg[id] = g = g_;
  
);


function comphard_(in id)  // DynaStrip
  instance(ina inag g_ g g0 ovr ovrdb rc tgtg tgtgdb out thr2 cran)(

  thr = this...thr;
  thr2 = thr/2;
  
//  thr = min(1, thr2 *(2+8*(1-thr2)));
  
  
  
  cran = thr-thr2;
  

  ina = abs( in );
  g_ = g0 +1;
  ovr = max(0,(ina-thr2)/cran);
//  ovrdb = max(0, 19.93*log10(ina) - thr2db );
//  ovr = 2^(( (ovrdb-ovrdb/ratio)/crandb )/6);
//  ovr = (ovrdb-ovrdb/ratio)/crandb;
  tgtg = min(1, (thr2 + (cran)* sin(min(1.57, ovr ))  ) /ina );
  tgtgdb = 19.93*log10(tgtg);
  tgtg = 2^(tgtgdb/6);
  
  g_ > tgtg ? (
    g_ -= (g-tgtg) *.5 * this...attmul;
    rc = 0;
  ):(
    rc = min(this...rels , rc += 1);
//    g *= (1- (ina*g)/thr) * (tgtg-g*g) *rels*1.3* (.5-cos((tmp=rc/relspls)*3.14)*.5 ) +1;
//    g *= (1- (ina*g)/thr) * (tgtg-g*g) *rels +1;
//    g_ *= (1- (ina*g_)/thr) * (tgtg-g*g) *rels*2*(tmp=rc/relspls)*tmp +1;
    g_ += ((min(1,tgtg)-g_)+(1-g_))^2 *this...relmul*(tmp=rc/this...rels) ;
  );

  
  g_ > 1 ? g_ = 1;
  g_ < .01 ? g_ = .01;
  
  g0 = g_ -1;
  
  
  
  ratio1 == 1 ? g = g_ :
//    g = g_ + (1-g_)/ratio;
//    g = g_ * ((1/g_-1)/ratio+1);
    g = g_;

  
//  out = in * g * compvol :
//   out = in * ( (g * compvol -1) * ratm +1 );
   
  
  compg[id] = g;
  
);

function eq(in , id)
  instance(out cin dg solog )(
  
  soloid == 0 || soloid == id ? (
    this...shape == 0 || this...shape == 5 ? (  // LP & HP
      out = in * (1-this...blend1) + this...blend1 *  this..p1.eqpole(in,id) ;
      this...poles > 1 ? out = out * (1-this...blend2) + this...blend2 *  this..p2.eqpole(out,id) ;
      this...poles > 2 ? out = out * (1-this...blend3) + this...blend3 *  this..p3.eqpole(out,id) ;
      this...poles > 3 ? out = out * (1-this...blend4) + this...blend4 *  this..p4.eqpole(out,id) ;
      this...poles > 4 ? out = out * (1-this...blend5) + this...blend5 *  this..p5.eqpole(out,id) ;noway
    ) : (
  
      out = this..p1.eqpole(in,id) ;
      
      this...shape == 3 ? out = this..flat.eqpoleFP(out) ;    // FLAT TOP
  
  
      bufdynena[id] == 1 && bufm[id] > 0 ? (

        cin = this..p1.cout * (this...cQ *.1 + .997);
        bufdynknee[id] == 0 ? dg = this.compsoft(cin, id) : dg = this.comphard(cin, id);


        this...gdb < 0 ? dg = 1-dg;
        
        out = out * dg + in * (1-dg)
      );
      
  //    out = dg * out + (1-dg) * in;
  
    );
  //  this...reset = 0;
    soloid == id && bufm[id] > 0 ? (
      bufg[id] == 0 ? solog = 1 :
      bufg[id] > 0 ? (
        solog = 2^( (bufg[id] * dg) /6);
      ):(
        solog = 2^( (bufg[id] * (1-dg) ) /6);
      );
      
      out = this..p1.cout * solog;
    );

  ):(
    out = in;
  );
  
  out;

);



/*
function eq_old(in)
  instance(d0 fd1 fd2 bpout out
    out_ in1 in2 out1 out2
    in1_ in2_ out1_ out2_
    g1tmp 
   )(
  
  this..shape == 2 ? ( // PEAK
    this..g1 != 0 ? (
      g1tmp += 1;
      d0 = this..fk*in - (this..fa1*fd1 + this..fa0*fd2);
      bpout = (d0 - fd2 );
      fd2 = fd1;
      fd1 = d0;
      out =  in + (bpout) * (this..g1);
    ):(
      out = in;
    );
  ) :

  this..shape == 3 ? (  // FLAT TOP

    this..g1 != 0 ? (
      out_ = this..b0*in + this..b1*in1 + this..b2*in2 - this..a1*out1 - this..a2*out2;
      out2 = out1;
      out1 = out_;
      in2 = in1;
      in1 = in;
  
      out = this..b0_*out_ + this..b1_*in1_ + this..b2_*in2_ - this..a1_*out1_ - this..a2_*out2_;
      out2_ = out1_;
      out1_ = out;
      in2_ = in1_;
      in1_ = out_;
    ):(
      out = in;
    );
//    out = out_;

  ) :

  this..shape == 1 || this..shape == 4 ? (  // SHELVES

    this..g1 != 0 ? (
  
      out = this..b0*in + this..b1*in1 + this..b2*in2 - this..a1*out1 - this..a2*out2;
      out2 = out1;
      out1 = out;
      in2 = in1;
      in1 = in;
    ):(
      out = in;
    );
    
  ) :
  
  this..shape == 0 || this..shape == 5 ? (  // LP & HP

    out = in * (1-this..blend1) + this..blend1 *  this.p1.eqpole(in) ;
    this..poles > 1 ? out = out * (1-this..blend2) + this..blend2 *  this.p2.eqpole(out) ;
    this..poles > 2 ? out = out * (1-this..blend3) + this..blend3 *  this.p3.eqpole(out) ;
    this..poles > 3 ? out = out * (1-this..blend4) + this..blend4 *  this.p4.eqpole(out) ;
    this..poles > 4 ? out = out * (1-this..blend5) + this..blend5 *  this.p5.eqpole(out) ;
  );
  
  
  
  out;

);
*/
function eqini_all()(
//  freqmax(points);
  points >= (nei=1) ? eq1.eqini(buff[nei],bufg[nei],bufw[nei]);
  points >= (nei=2) ? eq2.eqini(buff[nei],bufg[nei],bufw[nei]);
  points >= (nei=3) ? eq3.eqini(buff[nei],bufg[nei],bufw[nei]);
  points >= (nei=4) ? eq4.eqini(buff[nei],bufg[nei],bufw[nei]);
  points >= (nei=5) ? eq5.eqini(buff[nei],bufg[nei],bufw[nei]);
  points >= (nei=6) ? eq6.eqini(buff[nei],bufg[nei],bufw[nei]);
  points >= (nei=7) ? eq7.eqini(buff[nei],bufg[nei],bufw[nei]);
  points >= (nei=8) ? eq8.eqini(buff[nei],bufg[nei],bufw[nei]);
  points >= (nei=9) ? eq9.eqini(buff[nei],bufg[nei],bufw[nei]);
  points >= (nei=10) ? eq10.eqini(buff[nei],bufg[nei],bufw[nei]);
);  


function mute(ms)(
  mutespls = srate/1000 * ms;
);


function eqini_one(drag)
  instance()(
//  freqmax(drag);
//  dragstop == 0 ? (
    drag == (nei=1) ? eq1.eqini(buff[nei],bufg[nei],bufw[nei]);
    drag == (nei=2) ? eq2.eqini(buff[nei],bufg[nei],bufw[nei]);
    drag == (nei=3) ? eq3.eqini(buff[nei],bufg[nei],bufw[nei]);
    drag == (nei=4) ? eq4.eqini(buff[nei],bufg[nei],bufw[nei]);
    drag == (nei=5) ? eq5.eqini(buff[nei],bufg[nei],bufw[nei]);
    drag == (nei=6) ? eq6.eqini(buff[nei],bufg[nei],bufw[nei]);
    drag == (nei=7) ? eq7.eqini(buff[nei],bufg[nei],bufw[nei]);
    drag == (nei=8) ? eq8.eqini(buff[nei],bufg[nei],bufw[nei]);
    drag == (nei=9) ? eq9.eqini(buff[nei],bufg[nei],bufw[nei]);
    drag == (nei=10) ? eq10.eqini(buff[nei],bufg[nei],bufw[nei]);
//  drag > 0 && mouse_cap == 0 ? ( reorder_all(); );
//  );
);






function stereo2ms(n)(
//  slider(32+n) == 1 || slider(32+n) == 2 ? (
  bufm[n] == 1 || bufm[n] == 2 ? (
    opM = (spl0 + spl1)*.5;
    opS = (spl0 - spl1)*.5;
    opL = opR = 0;
  ):(
    opL = spl0; opR = spl1;
    opM = opS = 0;
  );
);

function ms2stereo(n)
  instance(n)(
//  slider(32+n) == 1 || slider(32+n) == 2 ? (
  bufm[n] == 1 || bufm[n] == 2 ? (
    spl0 = (opM+opS);
    spl1 = (opM-opS);
    opL = opR = 0;
  ):(
    spl0 = opL;
    spl1 = opR;
    opM = opS = 0;
  );
  
  soloid == n ? (
    soloL = spl0;
    soloR = spl1;
  );
/*
  opL = spl0; opR = spl1;
  opM = (spl0 + spl1)/2;
  opS = (spl0 - spl1)/2;
*/
);
function ms2stereo_wrong(n)
  instance(n)(
//  slider(32+n) == 1 || slider(32+n) == 2 ? (
  bufm[n] == 1 || bufm[n] == 2 ? (
    spl0 = (opM-opS);
    spl1 = (opM+opS);
  ):(
    spl0 = opL;
    spl1 = opR;
  );
  opL = spl0; opR = spl1;
  opM = (spl0 + spl1)/2;
  opS = (spl0 - spl1)/2;
);

function process(id)
  instance(LRg cinL cinR cin solog out)(
  
  bufbyp[id] == 0 && points >= id && (soloid == 0 || soloid == id) ? (
    this.stereo2ms(id);
    bufm[id] == 0 ? (
      bufdynena[id] == 1 && bufg[id] != 0 ? (
        this.Lc.p1.eqpole(opL,id) ;
        this.Rc.p1.eqpole(opR,id) ;
        cinL = this.Lc.p1.cout;
        cinR = this.Rc.p1.cout;
      
        cin = max(abs(cinL),abs(cinR)) * (this.cQ *.1 + .9);
        bufdynknee[id] == 1 ? LRg = this.LR.p1.comphard(cin, id) : LRg = this.LR.p1.compsoft(cin, id);
        
        this.gdb < 0 ? LRg = (1-LRg);

        opL = this.L.a.eq(opL, id) * LRg + (1-LRg) * opL;
        opR = this.R.a.eq(opR, id) * LRg + (1-LRg) * opR;
      ):(
        opL = this.L.a.eq(opL, id);
        opR = this.R.a.eq(opR, id);
        LRg = 0;
      );
      
      soloid == id ? (
        bufg[id] == 0 ? solog = 1 :
        bufg[id] > 0 ? (
          solog = 2^( (bufg[id] * dg) /6);
        ):(
          solog = 2^( (bufg[id] * (1-dg) ) /6);
        );
        
        opL = cinL * solog;
        opR = cinR * solog;
      );
      
    ) :
    bufm[id] == 1 ? (
      opM = this.L.a.eq(opM, id);
      soloid == id ? opS = 0;
    ) :
    bufm[id] == 2 ? (
      opS = this.L.a.eq(opS, id);
      soloid == id ? opM = 0;
    ) :
    bufm[id] == 3 ? (
      opL = this.L.a.eq(opL, id);
      soloid == id ? opR = opL;
    ) :      
    bufm[id] == 4 ? (
      opR = this.L.a.eq(opR, id);
      soloid == id ? opL = opR;
    );
    this.ms2stereo(id);
    
    this.flush > 0 ? this.flush -= flushspd : this.flush = 0;
  );  
  
);


function upauto_new() // new
  instance(nau multi multisin wmul wtmp gn tmp tmp2 autotmp flog flogn)(
  
  this.logging = log10(buff[1]);
  
  autotmp = 0;
  nau = 1;
  loop(points,
/*
W6:
f:20 log10:1.3 autodb:2.5
100 2.0 4
200 2.3 4.5
500 2.7 5
1000 3.0 5.5
2000 3.3 6
4000 3.6 6.5
8000 3.9 6
9000 3.96 5.5
12K 4.08 4.5
15K 4.17 2.5

*/  
    
    bufbyp[nau] == 0 ? (
    
      wmul = (wtmp = bufw[nau]) / (wtmp +1) *1.166;

      flog = ( log10(buff[nau] + 62) - 1.88) / (2.423) *.5 + buff[nau] * .000025;
      flogn = 1-flog;
      
      flog2 = min(1,max(0,flog-.003 )/.85);
      flogn2 = 1-flog2;
      
//      multisin = (.5- cos((multi = min(1, max(0, flog -.07)/.75) ) * 6.28)*.5);
//      multisin = (sin((multi = min(1, max(0, flog -.07)/.75) ) * 3.14));
      multisin = (sin(multi = flog * 3.14));
      multisin = multisin^.5;
//      multisin = multisin + (1-multisin) * (1-multisin) * multisin ;
//      multisin = (.5 +bufw[nau]*.1 -cos((multi = min(1, max(0, flog -.07)/.75)  ) * 3.14 *2)*(.5-bufw[nau]*.03));
      gn = 1- (gp = (bufg[nau]>0) );

  
      bufshape[nau] == 1 ? (
//        gp == 0 ? autotmp += ( (tmp = (flog*2)/(2*flog+1)*2)*tmp*.55 * bufg[nau]) :
//        gp == 0 ? autotmp += .1*(10*(flog) + .3*sin( min(6.28, flog *13))) * bufg[nau] :
//        gp == 0 ? autotmp += (1-((tmp=max(0,flogn-.2)/.8)-.2*flog*tmp*tmp)) * bufg[nau] :
        gp == 0 ? autotmp += (min(1,flog/.8) -.8*(flogn*flogn*flog)) * bufg[nau] :
//        gp == 1 ? autotmp += ( (flog*6)/(1+flog*6)*1.1 + (.2*flog*(1-flog))) * bufg[nau] ;
        gp == 1 ? autotmp += (1-flogn*flogn*flogn*flogn*flogn*flogn*flogn -.8*(flogn*flogn*flog)) * bufg[nau];

      ) :
      bufshape[nau] == 4 ? (
//        autotmp += ((1-flog/(flog+1)*2) * bufg[nau]) ;
//        autotmp += ((1-flog)*(1-flog)*(1-flog)+(.1*flog)) * bufg[nau] ;
//        gp == 0 ? autotmp += (flogn*flogn*flogn*flogn*flogn+(.5*flogn*flog)) * bufg[nau] :
        gp == 0 ? autotmp += (flogn*flogn*flogn*flogn*flogn*flogn*flogn*flogn*flogn+ 1*flogn*flogn*flogn*flog) * bufg[nau] :
//        gp == 1 ? autotmp += ((tmp=2*flogn*flog)*tmp*tmp*tmp + flogn*flogn) * bufg[nau] ;
//        gp == 1 ? autotmp += ((tmp=flogn*flogn*2*flog)*tmp + flogn*flogn) * bufg[nau] ;
//        gp == 1 ? autotmp += bufg[nau] *  (flogn + (flogn*flog*flog) - 2*(1- (1-flogn*flogn*flog)));
//        gp == 1 ? autotmp += (flogn-3*flog*flogn*flogn*flogn*flogn) *  bufg[nau];
//        gp == 1 ? autotmp += ((tmp=max(0,flogn-.2)/.8)-0*.2*flog*tmp*tmp) *  bufg[nau];
//        gp == 1 ? autotmp += 1*(tmp2=(tmp=max(0,flogn-.28)/.72*2)/(1+flogn)) *  bufg[nau];
//        gp == 1 ? autotmp += (2* (tmp=max(0,flogn-.2)/.8) /(1+tmp) -.5*(flogn*flogn*flog)) *  bufg[nau];
        gp == 1 ? autotmp += ((max(0,flogn-.2)/.8) + .5*(flogn*flog)) *  bufg[nau];
        
  
  //      multisin = (.5- cos((multi = min(1, max(0,xpos[nau]/gfx_wlim -.07)/.9)  ) * 3.14)*.5);
      ) :

      bufshape[nau] == 0 ? (
//        autotmp -=  (multisin *3 + multi);
//        autotmp -=  13*(flog/(1+flog)) + .5*sin( min(6.28, flog *17));
        autotmp -=  15*(flog/(1+flog));
      ) :
      
      bufshape[nau] == 5 ? (
        autotmp -= 30*(tmp= max(0,flogn-.2)/(1+flogn))*tmp;
      
      ) : ( // w6: 42%, w5 38, w4 33, w3 28, w2 2.1, w1 1.3
          //    w.5 .7, w.2 .3, w.1 .2.

//        autopeak += bufg[nau] * bufw[nau] *.135 * multisin;
//        autotmp += bufg[nau] * (bufw[nau]-2.5*(bufw[nau]/6)^2 +.15) *.22 * multisin;
//        autotmp += bufg[nau] * (bufw[nau]-2.5*(bufw[nau]/6)^2 +.15) *.15 * multisin;
      
//        autotmp += bufg[nau]*.27 ; // +6dB
//        autotmp += bufg[nau]*.42 ; // +40dB
        autotmp += bufg[nau]*(.2 + bufg[nau]/40 * .2
        
        + .2* (flog2*flogn2*flogn2*flogn2*flogn2*flogn2*flogn2*flogn2*flogn2*flogn2*flogn2
        *flogn2*flogn2*flogn2*flogn2*36 // 95Hz
    //    + 9* flog2*flogn2*flogn2*flogn2 // 580Hz
    //    + 1.5* 6*flog2*flogn2*flogn2 // 1150Hz
        + 2* 26*flog2*flog2*flogn2*flogn2*flogn2 // 1800Hz
        + 2* 9*flog2*flog2*flog2*flogn2 )); // 7500Hz
    
/*
* wmul *
//         (6.5 - 1.6* ABS((tmp= LOG10(buff[nau]) )-3.6) - 8* MAX(0, tmp-3.9) );
//         max(0, 6.5 - 1.6* ABS((tmp= LOG10(buff[nau]) )-3.6) - 40* MAX(0, tmp-3.9)^2 );
         (6-1.8*gn - 1.3* ABS((tmp= LOG10(buff[nau]) )-3.4) -(1+wmul-1.5*gn)*max(0,-tmp+1.9+.5*gn)
         - (5-3*wmul-1.5*gn)* MAX(0, tmp-3.7+.3*gn) - 7*(1+wmul-1.3*gn)*max(0,tmp-4.1+.2*gn));
*/      
      );
      
      
    );
    nau += 1;
  );  
  autopoolpx = (autovoldb = (autotmp)  * max(0,slider41) ) *scaleg;

);

function upauto_orig()
  instance(nau multi multisin wmul wtmp gn tmp tmp2 autotmp flog flogn)(
  
  this.logging = log10(buff[1]);
  
  autotmp = 0;
  nau = 1;
  loop(points,
/*
W6:
f:20 log10:1.3 autodb:2.5
100 2.0 4
200 2.3 4.5
500 2.7 5
1000 3.0 5.5
2000 3.3 6
4000 3.6 6.5
8000 3.9 6
9000 3.96 5.5
12K 4.08 4.5
15K 4.17 2.5

*/  
    
    bufbyp[nau] == 0 ? (

//      flog = ( log10(buff[nau] + 62) - 1.88) / (2.423) *.7 + buff[nau] * .000015;
      flog = ( log10(buff[nau] + 62) - 1.88) / (2.423) *.5 + buff[nau] * .000025;
      flogn = 1-flog;
      
      flog2 = min(1,max(0,flog-.008)/.85);
      flogn2 = 1-flog2;
      
//      multisin = (.5- cos((multi = min(1, max(0, flog -.07)/.75) ) * 6.28)*.5);
//      multisin = (sin((multi = min(1, max(0, flog -.07)/.75) ) * 3.14));
      multisin = (sin(multi = flog * 3.14));
      multisin = multisin^.5;
//      multisin = multisin + (1-multisin) * (1-multisin) * multisin ;
//      multisin = (.5 +bufw[nau]*.1 -cos((multi = min(1, max(0, flog -.07)/.75)  ) * 3.14 *2)*(.5-bufw[nau]*.03));
      gn = 1- (gp = (bufg[nau]>0) );

  
      bufshape[nau] == 1 ? (
//        gp == 0 ? autotmp += ( (tmp = (flog*2)/(2*flog+1)*2)*tmp*.55 * bufg[nau]) :
//        gp == 0 ? autotmp += .1*(10*(flog) + .3*sin( min(6.28, flog *13))) * bufg[nau] :
//        gp == 0 ? autotmp += (1-((tmp=max(0,flogn-.2)/.8)-.2*flog*tmp*tmp)) * bufg[nau] :
        gp == 0 ? autotmp += (min(1,flog/.8) -.8*(flogn*flogn*flog)) * bufg[nau] :
//        gp == 1 ? autotmp += ( (flog*6)/(1+flog*6)*1.1 + (.2*flog*(1-flog))) * bufg[nau] ;
        gp == 1 ? autotmp += (1-flogn*flogn*flogn*flogn*flogn*flogn*flogn -.8*(flogn*flogn*flog)) * bufg[nau];

      ) :
      bufshape[nau] == 4 ? (
//        autotmp += ((1-flog/(flog+1)*2) * bufg[nau]) ;
//        autotmp += ((1-flog)*(1-flog)*(1-flog)+(.1*flog)) * bufg[nau] ;
//        gp == 0 ? autotmp += (flogn*flogn*flogn*flogn*flogn+(.5*flogn*flog)) * bufg[nau] :
        gp == 0 ? autotmp += (flogn*flogn*flogn*flogn*flogn*flogn*flogn*flogn*flogn+ 1*flogn*flogn*flogn*flog) * bufg[nau] :
//        gp == 1 ? autotmp += ((tmp=2*flogn*flog)*tmp*tmp*tmp + flogn*flogn) * bufg[nau] ;
//        gp == 1 ? autotmp += ((tmp=flogn*flogn*2*flog)*tmp + flogn*flogn) * bufg[nau] ;
//        gp == 1 ? autotmp += bufg[nau] *  (flogn + (flogn*flog*flog) - 2*(1- (1-flogn*flogn*flog)));
//        gp == 1 ? autotmp += (flogn-3*flog*flogn*flogn*flogn*flogn) *  bufg[nau];
//        gp == 1 ? autotmp += ((tmp=max(0,flogn-.2)/.8)-0*.2*flog*tmp*tmp) *  bufg[nau];
//        gp == 1 ? autotmp += 1*(tmp2=(tmp=max(0,flogn-.28)/.72*2)/(1+flogn)) *  bufg[nau];
//        gp == 1 ? autotmp += (2* (tmp=max(0,flogn-.2)/.8) /(1+tmp) -.5*(flogn*flogn*flog)) *  bufg[nau];
        gp == 1 ? autotmp += ((max(0,flogn-.2)/.8) + .5*(flogn*flog)) *  bufg[nau];
        
  
  //      multisin = (.5- cos((multi = min(1, max(0,xpos[nau]/gfx_wlim -.07)/.9)  ) * 3.14)*.5);
      ) :

      bufshape[nau] == 0 ? (
//        autotmp -=  (multisin *3 + multi);
//        autotmp -=  13*(flog/(1+flog)) + .5*sin( min(6.28, flog *17));
        autotmp -=  15*(flog/(1+flog));
      ) :
      
      bufshape[nau] == 5 ? (
        autotmp -= 30*(tmp= max(0,flogn-.2)/(1+flogn))*tmp;
      
      ) : ( // w6: 42%, w5 38, w4 33, w3 28, w2 2.1, w1 1.3
          //    w.5 .7, w.2 .3, w.1 .2.

//        autopeak += bufg[nau] * bufw[nau] *.135 * multisin;
//        autotmp += bufg[nau] * (bufw[nau]-2.5*(bufw[nau]/6)^2 +.15) *.22 * multisin;
//        autotmp += bufg[nau] * (bufw[nau]-2.5*(bufw[nau]/6)^2 +.15) *.15 * multisin;
      
        wmul = (wtmp = bufw[nau]) / (wtmp +1) *1.166;
        autotmp += bufg[nau]*.15 * wmul *
//         (6.5 - 1.6* ABS((tmp= LOG10(buff[nau]) )-3.6) - 8* MAX(0, tmp-3.9) );
//         max(0, 6.5 - 1.6* ABS((tmp= LOG10(buff[nau]) )-3.6) - 40* MAX(0, tmp-3.9)^2 );
         (6-1.8*gn - 1.3* ABS((tmp= LOG10(buff[nau]) )-3.4) -(1+wmul-1.5*gn)*max(0,-tmp+1.9+.5*gn)
         - (5-3*wmul-1.5*gn)* MAX(0, tmp-3.7+.3*gn) - 7*(1+wmul-1.3*gn)*max(0,tmp-4.1+.2*gn));
      
      );
      
      
    );
    nau += 1;
  );  
  autopoolpx = (autovoldb = (autotmp)  * max(0,slider41) ) *scaleg ;

);


function upauto_old()
  instance(nau multi multisin tmp flog)(
  
  autohplp = 0;
  nau = 1;
  loop(points,
  
    flog = ( log10(buff[nau] + 62) - 1.88) / (2.423);
    
    bufbyp[nau] == 0 ? (
//      multisin = (.5- cos((multi = min(1, max(0,xpos[nau]/gfx_wlim -.07)/.9)  ) * 3.14)*.5);
      multisin = (.5- cos((multi = min(1, max(0, flog -.07)/.9)  ) * 3.14)*.5);
      
      bufshape[nau] == 0 ? (
        autohplp += multisin *3 + multi;
      ) :
      
      bufshape[nau] == 5 && bufbyp[nau] == 0 ? (
        autohplp += (1-multisin) *3 + multi*.5;
      );
    );
    nau += 1;
  );  
  autopoolpx = (autovoldb = (autopool/gfx_wlim - autohplp*2)  * max(0,slider41) ) * scaleg;
  
);

function upauto_()
  instance(z autonode fgr flog flogn flog2 flogn2 tmp)(

//  autopoolpx = (autovoldb = ((autopoolpri*1.15)/gfx_wlim )  * max(0,slider41) ) *scaleg;
//  autopoolpx = (autovoldb = (automax *.8)  * max(0,slider41) ) *scaleg;
//  autopoolpx = (autovoldb = ((autopoolpri*1.15)/gfx_wlim *.5 + .5* automax*.8 )  * max(0,slider41) ) *scaleg;

  autonode = 0;
  z = 1;
  loop(points,

    bufbyp[z] == 0 ? (
      flog = ( log10( buff[z] + 62) - 1.88) / (2.423) *.5 + buff[z] * .000025;
      
      flogn = 1-flog;
      
//      flog2 = min(1,max(0,flog-.02)/.7);
      flog2 = ((tmp= max(0, flog-.025 * (1-wmul)))*(3-.5*wmul)) / (2*tmp +1);
      flogn2 = 1-flog2;
      
      wmul = bufw[z] / 6 * .9 + .1;
      
      bufshape[z] == 1 ? (
        autonode += flog2 * bufg[z];
      );
    );
    z += 1;
  );
  
  autopoolpx = (autovoldb = (autonode)  * max(0,slider41) ) *scaleg;
  

);

function getxpos(id)
  instance(z)(
  
  id == 0 ? (
    z = 1;
    loop(points,
      xpos[z] = xpos(buff[z]);
      z += 1;
    );
  ):(
    xpos[id] = xpos(buff[id]);
  );
);



function upgraph()
  instance(ngra ytmp flog flogn flog2 flogn2 tmp wmul autotmp lowestval z fltzero gabs grg)(
  
  getxpos(0);

  
  gfx_dest = 2; gfx_setimgdim(2,-1,-1); gfx_setimgdim(2,gfx_wlim,gfx_h*2);

  autopool = autopoolneg = automax = autopoolbas = autopoolmid = autopooltre = lowestval = 0;

  gfx_set(.2,.8,.65,1,0);
//  gfx_line(0,0,fx_w,fx_h); //tmp
  gfx_x = xgr = -2;
  gfx_y = (zerog2 = zerog + gfx_h*.5);
//  n = 1;

  graphmid = graphsid = graphlef = graphrig = 0;
  ypxst = ypxm = ypxs = ypxl = ypxr = 0;
  ypxstold = ypxmold = ypxsold = ypxlold = ypxrold = 0;
  autoabs = automax = automax_ = automul = autovr = autovrneg = autovoldb_ = 0;
  auto1 = auto2 = autoshpool = autoshpool2 = autopoolhi = autoshpool2neg = autoshapearea = maxygr = autolog = 0;
  autoymin = 200;
  autoymax = -200;
  autoshapemax = -200;
//  autopool = 0;
/*
  fltzero = 0;
  z = 1;
  loop(points,
    fltzero = min(bufg[z] , fltzero);
    z += 1;
  );
*/
  while(xgr < gfx_wlim)(  // Pixel loop
    
//    f = ((exp((xgr-3+gfx_wlim/27.5)/wscmou))-1)/800*old_srate+1;
    fgr = ((exp((xgr+gfx_wlim/28.275)/wscmou))-1)/800*old_srate ;
//    autoy = bufg[n]*(2*bufw[n]*4+1)^(-1*(LOG(f)*10-LOG(buff[n])*10)^2 / ((2*bufw[n]*4)^2));
    ygr = yaste = yamid = yasid = yalef = yarig = ygr_ = yaste_ = ycomphplp = yastedyn = 0;

    flog = ( log10(fgr + 62) - 1.88) / (2.423) *.5 + fgr * .000025;
    flogn = 1-flog;
    
//    flog2 = min(1,max(0,flog-.03)/.75);
    flog2 = min(1,max(0,flog-.02)/.9);
    flogn2 = 1-flog2;

    ngra = 1;
    
    loop(points,
      
      ygr = ygr_ = 0;
      bufbyp[ngra] == 0 ? (
      
        gabs = abs(bufg[ngra]);
      
        bufshape[ngra] == 0 ? ( // HP
          x = xpos[ngra];
          ftmp = (x/gfx_wlim)^1 *2;
          f2x = xpos(buff[ngra]* (1.9 + 1.2 / (bufw[ngra]) ) );
          
          xgr < f2x ? (
            ygr_ -= 7* (ytmp= -(xgr-f2x) / (f2x-x) )^(1/ytmp +.8+ 1.5* min(1,bufw[ngra]/5)^.5 ) ;
          );
        ) :


        bufshape[ngra] == 1 ? ( // LSF
          wtmp = max( bufw[ngra] , .05*(abs(gabs)-17) );
          gtmp = (1+ max(0, abs(gabs)-16) *.05);
          xgr < (f1x = xpos[ngra] - gtmp * gfx_wlim * (wtmp/(16+wtmp) +.07) ) ? (
            ygr += gabs ;
          ):(
            xgr < (f2x = xpos[ngra] + gtmp * gfx_wlim * (wtmp/(16+wtmp) +.07) ) ? (
              lshmul = (xgr - f1x) / (f2x-f1x);
              ygr += min(1, 1-(sin(lshmul*3.14-1.57)/2+.5)) * gabs;
            );
          );
        ) :
        bufshape[ngra] == 4 ? ( // HSF
          wtmp = max( bufw[ngra] , .05*(abs(gabs)-17) );
          gtmp = (1+ max(0, abs(gabs)-16) *.05);
          xgr > (f2x = xpos[ngra] + gtmp * gfx_wlim * (wtmp/(16+wtmp) +.07) ) ? (
            ygr += gabs ;
          ):(
            xgr > (f1x = xpos[ngra] - gtmp * gfx_wlim * (wtmp/(16+wtmp) +.07) ) ? (
              lshmul = (xgr - f1x) / (f2x-f1x);
              ygr += min(1, (sin(lshmul*3.14-1.57)/2+.5)) * gabs;
            );
          );
        ) :
        
        bufshape[ngra] == 5 ? ( // LP
//          freqmax = 16500;
          f1x = xpos(buff[ngra]* (.4 - .165 /(bufw[ngra]) ) );
          x = xpos[ngra];
          ftmp = (x/gfx_wlim)^1 *2;
          xgr > f1x ? (
            ygr_ -= 7* (ytmp= (xgr-f1x) / (x-f1x) )^(.9/ytmp +.6 +(ftmp) + .2* bufw[ngra] ) ;
          );
        ) :
        

        bufshape[ngra] == 3 ? ( // Flat Top
          gtmp = gabs/30;
          wtmp = min( bufw[ngra]/6 / (1+ buff[ngra]/20000) , 1 );
          ylin = max(0, (1+.2*gtmp) +.1*wtmp^.5 - abs(log10(fgr)-log10(buff[ngra])) * (1/(.02 + 1.1* wtmp^.6 )) )/ (1+.2*gtmp) ;
          ygr += gabs * (.5-cos( min(1,ylin) *3.14)*.5)^1.5;
          
        ) :

        bufshape[ngra] == 2 ? ( // Peak
          wtmp = bufw[ngra]+.1;
          nar = (gabs/40) * (1-wtmp/6.1);
          lowide = (1-gabs/40) * (wtmp/6.1);
          tmp = abs(log10(fgr)-log10(buff[ngra])) / (wtmp - .1*wtmp*wtmp);
          ylin = max(0, 1+wtmp*.02 - (.95-(.008-.001*wtmp)* abs(bufg[ngra]))* (3*tmp)/(2*tmp+1) );
//          ygr += gabs * (.5-cos(ylin *3.14 *(1.1-wtmp/60) )*.5)^(2-gabs/30) *(1.18-.25*(wtmp/6)^.2) * ylin^(2-wtmp/6) ;
//          ygr += gabs * (.5-cos(ylin *3.14 *(1 +.1 *(gabs/40)*(1-wtmp/6.1)) )*.5)^(2-gabs/30) * ylin^(2-wtmp/6) ;
//          ygr += gabs * (.5-cos(ylin *3.14 )*.5)^(2-gabs/30) * ylin^(2-wtmp/6) ;
//          ygr += gabs * (.5-cos(ylin *3.14 *(1-.2*lowide))*.5) ;
//          ygr += gabs * (.5-cos(ylin *3.14 *(1-.1*lowide))*.5)^(2-gabs/30) * ylin^(2-wtmp/6) ;
//          ygr += gabs * (.5-cos(ylin *3.14 *(1+.2*gabs/40 *(1-wtmp/6.1)) )*.5)^(2-gabs/30)* (1.1-.15*wtmp/6.1) * ylin^(2-wtmp/6) ;
          ygr += gabs * (.5-cos(ylin *3.14 *(1+.2*gabs/40 *(1-wtmp/6.1)) )*.5)^(2-gabs/30)* (.8+.28/(1+wtmp/6.1)) * ylin^(2-wtmp/6) ;

          
        );
      );
      
      ygr != 0 || ygr_ != 0 ? (
        bufm[ngra] == 0 ? (
          bufdynena[ngra] == 1 && dyns > 0 ? (
            bufg[ngra] > 0 ? grg = compg[ngra] : grg = (1-compg[ngra]);
            yastedyn += ygr * sign(bufg[ngra]) * grg ;
          ):(
            grg = 1;
          );
          yaste += ygr * sign(bufg[ngra]) * grg ;
          yaste_ += ygr_;
          maxygr = max(maxygr,abs(ygr));
          
          nonste = 0;
        ):(
          nonste = 1;
          bufdynena[ngra] == 1 && dyns > 0 ? (
            bufg[ngra] > 0 ? grg = compg[ngra] : grg = (1-compg[ngra]);
          ):(
            grg = 1;
          );
          
          ygr *= sign(bufg[ngra]) * grg;
          bufm[ngra] == 1 ? (graphmid = 1; yamid += (ygr+ygr_) ;) :
          bufm[ngra] == 2 ? (graphsid = 1; yasid += (ygr+ygr_) ;) :
          bufm[ngra] == 3 ? (graphlef = 1; yalef += (ygr+ygr_) ;) :
          bufm[ngra] == 4 ? (graphrig = 1; yarig += (ygr+ygr_) ;);
        );
      );
      
      
      ngra += 1;
    ); // end node loop
    
    bypass == 0 || bypass == 2 ? (byp_a = 1; byp_afill = .5;) : (byp_a = .4; byp_afill = .4;) ;

    ypxst = zerog2 - (yaste+yaste_)*scaleg *  +1;
    ypxm = zerog2 - (yamid+yaste+yaste_)*scaleg +1;
    ypxs = zerog2 - (yasid+yaste+yaste_)*scaleg +1;
    ypxl = zerog2 - (yalef+yaste+yaste_)*scaleg +1;
    ypxr = zerog2 - (yarig+yaste+yaste_)*scaleg +1;
    
    
    yz1m = min(ypxst,zerog2);
    yz2m = max(ypxst,zerog2);
    yz1s = min(ypxm,yz1m);
    yz2s = max(ypxm,yz2m);
    yz1l = min(ypxs,yz1s);
    yz2l = max(ypxs,yz2s);
    yz1r = min(ypxl,yz1l);
    yz2r = max(ypxl,yz2l);
    
    mslr = 0;
    
    yarig != 0 ? (
      mslr += 1;
      gfx_set(.8,.2,.1,byp_a,0);
      gfx_rect(xgr-1,min(ypxrold,ypxr)-1, 3,abs(ypxrold-ypxr)+1);
      gfx_set(.5,0,0,byp_afill);
      ypxr < yz1r ? gfx_line(xgr,yz1r,xgr,ypxr) :
      ypxr > yz2r ? gfx_line(xgr,yz2r,xgr,ypxr);
    );
    yalef != 0 ? (
      mslr += 1;
      gfx_set(.2,.3,1,byp_a);
      gfx_rect(xgr-1,min(ypxlold,ypxl)-1, 3,abs(ypxlold-ypxl)+1);
      gfx_set(0,.1,.5,byp_afill);
      ypxl < yz1l ? gfx_line(xgr,yz1l,xgr,ypxl) :
      ypxl > yz2l ? gfx_line(xgr,yz2l,xgr,ypxl);
    );
    yasid != 0 ? (
      mslr += 1;
      gfx_set(.8,.7,0,byp_a);
      gfx_rect(xgr-1,min(ypxsold,ypxs)-1, 3,abs(ypxsold-ypxs)+1);
      gfx_set(.7,.7,0,byp_afill);
      ypxs < yz1s ? gfx_line(xgr,yz1s,xgr,ypxs) :
      ypxs > yz2s ? gfx_line(xgr,yz2s,xgr,ypxs);
    );
    yamid != 0 ? (
      mslr += 1;
      gfx_set(0,.8,0,byp_a);
      gfx_rect(xgr-1,min(ypxmold,ypxm)-1, 3,abs(ypxmold-ypxm)+1);
      gfx_set(0,.8,0,byp_afill);
      ypxm < yz1m ? gfx_line(xgr,yz1m,xgr,ypxm) :
      ypxm > yz2m ? gfx_line(xgr,yz2m,xgr,ypxm);
    );

    gfx_set(.5,1,1,byp_a /(1+.3*(mslr>0)));
    gfx_rect(xgr-1,min(ypxstold,ypxst)-1, 3,abs(ypxstold-ypxst)+2);
    gfx_set(.7,1,1,byp_afill+(1-byp_afill)*.05);
    gfx_line(xgr , zerog2 , xgr,ypxst);

    ypxstold = ypxst;
    ypxmold = ypxm;
    ypxsold = ypxs;
    ypxlold = ypxl;
    ypxrold = ypxr;
    
    yaste -= yastedyn;

    autoshape = 1.78* // autoareapr
    (tmp=flog2*flogn2*flogn2*flogn2*100)/(1+tmp*(1
//    +3*8*flog2*flogn2*flogn2*flogn2*flogn2*flogn2*flogn2
    +17*flog2*flogn2*flogn2*flogn2*flogn2*flogn2*flogn2*flogn2
    +170*flog2*flog2*flog2*flog2*flogn2*flogn2*flogn2*flogn2
//    +100*flog2*flog2*flog2*flogn2*flogn2*flogn2*flogn2
    ));
    
    
    
    autovr += (max(0,yaste-autozero)*.3)^2;
    autovrneg += (autotmp= max(0,autozero-yaste)*.2)/(1+autotmp);

    autopoolhi += max(0,yaste-((autopool-autopoolneg)/gfx_wlim) -6 );
    
    yaste > 0 ? (
      autopool += yaste;
      autoshpool += (yaste * autoshape * min(1, yaste/3));
  //    autoshpool2 += ( max(0,yaste/30)^2 *7 + .1*yaste) * autoshape;
  //    autoshpool2 += ( max(0,yaste/16)^2 ) * autoshape;
  //    autoshpool2 += ( max(0,yaste * (1+ (tmp=yaste*(yaste*.1))/(1+tmp))) ) * autoshape;
  //    autoshpool2 += ( max(0,yaste * (1+ 2*(tmp=yaste*.1)/(1+tmp))) ) * autoshape;
//      autoshpool2 += ( (yaste * (.1+ min(10,yaste*.037))) ) * autoshape;
      autoshpool2 += sqrt( yaste ) * autoshape;
  //    autoshpool2neg += max(0,-yaste)^.5 ;
      
//      autopoolhi += (tmp= max(0, yaste-12)/6)^2 *6;
//      autopoolhi += (tmp= max(0, yaste*autoshape-6)) * (1+.0*1*tmp);
    ):(
      autopoolneg += max(0,-yaste-yaste_) ;
      autoshpool2neg += (tmp=(-yaste)*autoshape) / (1+ .01*tmp) ;
    );
//    yaste += .5* max(-yaste,yaste_);
//    fgr > 50 && fgr < 12000 ? ( 
//      autoymin = min(autoymin,(yaste-autoymin)*autoshape);
      autoymin = min(autoymin,(yaste+yaste_));
      autoymax = max(autoymax,yaste+yaste_);
//    );
//    yaste *= 1/ (1-yaste_ *.2);
//    yaste += max(-yaste,yaste_);
    autoshapearea += autoshape;
//    autopool += (tmp = yaste * autoshape) * (2^(tmp/6));
    autoshapemax = max((autoshapemax),(autoshape*yaste));
//    autoshapemax = max(abs(autoshapemax),abs(autoshape*yaste)) * sign(autopool);
//    autopool += (2^((yaste * autoshape)/6)) -1;
//    autopool += (yaste * (.5 +yaste*.02) * autoshape);
//    autopool += (yaste * autoshape);
/*
    yaste > 0 ? autopool += (yaste + .5* (2^(yaste/6)-1) ) * autoshape :
    autopoolneg += (-yaste + .5* (2^(abs(yaste)/6)-1) ) * autoshape;
*/    
//    yaste > 0 ? autopool += (yaste*max(0,yaste+yaste_)) : autopoolneg -= yaste;
//    autopoolneg +=  abs(yaste_)^(1-.4*autoshape);
    
//    autolog += 2^((yaste*autoshape)/6) ;
    autolog += 2^((yaste)/6) ;
    
//    gfx_line(xgr,zerog2,xgr,zerog2-zerog2*(autoshape^1 * .4));
    
    xgr += 1;    
  ); // end pixel loop

  autolevel = ( 1/(1+.005*(autoymax-autoymin)^2) )^.5;
//  autolevel = 1/(1+.000001*(autoshpool+autoshpool2neg+1)^2);
  
/*
//  autopkpr = (tmp=autopool/gfx_wlim) / maxygr;
//  autopkpr = (autopool/autoshapearea /autoymax);
  autopkpr = (autoshapemax/autoshapearea /autoymax);
//  autopkpr = (tmp=autopool/gfx_wlim*1.6);
  
//  autovoldb = autopool/gfx_wlim / (autopkpr + .04*(1-autopkpr) );
//  autovoldb = (tmp -yastemin ) * (autopkpr^.5 / autopkpr) ;
//  autovoldb = (autopool/autoshapearea)*.66 ;
//  autovoldb =  (autoshapemax*.7 + .3*(autopool/autoshapearea)*.45 *2^(.1*autoshapemax/6) ) ;
  autoshapeflt = autoshapemax-autoymin; // howto negative shape???
  autopoolflt = autopool + (autoymin * autoshapearea - autopoolneg);
  autovoldb =  (autoshapeflt*1 + 0*.3*(autopoolflt/autoshapearea)*.45 *2^(.1*autoshapeflt/6) ) 
    + autoymin;
//  autovoldb = 19.93* log10(autovol);
  
  autovoldb = 19.93 * log10( (autolog*1.9) /gfx_wlim ) *0;
*/
//  autostraightmul = 1/ (autoshapemax*.3);
   autostraightmul = (1/ (1+ 2* sqrt(autoymax-autoymin)) );
   autoshapemul = (autoshpool/(autopool*.89));
//   autoshmaxmul = (.3 + .7*(auto4=autoshpool/(gfx_wlim*21))) 
//    + (1-auto4)*.2* (autoshapemax/40)^1;
   autoshmaxmul = (1) 
    + .2* (autoshapemax/40)^1;
//   autoshmaxmul = 1 + .2* (autoshapemax/40)^1;
    autoshpool3 = autoshpool*.2+.8*autoshpool2;
   auto3 = autoshpool2/autoshpool2;
   

//  autopkpr = (autoymax-autoymin) / max(abs(autoymax),abs(autoymin));
  autoareapr = (((autopool)/gfx_wlim) / max(abs(autoymax),abs(autoymin)))^(
//  1 + 0*autoymax/30);
  1);
//  autovoldb = (autoymax-autoymin) * sign(autopool-autopoolneg);
  autovoldb_ = (
//   autoshapemax *.5 * min(1,autopkpr)
//   19.93 * log10( (autolog*1) /gfx_wlim) * min(1,autopkpr)
/*
   autoshapemax * (1- (autopool/gfx_wlim)/(autoymax) ) * min(1,autopkpr)
   + max(0, 1-autopkpr) * (autopool-autopoolneg)/gfx_wlim // Levels ++ shelves
*/
/*
//   autoshapemax* .6 * (1- autoareapr )
   autoshapemax* .5 * (1- autoareapr^(1 + 0*autoymax/30) ) // Small area
//   + (autopool/gfx_wlim) * autoareapr // Levels ++ shelves
   + (autopool/gfx_wlim) * autoareapr // Levels ++ shelves
   + ( max(0,autoshapemax-autoymax*.5)*.35 * autoareapr*(1-autoareapr)*4)
*/


/*
    //BEST SO FAR
    (autopool/gfx_wlim)
    + .2*(auto1=(auto2=autoshapemax-0*.5*autoymin-(autogw=autopool/gfx_wlim))*.04)/(auto1 +1) * auto2
    + .5*(tmp1 = .00007*(tmp2=autoshpool))/(tmp1+1) * (autoshapemax-(autopool/gfx_wlim))
//    - .5* abs(autoymin)^.75
    - 16* (auto3=max(0,autopoolneg-autopool)/gfx_wlim *.04 )/(auto3+1)
    + 1* min(0,autoymax)
*/   

//    (autolog-gfx_wlim-1.6437)
//    ((autolog)/gfx_wlim-1)

//    atan((tmp1=autopool/gfx_wlim) * .1) * (tmp1)

/* //   PROMISING
//    autoshmaxmul = 1 + .2* (autoshapemax/40)^2;
//    (1-auto1=(autoymax-autoymin)/80)^2 * (auto2=autopool/gfx_wlim) // Straight
    autostraightmul * (auto2=(autoymax-(autoymax-autoymin))) // Straight
//    + autostraightmul * (auto3=autoshapemax*.04)/(auto3+1) *3.2 * autoshapemax
    +(1-autostraightmul) * autoshapemul* (
      autoshmaxmul*(autoshapemax*.2+.8*autoymax)*.55 + .55* (autoshpool)/gfx_wlim  )
//      autoshmaxmul*(autoshapemax*.2+.8*autoymax)*.2 + .8* (autoshpool)/gfx_wlim  )
*/    

//    (autop=((autoshpool-autoshpool2)*2.7-autopoolneg)/gfx_wlim)
//    (autop=((autoshpool2)*2.2-autopoolneg)/gfx_wlim)
//    (autop=((autoshpool)*1.2-autopoolneg)/gfx_wlim)
//    (autop=((autoshpool3)*2.0-autopoolneg)/gfx_wlim)
//    (auto1=(autopool-autopoolneg)/gfx_wlim)
//    (autopool-autopoolneg/(auto3= (1+10*((autoymax-autoymin)*.02)^3)) )/gfx_wlim
    

//    + ((auto3= (autoymax-autop) )+(auto3*.1*0)^1.2 ) *(.15 + .8*(autoshpool/(autoshapearea*40)))
/*
//    (auto1=(autopool+0*autopoolneg)/gfx_wlim) + .5* (autoymax-auto1)
    (auto1=(autoshpool-autoshpool2neg)/gfx_wlim)
//    + ((autoymax+autoymin)/2-auto1) * (auto2=1/(1+.1*(autoymax-autoymin))) 
    + .5 * ((autoymax)-auto1)
//    + (autovr-autovrneg*.0)/gfx_wlim 
*/
//    (auto1 = ( ((autopool )-autoshpool2neg *.9 )/(gfx_wlim+2) ))
//    + autolevel * (autoymax+autoymin)*.5;
//    + autolevel * (autopool-autopoolneg)/gfx_wlim;
//    + autolevel * (autopool-autoshpool2neg)/gfx_wlim;
//    (auto1 = ( ((autopool )-autopoolneg *.9 )/(gfx_wlim+2) ))
    + (.5+.5*autolevel) * (autopool-autopoolneg)/gfx_wlim
    + (1-autolevel) * autopoolhi/gfx_wlim 
      
//    autolevel * (auto1=((autoshpool *1.2)-autoshpool2neg * 1.6)/gfx_wlim )
//    autolevel * (auto1=((autoshpool2 *6.7)-autoshpool2neg * 1.6)/gfx_wlim ) 
//    + (auto2 = (autoymax-auto1) *.1)/(1+auto2)/auto2 * (autoymax-auto1)
//    + min(1, (auto2 = (autoymax-auto1) *.03)^1.5 /auto2) * (autoymax-auto1)
//    + ( (auto2 =(autoymax-auto1)/16)  / (1+auto2)) * (autoymax-auto1)
//    + ( (auto2 =(autoymax-auto1)/16)  / (1+auto2)) *.8* (autoymax-auto1)
//    + autopoolhi/gfx_wlim *2
//    - max(0, autoymin)
//    + ((auto2=(autoymax-auto1)/20)-( (auto2) / (1+auto2)) ) *20
//    + 1 *(autopoolhi/gfx_wlim) 

//    + ((autoymax+autoymin)/2-auto1) * (autolevel) 
     

    
    );
    autopoolpk = autoymax - (autopool/gfx_wlim) ;

//   auto2 = (auto3= (autoymax+autovoldb)) / (1+auto3/12) ;
//  autovoldb = autovoldb_ + ((autopool/gfx_wlim -autovoldb_)-auto2);

//    auto2 = (auto3= (autoymax+autovoldb_)) / (1+auto3/24) ; // autoymax-autovoldb_vvv
//    autovoldb = autovoldb_ + ((autoymax -autovoldb_)-auto2);
   
//    auto2 = (auto3= autovoldb_ +(autoymax-autovoldb)*.5) / (1+auto3/12) ; 
//    autovoldb = autovoldb_ + ((autoymax -autovoldb_)-auto2);
//    autovoldb = autovoldb_ + ((autoymax -autovoldb_)*.5);
//    autovoldb = autovoldb_ * ( (autovoldb_/autoymax)^.5 / (autovoldb_/autoymax) );
//    autovoldb = autovoldb_ + .5* autopoolhi/gfx_wlim;
//    auto2 = ( (autoymax-autovoldb_)- (auto3= autoymax-autovoldb_) / (1+abs(auto3)/48) ); 
    auto2 = ( (autoymax-autovoldb_)- (auto3= autoymax-autovoldb_) / (1+abs(auto3)*.1) ); 
    autopoolhimul = max(0, (autopoolhi)/(1+(autoymax-autovoldb_)*gfx_wlim) *3);
  
    autovoldbold = autovoldb;    
     autovoldb = autovoldb_ +auto2*1+0 * (autopoolhimul) +0*1*(autopoolhi/gfx_wlim);
//   autovoldb += (autovoldb - auto2);
//  autovoldb += ((autoymax-autovoldb)-auto2);
   
    autovoldb *= max(0,slider41);
   


//  autopoolpx = (autovoldb = (automax*(.25 + .75*autopool/gfx_wlim ))  * max(0,slider41) ) *scaleg;
    autopoolpx = (autovoldb    ) *scaleg ;

  willdrawpoints = 1;
//  willupauto = 1;
  gfx_dest = -1;

);

function upauto()( 
//  upgraph();
  p=0;
);


//gmem[0] != gmemold ? gmaster = 2; // Someone else Mastered

function drawpoint(f g ndrw)
  instance(x y x1 x2 y1 y2 r r2 s nstr poa ndrw gr thi)(
  gfx_dest = 6;
  
  ndrw >= 10 ? gfx_setfont(15) : gfx_setfont(11);
  
  x = xpos[ndrw] = xpos(f);
  
  bufshape[ndrw] == 0 || bufshape[ndrw] == 5 ? (
    y = ypos[ndrw] = zerog - (-6)*scaleg + autopoolpx;
  ):(
    y = ypos[ndrw] = zerog - g*scaleg + autopoolpx;
  );
  r = 7*ret;
  r2 = 3*ret;

  f > 20000 ? poa = 0 : poa = 1;

  multiedit == 1 ? (
    orpo = multiselect[ndrw];
  ):(
    (showbox > 0 && ndrw == dragprev) ? orpo = 1 : orpo = 0;
  );
  
  // Gray Edge
  gr = .1;
  gfx_set(gr,gr/2,0,1,0);
  gfx_circle(x,y, r+2*ret ,1,1);

  // Inner Edge
  bufbyp[ndrw] == 0 ? (
    orpo == 1 ? (
      bufdynena[ndrw] == 1 ? gfx_set(1,.9,1,1,0) : gfx_set(1,1,.9,1,0);
    ):(
      bufdynena[ndrw] == 1 ? gfx_set(1,.0,0,1,0) : gfx_set(7,0,0,1,0);
    );
  ):(
    bufdynena[ndrw] == 1 ? gfx_set(.0,.3,1,1,0) : gfx_set(.5,0,0,1,0);
  );
  gfx_circle(x,y, r+1*ret ,1,1);

  // Eq Link Indicators
  (gmaster == 1) || (gmaster == 2 && slider(4+(ndrw-1)*4) > 0) ? 
//  (gmaster != 0 && slider(4+(ndrw-1)*4) > 0) || (gmaster == 1 && buflm[ndrw] == 0) ? 
    gfx_set(.0,.5,0,poa,0) :
    gfx_set(.0,.4,1,poa,0);

  (gmaster == 1 && buflm[ndrw] == 0) || (gmaster == 2 && bufl[ndrw] != 0) ? (
//  gmaster != 1 || buflm[ndrw] == 0 ? (
    mygmem >= 0 ? (
      s = r+ret;
      loop(2*ret,
        gfx_circle(x,y,s);
        s += 1;
      );
    );
  );

  // Eq Mode Indicators
  thi = 3*ret;
  gfx_set(1,.2,.1,poa,0);
  bufm[ndrw] == 1 ? (
    s = r+r2;
    loop(thi,
      gfx_arc(x,y,s, -.7,.7,1);
      s += 1;
  ););
  bufm[ndrw] == 2 ? (
    s = r+r2;
    loop(thi,
      gfx_arc(x,y,s, -2.25,-1,1);
      gfx_arc(x,y,s, .9,2.3,1);
      s += 1;
  ););
  bufm[ndrw] > 2 ? (
    loop(thi,
      gfx_arc(x,y,r+r2, rad1= -2.3 +(bufm[ndrw]==4?3.15:0), rad1+1.45 ,1);
//      gfx_arc(x,y,r+r2, 1.1,2.1,1);
      r2 += 1;
  ););

  
/*
  multiedit == 1 ? (zmu = multiselect[ndrw]);
//  zmu = multiselect[ndrw];
  zmu == 1 || ndrw == dragprev ? (
*/

  
  // Point color
  orpo == 1 ? (
    bufdynena[ndrw] == 1 ? (
      bufbyp[ndrw] == 1 ? gfx_set(.6,.75,.75,1,0) : gfx_set(0,.8,1,1,0);
    ):(
      bufbyp[ndrw] == 1 ? gfx_set(.75,.65,.55,1,0) : gfx_set(.9,.6,.0,1,0);
    );
  ):(
    bufdynena[ndrw] == 1 ? (
      bufbyp[ndrw] == 1 ? gfx_set(.3,.3,.3,1,0) : gfx_set(.0,.6,1,1,0);
    ):(
      bufbyp[ndrw] == 1 ? gfx_set(.3,.3,.3,1,0) : gfx_set(.8,.2,.1,1,0);
    );
  );
  gfx_circle(x,y, r ,1,1);
  sprintf(nstr,"%.f",ndrw);
  
  bufbyp[ndrw] == 1 ? gfx_set(0,0,0,.5,0) : gfx_set(0,0,0,1,0);
  gfx_x = x - gfx_texth*0.25 -ret - (ndrw >= 10) * gfx_texth*.27;
  gfx_y = y - gfx_texth*0.5 -ret/2;
  ndrw == 2 ? gfx_x += ret/2 :
  ndrw == 3 ? gfx_x += ret;
  gfx_drawstr(nstr,256,gfx_x,gfx_y);
  
  x1buf[ndrw] = x -r -poimoupad;
  x2buf[ndrw] = x +r +poimoupad;
  y1buf[ndrw] = y -r -poimoupad;
  y2buf[ndrw] = y +r +poimoupad;

  gfx_dest = -1;
);


function drawpoints()
  instance(n)(
  
//  n = 1;
//  loop(points,
  gfx_setimgdim(6,-1,-1);   gfx_setimgdim(6,gfx_wlim,gfx_h); 

  points > 0 ? eq1.drawpoint(buff[1],bufg[1] ,1);
  points > 1 ? eq2.drawpoint(buff[2],bufg[2] ,2);
  points > 2 ? eq3.drawpoint(buff[3],bufg[3] ,3);
  points > 3 ? eq4.drawpoint(buff[4],bufg[4] ,4);
  points > 4 ? eq5.drawpoint(buff[5],bufg[5] ,5);
  points > 5 ? eq6.drawpoint(buff[6],bufg[6] ,6);
  points > 6 ? eq7.drawpoint(buff[7],bufg[7] ,7);
  points > 7 ? eq8.drawpoint(buff[8],bufg[8] ,8);
  points > 8 ? eq9.drawpoint(buff[9],bufg[9] ,9);
  points > 9 ? eq10.drawpoint(buff[10],bufg[10] ,10);
);

function reorder_all()
  instance(n stop tmpf tmpg tmpw tmpm tmpl tmplm tmps tmpbyp tmpmulsel tmpena tmpthr tmpsol tmpatt tmprel tmpknee )(
  
  
  (gmaster != 2 || gmem[color*100] == 0) && points > 1 ? (
    n = 1;
    stop = 0;
    while(stop < points)(
      buff[n+1] < buff[n] ? (
        dragprev == n ? (forcedragprev = (dragprev += 1) ):
        dragprev == (n+1) ? (forcedragprev = (dragprev -= 1) );
        tmpf = buff[n];
        tmpg = bufg[n];
        tmpw = bufw[n];
        tmpm = bufm[n];
        tmpl = bufl[n];
        tmplm = buflm[n];
        tmps = bufshape[n];
        tmpbyp = bufbyp[n];
        tmpmulsel = multiselect[n];
        tmpena = bufdynena[n];
        tmpthr = bufdynthr[n];
        tmpsol = bufdynsol[n];
        tmpatt = bufdynatt[n];
        tmprel = bufdynrel[n];
        tmpknee = bufdynknee[n];
        
        buff[n] = buff[n+1];
        bufg[n] = bufg[n+1];
        bufw[n] = bufw[n+1];
        bufm[n] = bufm[n+1];
        bufl[n] = bufl[n+1];
        buflm[n] = buflm[n+1];
        bufshape[n] = bufshape[n+1];
        bufbyp[n] = bufbyp[n+1];
        multiselect[n] = multiselect[n+1];
        bufdynena[n] = bufdynena[n+1];
        bufdynthr[n] = bufdynthr[n+1];
        bufdynsol[n] = bufdynsol[n+1];
        bufdynatt[n] = bufdynatt[n+1];
        bufdynrel[n] = bufdynrel[n+1];
        bufdynknee[n] = bufdynknee[n+1];
        
        
        buff[n+1] = tmpf;
        bufg[n+1] = tmpg;
        bufw[n+1] = tmpw;
        bufm[n+1] = tmpm;
        bufl[n+1] = tmpl;
        buflm[n+1] = tmplm;
        bufshape[n+1] = tmps;
        bufbyp[n+1] = tmpbyp;
        multiselect[n+1] = tmpmulsel;
        bufdynena[n+1] = tmpena;
        bufdynthr[n+1] = tmpthr;
        bufdynsol[n+1] = tmpsol;
        bufdynatt[n+1] = tmpatt;
        bufdynrel[n+1] = tmprel;
        bufdynknee[n+1] = tmpknee;
        
        drag = forcedragprev;
  //      addad += 1;
        upsliders();
        eqini_all();
        compini_all();
        mutespls = 200;
        
  //      upgraph += 2;
        stop = 0;
        
//        mute(1);
  //      dragprev = 1;
      ):(
        stop += 1;
      );
      (n += 1) >= points ? n = 1;
    );
    willdrawbox = 1;
//    forcedragprev3 = forcedragprev;
    drawpoints();
    
    dragprev > 0 ? slider_automate(slider(1+(dragprev-1)*4));
  );
);

function selectother()
  instance(n nn na nb)(
//  n = dragprev;
//  n == 0 ? 
  n = dragprevold;


  points == 2 || multis == 2 ? (
    multiselect[n] = multiedit = 0;
    nn = multis = 1;
    loop(points,
      multiedit > 0 ? (
        multiselect[nn] > 0 ? forcedragprev2 = nn :
        showbuf[nn] > 0 ? forcedragprev2 = nn;
      );
      nn += 1;
    );
  ) :

  points > 2 ? (
    multiedit == 0 ? (
      na = n-1;
      nb = n+1;
    ):(
      nn = n;
      while(nn >= 0)(
        na = nn-1;
        multiselect[na] > 0 ? nn = -1 : nn -= 1;
      );
      nn = n;
      while(nn <= points)(
        nb = nn+1;
        multiselect[na] > 0 ? nn = (points+1) : nn += 1;
      );
    );
    n > 1 && ( (points == n) || ((x1buf[n] - x1buf[na]) < (x1buf[nb] - x1buf[n]))  )? (
//      || (multis >= 1 && multiselect[n+1] == 0) ? (
      forcedragprev2 = n-1;
    ):(
      forcedragprev2 = n;
    );
  ) :

  points <= 1 ? forcedragprev2 = forcedragprev = dragprev = 0 ;
 
      
/*    
//      multiselect[forcedragprev2] = 1;
    ):(
      dragprevold > n ? forcedragprev2 = dragprevold -1;
      (dragprevold < n) && (dragprevold > 0) ? forcedragprev2 = dragprevold;
    );
  );
*/
);

function selectother_(n)(
  points > 2 ? (

    dragprevold == n ? (
      (points == n) || ((x1buf[n] - x1buf[n-1]) < (x1buf[n+1] - x1buf[n]))
      || (multis >= 1 && multiselect[n+1] == 0) ? (
        forcedragprev2 = n-1;
      ):(
        forcedragprev2 = n;
      );
//      multiselect[forcedragprev2] = 1;
    ):(
      dragprevold > n ? forcedragprev2 = dragprevold -1;
      (dragprevold < n) && (dragprevold > 0) ? forcedragprev2 = dragprevold;
    );

  ):(
    dragprev > 0 ? forcedragprev2 = points-1;
  );
);

function nearest()
  instance(z)(
  multinext = multiprev = 0;
  z = dragprev+1;
  while(z <= points)(
    bufbyp[z] != 99 ? (
      (multiedit > 0 && multiselect[z] > 0) || multiedit == 0 ? (
        multinext = z;
        z = points;
      );
    );
    z += 1;
  );
  z = dragprev-1;
  while(z > 0)(
    bufbyp[z] != 99 ? (
      (multiedit > 0 && multiselect[z] > 0) || multiedit == 0 ? (
        multiprev = z;
        z = 0;
      );
    );
    z -= 1;
  );
  multinext == 0 ? dragprev = multiprev:
  multiprev == 0 ? dragprev = multinext:
  (xpos[multinext] - xpos[dragprev]) > (xpos[dragprev] - xpos[multiprev]) ? 
    dragprev = multiprev :
    dragprev = multinext;
  dragprev;
);


function rempoint(n)
  instance(n s)(

  removing == 0 ? (
    dragprev == n ? (
      dragprev = nearest();
    );  
//    s = (dragprev > 0 ? (dragprev-1) : (drag-1) );
    multiselect[n] > 0 ? (
      multis > 1 ? (
        (multis -= 1) < 2 ? (
          multiedit = 0;
        );
      );
    );

/*
    points == 1 ? multis = 0;
//      multiedit > 0 ? (multis -= 1) < 2 ? multiedit = 0;

//    multiselect[n] = 0;    
//    selectother(n);
    dragprevold == n ? (
      selectother();
    ):(
      dragprevold > n ? forcedragprev2 = dragprevold-1;
    );
*/


//    dragprev > n ? (forcedragprev2 = (dragprev -= 1));
//    dragprev < n ? (forcedragprev2 = dragprev);
    s = n-1;
    bufbyp[n] = 1;
    slider(1+s*4) = buff[n] = 20001;
    slider(2+s*4) = bufg[n] = 0;
    slider_automate(slider(1+s*4));
    slider_automate(slider(2+s*4));
    multiselect[n] = 0;
//    eqini_all();
    reorder == 1 ? reorder_all();
//    forcedragprev = forcedragprev2;
    slider63 -= 1;
    slider_automate(slider63);
    points = max(0,slider63);
//    n == points ? points -= 1;
    removing = 1;
//    upgraph = 2;
  );
  willdrawpoints = 1;
  points == 0 ? (
    upgrid = 1;
    gmaster = slider49 = 0;
    slider_automate(slider49);
  );
);


function addpoint(f mouseg link select)
  instance(z zg1 zg2)(
//  dragprev = 0;
  slider63 < maxpoints ? (
    slider63 < 1 ? slider63 = 1 : slider63 += 1;
    slider_automate(slider63);
    points = slider63;
    
    multis = multiedit = 0;
    z = 1;
    loop(points,
      multiselect[z] = 0;
      z += 1;
    );
    
    
    f == 0 ? (
      slider(1+(points-1)*4) = buff[points]
//       = ((exp(( (mouse_x) -3+gfx_wlim/27.5)/wscmou))-1)/800*old_srate+1;
       = ((exp(((mouse_x )-0*3+gfx_wlim/28.275)/wscmou))-1)/800*old_srate+1*0 ;
    ):(
      slider(1+(points-1)*4) = buff[points] = f;
    );
    slider_automate(slider(1+(points-1)*4));
    
//    buff[1] = slider1;
    
    
    mouseg == 1 &&
//    (mouse_y > (zg1=zerog + 5*ret) || mouse_y < (zg2=zerog - 5*ret) ) &&
    (mouse_y > (zg1=zerog+autopoolpx) + (zg2=5*ret) || mouse_y < (zg1 - zg2) ) ? (
//    (mouse_y > zg1+autopoolpx || mouse_y < zg2+autopoolpx ) ? (
      slider(2+(points-1)*4) = bufg[points] = (zerog-mouse_y+autopoolpx) / scaleg;
    ):(
      slider(2+(points-1)*4) = bufg[points] = 0;
    );
    slider_automate(slider(2+(points-1)*4));

    
    slider(3+(points-1)*4) = bufw[points] = 1;

//    bufm[points] = 0;
    bufm[points] = modeana;
//    (gmaster == 2 && waszero == 0) || link == 0 ? (
/*
    (gmaster == 2 && waszero == 0) ? (
      slider(4+(points-1)*4) = bufl[points] = 0;
//        ownpoints += 1;
    ):(
*/
    slider(4+(points-1)*4) = bufl[points] = link;
//        bufl[points] == 0 ? ownpoints += 1;
//    );
    slider_automate(slider(4+(points-1)*4));
    
    buflm[points] = 0;
//      bufshape[dragprev] < 2 ? bufshape[points] = bufshape[dragprev];
    dblclk > 0 && gmaster != 2 ? (
//      mouse_y < (zerog+autopoolpx) ? (
      mouse_y < (gfx_h *.8) ? (
        mouse_x > xpos(10000) ? bufshape[points] = 4 :
        mouse_x < xpos(200) ? bufshape[points] = 1 :
        mouse_y < (zerog+autopoolpx) ? bufshape[points] = 3 : bufshape[points] = 2;
      ):(
        mouse_x > xpos(10000) ? bufshape[points] = 5 :
        mouse_x < xpos(200) ? bufshape[points] = 0 :
        bufshape[points] = 2;
      );
      upgraph();
    ):(
      bufshape[points] = 2;
    );        

//    drag = dragtaken = dragprev = points;
    dragtaken = drag = 0;
    dragprev = points;
    added = 1;
    
    bufdynatt[points] = .2;
    bufdynrel[points] = .5;
    bufdynthr[points] = 1;
    bufdynknee[points] = 0;
    bufdynena[points] = 0;
    bufdynsol[points] = 0;
    willdrawdyn = 1;
    showdyn = 0;
    compini_1(points);
  );
//  forcedragprev2 = points;
  
  select == 1 ? (
    dragprev = points;
    multiselect[points] = 1;
    showbox = multis = 1;
  );

  

//  drag = dragtaken = points;
  gmaster != 2 ? (
    upbufs();
    reorder == 1 ? reorder_all();
  );



  bufbyp[dragprev] = 0;
//  forcedragprev2 = dragprev;

  willdrawbox += 1;
  
  upgraph += 1;
  
  points == 1 ? upgrid = 1;
  
  eqini_one(points);
  
);

function newpoints()
  instance(fa fa1)
//  globals(bufshape dragprev upmaster bufl points slider63 )
  (

/*
  fa = 100;
  fa1 = 1;
  loop(4,
    addpoint(fa,0,1,0);
//    bufl[fa1] = 1;
    fa == 3500 ? fa = 10000;
    fa == 800 ? fa = 3500;
    fa == 100 ? fa = 800; 
    fa1 += 1;
  );
*/
  points = slider63 = 0;
  addpoint(100,0,1,0);
  addpoint(800,0,1,0);
  addpoint(3500,0,1,0);
  addpoint(10000,0,1,0);
  bufshape[1] = 1;
  bufshape[2] = 2;
  bufshape[3] = 3;
  bufshape[4] = 4;
  upsliders();
  
  dragprev = 0;
  drawpoints();
  upmaster += 1;
  
);

/*
function import()
  instance(p)(
  imported += 1;
  _impoints = points = slider63;
  
  _impf1 = slider1;
  _impf2 = slider5;
  _impf3 = slider9;
  _impf4 = slider13;
  
  _veroldwas = verold;
  _sli33was = slider33;
  _sli37was = slider37;
  
  _impbuff0 = buff;
  
  
  (verold < .835 && slider33 < 20 && slider37 < 20) ? (
    imported.83 += 1;
    upbufs();
    p = 1;
    loop(maxpoints,
      shapeold[p] = bufshape[p];
      bufshape[p] == 0 ? bufshape[p] = 2 :
      bufshape[p] == 1 ? bufshape[p] = 3 :
      bufshape[p] == 2 ? bufshape[p] = 1 :
      bufshape[p] == 3 ? bufshape[p] = 4;
      shapemold[p] = bufm[p];
      bufm[p] = slidold[p] = slider(32+p);
      p += 1;
    );
  ) :

  (verold < .845 && slider33 > 19 && slider37 > 19) ? (
    imported.84 += 1;
    importing.84 = 1;
    upbufs();
    importing.84 = 0;
//      eqini_all();
    
    bufmwas1 = bufm[1];
    bufmwas2 = bufm[2];
    bufmwas3 = bufm[3];
    bufmwas4 = bufm[4];
    bufmwas5 = bufm[5];
    bufmwas6 = bufm[6];
    bufmwas7 = bufm[7];
    bufmwas8 = bufm[8];
  ) :
  
  verold < .855 ? (
    slider41 == 1 ? slider41 = 0 :
    slider41 == 0 ? slider41 = 1;
    noauto = slider41;
    slider50 == 1 ? slider50 = 0 :
    slider50 == 0 ? slider50 = 1;
    noanal = slider50;
    upgrid = 1;
  );
  
  
  
  
  _imp2f1 = slider1;
  _imp2f2 = slider5;
  _imp2f3 = slider9;
  _imp2f4 = slider13;
  _impbf1 = buff[1];
  _impbf2 = buff[2];
  _impbf3 = buff[3];
  _impbf4 = buff[4];
  
  
  shapemold1 = shapemold[1];
  shapemold2 = shapemold[2];
  shapemold3 = shapemold[3];
  shapemold4 = shapemold[4];
  shapemold5 = shapemold[5];
  shapemold6 = shapemold[6];
  shapemold7 = shapemold[7];
  shapemold8 = shapemold[8];

  slidold1 = slidold[1];
  slidold2 = slidold[2];
  slidold3 = slidold[3];
  slidold4 = slidold[4];
  slidold5 = slidold[5];
  slidold6 = slidold[6];
  slidold7 = slidold[7];
  slidold8 = slidold[8];
/*
  verold <= .845 ? (
    imported.84 += 1;
    p = 1;
    loop(maxpoints,
      shapeold[p] = bufshape[p];
      bufshape[p] == 1 ? bufshape[p] = 2 :
      bufshape[p] == 2 ? bufshape[p] = 0 :
      bufshape[p] == 3 ? bufshape[p] = 1 :
      bufshape[p] == 4 ? bufshape[p] = 3;
      p += 1;
    );
  );
* /
  
  verold = ver;
//  slider63 = points;
//  upsliders();
  eqini_all();
  
);
*/

function gmemslave()
  instance(c10 zr  q q1)(
  c10 = color*100;
  
//  pointsgmem = gmem[c10+3]; // tmp
  
  gmem[c10+0] == -1 && gmaster != 0 ? (
    slider49 = slider57 = singlecnt = 0;
    willdrawpoints = 1;
  ):(
    gmem[c10+0] == -1 && gmaster == 0 ? (
      (singlecnt += 1) > 10 ? gmem[c10+0] = 0;
    ); 
  );
  gmaster != slider49 ? (
    slider_automate(gmaster = slider49);
    drawpoints();
  );
    
//  gmaster == 2 && bypass != 1 ? (  // GMEM SLAVE
  gmaster == 2  && gmem[c10+0] != gmemold ? (  // GMEM SLAVE
    
    gmem[c10+0] == 0 && mygmem >= 0 ? (
      slider49 = mygmem = 1;
    );
  
    gmasterold != 2 || slaved == 0 ? (
      slaved = 0;
      upgraph += 1;
      
        
    );
    gmem[c10+0] > gmemold && mygmem == -1 ? mygmem = 0;
    mygmem >= 0 ? (
      gmem[c10+0] == 0 && gmemold > 0 ? (
        slider49 = gmem[c10+0] = gmemold = mygmem = upmaster = 0;
      ):(
        mygmem = 0; 
      );
    );
    
    (gmem[c10+0] > 0) && (gmem[c10+3] > 0) && slaved == 0 ? (
    
//      slaved = 1;
      (gmem[c10+3] != points) || (mouse_cap > 0 && mouse_capold == 0)
       || gmem[c10+0] > gmemold || (gmem[c10+0] == 1 && gmemold > 1) || (noob < 10) ? (
        slaved = 1;
        
        gmem[c10+3] != points ? (
          points == 0 ? waszero = 1;
          gmasterold != 2 ? (

            while(points > gmem[c10+3])(
              zr = points;
              loop(points,
                bufl[zr] != 0 ? rempoint(zr);
                zr -= 1;
                zr == 0 && points > gmem[c10+3] ? rempoint(points);
              );
            );

          );
          
          points > gmem[c10+3] ? (
            points = slider63 = 0;
          );
          
          
          while(points < gmem[c10+3])(
            addpoint(floor(rand(4500))+500,1,1,0);
          );
//          reorder_all();
//          points = slider63 = gmem[3];
//          slider_automate(slider63);
          
/*          
          z = 1;
          loop(points,
            bufl[z] = 1;
            z += 1;
          );
*/
//          drawpoints();
          
        );
        
  
        
    //    volout = gmem[9]/1000;
        slider42 = (gmem[c10+9]/10 -20) * slider48; // Volout
//        gmem[c10+1] != 1 ? slider43 = bypass = gmem[c10+1];  // Bypass
        gmem[c10+1] != gmembypold ? (
          gmembypold = gmem[c10+1];
          slider43 = bypass = gmem[c10+1];  // Bypass
          willtopbar = 1;
        );
    //    slider48 = gmem[2]/100;   // Link Strength
        gmem[c10+6] < 85.5 ? (
          noauto = gmem[c10+4];
          slider41 = -noauto;
        ):(
          slider41 = 1- gmem[c10+4];
          noauto = (slider41 <= 0);
        );
        
  //      points = gmem[3];
        slider_automate(slider41);
        slider_automate(slider42);
        slider_automate(slider43);
        
        
        q = color*100;
        q1 = 1;
        loop(points,
    //      bufl[q] > 0 || bufl[q] < 0 ? (
          waszero == 1 ? bufl[q1] = 1;
          bufl[q1] != 0 ? (
            gmem[q+q1*10+1] > 0 ? (
              buff[q1] = gmem[q+q1*10+1] *.1;
                
              bufw[q1] = gmem[q+q1*10+3] *.01;
              bufm[q1] = gmem[q+q1*10+4];
//                bufl[q] = gmem[q*10+5]/100;
              bufg[q1] = (gmem[q+q1*10+2] *.1 -100) * bufl[q1];
              gmem[q+6] < 83.5 ? (
                gmem[q+q1*10+6] == 0 ? bufshape[q1] = 2 :
                gmem[q+q1*10+6] == 1 ? bufshape[q1] = 3 :
                gmem[q+q1*10+6] == 2 ? bufshape[q1] = 1 :
                gmem[q+q1*10+6] == 3 ? bufshape[q1] = 4;
              ) : 
              gmem[q+6] < 84.5 ? (
                gmem[q+q1*10+6] == 1 ? bufshape[q1] = 2 :
                gmem[q+q1*10+6] == 2 ? bufshape[q1] = 0 :
                gmem[q+q1*10+6] == 3 ? bufshape[q1] = 1 :
                gmem[q+q1*10+6] == 4 ? bufshape[q1] = 3;
              ) :
              bufshape[q1] = gmem[q+q1*10+6];
              
              bufbyp[q1] = gmem[q+q1*10+7];
        //        bufl[q] == 2 ? bufg[q] *= -1;
        //      );
            );
          );
          q1 += 1;
        );
        waszero = 0;
        upsliders();
        slider_automate(slider43);
        slider_automate(slider48);
        
        
        upslave += 1;
      );
      willtopbar = 1;
      eqini_all();
      upgraph += 1;
      
    );
    gmemold >= 0 ? gmemold = gmem[c10+0];
    
  );
  gmaster != slider49 ? slider_automate(gmaster = slider49);
  slavealone = (gmaster == 2 && (gmem[c10+0] == 0 || gmem[c10+3] == 0) ? 1 : 0);
);

/*
slider63 == 4 && bufshape[1] == 0 && bufshape[2] == 0 && bufshape[3] == 0 && bufshape[4] == 0 ? (
  bufshape[1] = 2;
  bufshape[2] = 0;
  bufshape[3] = 1;
  bufshape[4] = 3;
);
*/

rmsmul = 1/(srate/1000 *  300  );

function rms(in)
  instance(ina flt m m_ o)(
  
  rmsmul == 0 ? rmsmul = 1/(srate/1000 *  300  );
  ina = (abs(in));
  flt += (ina-flt) * (rmsmul);
  o = 19.93 * log10(flt) +.9 ;
  
);




@serialize
//_shapeser = bufshape;

srate > 0 ? old_srate = srate;
//store_01 = file_var(0, old_srate);

store_01 = file_var(0, code_ver);

code_ver > 1000 ? (
  old_srate = code_ver;
  code_ver = 0;
);
//code_ver = 0;

code_ver < 2 ? (
  
  store_02 = file_var(0, bufshape[1]);
  store_03 = file_var(0, bufshape[2]);
  store_04 = file_var(0, bufshape[3]);
  store_05 = file_var(0, bufshape[4]);
  store_06 = file_var(0, bufshape[5]);
  store_07 = file_var(0, bufshape[6]);
  store_08 = file_var(0, bufshape[7]);
  store_09 = file_var(0, bufshape[8]);
  store_10 = file_var(0, bufshape[9]);
  store_11 = file_var(0, bufshape[10]);
  
  store_12 = file_var(0, bufbyp[1]);
  store_13 = file_var(0, bufbyp[2]);
  store_14 = file_var(0, bufbyp[3]);
  store_15 = file_var(0, bufbyp[4]);
  store_16 = file_var(0, bufbyp[5]);
  store_17 = file_var(0, bufbyp[6]);
  store_18 = file_var(0, bufbyp[7]);
  store_19 = file_var(0, bufbyp[8]);
  store_20 = file_var(0, bufbyp[9]);
  store_21 = file_var(0, bufbyp[10]);
);

store_22 = file_var(0, buflm[1]);
store_23 = file_var(0, buflm[2]);
store_24 = file_var(0, buflm[3]);
store_25 = file_var(0, buflm[4]);
store_26 = file_var(0, buflm[5]);
store_27 = file_var(0, buflm[6]);
store_28 = file_var(0, buflm[7]);
store_29 = file_var(0, buflm[8]);
store_30 = file_var(0, buflm[9]);
store_31 = file_var(0, buflm[10]);

code_ver < 2 ? (
  
  store_32 = file_var(0, bufm[1]);
  store_33 = file_var(0, bufm[2]);
  store_34 = file_var(0, bufm[3]);
  store_35 = file_var(0, bufm[4]);
  store_36 = file_var(0, bufm[5]);
  store_37 = file_var(0, bufm[6]);
  store_38 = file_var(0, bufm[7]);
  store_39 = file_var(0, bufm[8]);
  store_40 = file_var(0, bufm[9]);
  store_41 = file_var(0, bufm[10]);
  
  store_42 = file_var(0, multiselect[1]);
  store_43 = file_var(0, multiselect[2]);
  store_44 = file_var(0, multiselect[3]);
  store_45 = file_var(0, multiselect[4]);
  store_46 = file_var(0, multiselect[5]);
  store_47 = file_var(0, multiselect[6]);
  store_48 = file_var(0, multiselect[7]);
  store_49 = file_var(0, multiselect[8]);
  store_50 = file_var(0, multiselect[9]);
  store_51 = file_var(0, multiselect[10]);
  
  store_52 = file_var(0, bufdynena[1]);
  store_53 = file_var(0, bufdynena[2]);
  store_54 = file_var(0, bufdynena[3]);
  store_55 = file_var(0, bufdynena[4]);
  store_56 = file_var(0, bufdynena[5]);
  store_57 = file_var(0, bufdynena[6]);
  store_58 = file_var(0, bufdynena[7]);
  store_59 = file_var(0, bufdynena[8]);
  store_60 = file_var(0, bufdynena[9]);
  store_61 = file_var(0, bufdynena[10]);
  
  store_62 = file_var(0, bufdynsol[1]);
  store_63 = file_var(0, bufdynsol[2]);
  store_64 = file_var(0, bufdynsol[3]);
  store_65 = file_var(0, bufdynsol[4]);
  store_66 = file_var(0, bufdynsol[5]);
  store_67 = file_var(0, bufdynsol[6]);
  store_68 = file_var(0, bufdynsol[7]);
  store_69 = file_var(0, bufdynsol[8]);
  store_70 = file_var(0, bufdynsol[9]);
  store_71 = file_var(0, bufdynsol[10]);
  
  store_72 = file_var(0, bufdynknee[1]);
  store_73 = file_var(0, bufdynknee[2]);
  store_74 = file_var(0, bufdynknee[3]);
  store_75 = file_var(0, bufdynknee[4]);
  store_76 = file_var(0, bufdynknee[5]);
  store_77 = file_var(0, bufdynknee[6]);
  store_78 = file_var(0, bufdynknee[7]);
  store_79 = file_var(0, bufdynknee[8]);
  store_80 = file_var(0, bufdynknee[9]);
  store_81 = file_var(0, bufdynknee[10]);
  
//  willencode += 1;

//  codebyp * codeshape * codest * codesel * codedynena * codedynknee * codedynsol != 0 ? (
  memset(codebyp[1], 0, 10);
  memset(codeshape[1], 0, 10);
  memset(codest[1], 0, 10);
  memset(codesel[1], 0, 10);
  memset(codedynena[1], 0, 10);
  memset(codedynknee[1], 0, 10);
  memset(codedynsol[1], 0, 10);
//  );  
  
  code_ver = 0;
);

store_82 = file_var(0, bufdynatt[1]);
store_83 = file_var(0, bufdynatt[2]);
store_84 = file_var(0, bufdynatt[3]);
store_85 = file_var(0, bufdynatt[4]);
store_86 = file_var(0, bufdynatt[5]);
store_87 = file_var(0, bufdynatt[6]);
store_88 = file_var(0, bufdynatt[7]);
store_89 = file_var(0, bufdynatt[8]);
store_90 = file_var(0, bufdynatt[9]);
store_91 = file_var(0, bufdynatt[10]);

store_92 = file_var(0, bufdynrel[1]);
store_93 = file_var(0, bufdynrel[2]);
store_94 = file_var(0, bufdynrel[3]);
store_95 = file_var(0, bufdynrel[4]);
store_96 = file_var(0, bufdynrel[5]);
store_97 = file_var(0, bufdynrel[6]);
store_98 = file_var(0, bufdynrel[7]);
store_99 = file_var(0, bufdynrel[8]);
store_100 = file_var(0, bufdynrel[9]);
store_101 = file_var(0, bufdynrel[10]);

store_102 = file_var(0, bufdynthr[1]);
store_103 = file_var(0, bufdynthr[2]);
store_104 = file_var(0, bufdynthr[3]);
store_105 = file_var(0, bufdynthr[4]);
store_106 = file_var(0, bufdynthr[5]);
store_107 = file_var(0, bufdynthr[6]);
store_108 = file_var(0, bufdynthr[7]);
store_109 = file_var(0, bufdynthr[8]);
store_110 = file_var(0, bufdynthr[9]);
store_111 = file_var(0, bufdynthr[10]);


//store_29 = file_var(0, showbox);
store_112 = file_var(0, dragprev);
store_113 = file_var(0, dragprevold);
store_114 = file_var(0, points);
store_115 = file_var(0, autovoldb);
store_116 = file_var(0, color);
store_117 = file_var(0, verold);
store_118 = file_var(0, gmasterbypass);
store_119 = file_var(0, soloid);
store_120 = file_var(0, showdyn);
store_121 = file_var(0, dyns);
store_122 = file_var(0, old_srate);

forcedragprev3 = dragprev;
//upbufs();

//slider63 > 0 ? points = slider63;
//verold < .85 ? import();

//upsliders();
/*
loadsliders > 64 && verold < .855 ? (
  import();
  _imported_ser += 1;
);
*/

code_ver >= 2 && file_avail(0) < 0 ? ( // Writing
  encode_all_all() == 1 ? (
      
    store_123 = file_var(0, codebyp);
    store_124 = file_var(0, codeshape);
    store_125 = file_var(0, codest);
    store_126 = file_var(0, codesel);
    store_127 = file_var(0, codedynena);
    store_128 = file_var(0, codedynknee);
    store_129 = file_var(0, codedynsol);
  );
);

code_ver >= 2 && file_avail(0) >= 0 ? ( // Reading



  store_123 = file_var(0, codebyp_);
  store_124 = file_var(0, codeshape_);
  store_125 = file_var(0, codest_);
  store_126 = file_var(0, codesel_);
  store_127 = file_var(0, codedynena_);
  store_128 = file_var(0, codedynknee_);
  store_129 = file_var(0, codedynsol_);
  
  codebyp_ > 0 ? ( codebyp = codebyp_; willdecode = 1; );
  codeshape_ > 0 ? ( codeshape = codeshape_; willdecode = 1; );
  codest_ > 0 ? ( codest = codest_; willdecode = 1; );
  codesel_ > 0 ? ( codesel = codesel_; willdecode = 1; );
  codedynena_ > 0 ? ( codedynena = codedynena_; willdecode = 1; );
  codedynknee_ > 0 ? ( codedynknee = codedynknee_; willdecode = 1; );
  codedynsol_ > 0 ? ( codedynsol = codedynsol_; willdecode = 1; );
  
  willdecode == 1 ? (
    willdecode = 0;
    decode_all_all();
  );
  
);






@slider

upbufs();

//upauto();

willdrawdyn = 1;

//old_w=0;
//eqini_one(dragprev);
/*
verold < .845 ? (
  import();
  _imported_sli += 1;
);
*/

points = slider63;
//upbufs();

  
/*
  _impslif1 = slider1;
  _impslif2 = slider5;
  _impslif3 = slider9;
  _impslif4 = slider13;
  _impslif33 = slider33;
  _impslif37 = slider37;
  _impslipoints = points;
  _impslisli63 = slider63;
*/

//verold < .85 ? import();
/*
serd > 4 && verold < .845 ? (
  import();
  _imported_sli += 1;
);
*/
/*
  _impslibf1 = buff[1];
  _impslibf2 = buff[2];
  _impslibf3 = buff[3];
  _impslibf4 = buff[4];
*/

modeana = slider59;

slider52o = -slider52;

//slider52 != lfloor ? old_w=0;
slider52o != lfloor ? old_w=0;

//slope = slider56;
//slider56 != slope ? slope=3;

//roof = slider58;

//slope = slider56*10;

//liftdbpx = slider60 ;
 

//update =1;

/*
eqini_all(); // tmp
automate(1,43);
automate(48,55);
automate(59,64);
*/


willtopbar = 1;
//gfxini = 1;
//eqini_all();
//willeqini_all = 1;


/*
willencode > 10 ? (
  willencodedslider += 1;
  willencode = 0;
  eqini_all();
);

willdecode > 10 ? (
  willdecodedslider += 1;
  willdecode = 0;
  decode_all_all();
  eqini_all();
);
*/
willupgraph = 1;

/*
slin = 1;
loop(points,
  buff[1] != eq1.f ? 
*/
willeqini_all = 1;



@block



/*
  codebyp = codebyp_;
  codeshape = codeshape_;
  codest = codest_;
  codesel = codesel_;
  codedynena = codedynena_;
  codedynknee = codedynknee_;
  codedynsol = codedynsol_;
*/



//eqini_one(2);



//code_ver = 0;

/*
verold < .855 ? (

  blockshape1a = bufshape[1];
  blockshape2a = bufshape[2];
  import();
  blockshape1b = bufshape[1];
  blockshape2b = bufshape[2];
  _imported_blo += 1;
);
*/
willencode > 0 ? (
  willencode = 0;
  encode_all_all();
  

);

willdecode > 0 ? (
  willdecode = 0;
  decode_all_all();
//  eqini_all();
  willeqini_all = 1;
);

points > 0 && eq1.a0 == 0 ? willeqini_all = 1;

devmode > 0 ? (
  shapeold1 = shapeold[1];
  shapeold2 = shapeold[2];
  shapeold3 = shapeold[3];
  shapeold4 = shapeold[4];
  shapeold5 = shapeold[5];
  shapeold6 = shapeold[6];
  shapeold7 = shapeold[7];
  shapeold8 = shapeold[8];
  
  bufshape1 = bufshape[1];
  bufshape2 = bufshape[2];
  bufshape3 = bufshape[3];
  bufshape4 = bufshape[4];
  bufshape5 = bufshape[5];
  bufshape6 = bufshape[6];
  bufshape7 = bufshape[7];
  bufshape8 = bufshape[8];
  
  buff1 = buff[1];
  buff2 = buff[2];
  buff3 = buff[3];
  buff4 = buff[4];
  buff5 = buff[5];
  buff6 = buff[6];
  buff7 = buff[7];
  buff8 = buff[8];
  buff9 = buff[9];
  buff10 = buff[10];

  bufm1 = bufm[1];
  bufm2 = bufm[2];
  bufm3 = bufm[3];
  bufm4 = bufm[4];
  bufm5 = bufm[5];
  bufm6 = bufm[6];
  bufm7 = bufm[7];
  bufm8 = bufm[8];
  bufm9 = bufm[9];
  bufm10 = bufm[10];

  bufbyp1 = bufbyp[1];
  bufbyp2 = bufbyp[2];
  bufbyp3 = bufbyp[3];
  bufbyp4 = bufbyp[4];
  bufbyp5 = bufbyp[5];
  bufbyp6 = bufbyp[6];
  bufbyp7 = bufbyp[7];
  bufbyp8 = bufbyp[8];
  bufbyp9 = bufbyp[9];
  bufbyp10 = bufbyp[10];
);

noob == 0 ? (
  ret = wasit = gfx_ext_retina;
  slider49 = gmaster;
  slider_automate(slider49);
  gmaster == 2 ? (
    gmemold = 0;
//    upslave += 1;
  );  
);

/*
noob == -1 ? (
  pointed == 0 ? (
    pointed = 1;
    z = 1;
    loop(points,
      bufl[z] = 1;
      z += 1;
    );
//    ownpoints = 0;
    upslave += 1;
  );
);
*/

//slider49 = 0; // Force Single mode

//points = (slider63);
//slider63 = points;
//gmaster == 2 ? gmem[101] = points;
//gmem[102] = points;
//points = slider63;
//points = gmem[3];


slider64 < 6 ? (
  slider64 = 6;
  slider_automate(slider64);
);

/*
noauto != slider41 ? (
  noauto = slider41;
//  upgraph();
//  upauto(); 
  drawpoints();
);
*/

noanal = 1-slider50;

blocks = floor(srate/samplesblock);

(willupauto > 0) || (autoed == 0) ? (
  autoed = 1;
//  (willupauto -= 1) < 0 ? willupauto = 0;
  willupauto > 0 ? willupauto -= 1; // TMP
  upauto();
);



//gmaster = slider49;
//bypass = slider43;

gmaster > 0 ? gmemslave();



  
  
mix = 0;
link = 1;
hardclip = 1;


-slider52 != lfloor ? (
  lfloor = -slider52;
//  minvol=2*exp(log(10)/20*(-slider52 - slider60*slider52 ) );
//  minvol > 0.1 ? minvol = 0.1;
  minvol = 0;
);


willeqini_all > 0 ? (
  eqini_all();
  willeqini_all = 0;
);



@sample



rate = srate/20;
//ßrate = 1;

devmode ? (
  (mtrc += 1) < rate ? (
    mtrinsrc = max(mtrinsrc, max(abs(spl0),abs(spl1)) );
  ):(
    mtrin = mtrinsrc;
    mtrinsrc = 0;
  );
);

spl0 == 0 && spl1 == 0 && mouse_cap == 0 ? (
  sleep == 0 ? sleepc += 1;
  sleepc > srate*2 ? sleep = 1;
):(
  sleep = sleepc = 0;
);

sleep == 0 ? (
  
  spinL = spl0;
  spinR = spl1;
  
  opL = spl0;
  opR = spl1;
  
  bypass == 0 || bypass == 2 ? (
    sp0tmp = spl0;
    sp1tmp = spl1;
    
    eq1.process(1);
    eq2.process(2);
    eq3.process(3);
    eq4.process(4);
    eq5.process(5);
    eq6.process(6);
    eq7.process(7);
    eq8.process(8);
    eq9.process(9);
    eq10.process(10);
  
    
    mutespls > 0 ? (
      mutespls -= 1;
      mute > 0 ? mute -= 1;
      mute < 0 ? mute = 0;
    ):(
      mute < 1 ? mute += 0.001;
      mute > 1 ? mute = 1;
    );
    
    soloid > 0 ? (
      spl0 = soloL;
      spl1 = soloR;
    );
  
    volout = 2^( (slider42-autovoldb) /6);
    spl0 *= volout *mute;
    spl1 *= volout *mute;
  );
    
    
  
  sp12 = max(abs(spl0),abs(spl1));
  sp12 > 2 ? (
    slider42 /= (sp12/2);
    slider_automate(slider42);
    
    redvol = 1;
  );
  
  
  //spl0 > 2 ? spl0 = 2;
  //spl1 > 2 ? spl1 = 2;
  soloid > 0 ? modeana = bufm[soloid];
  
  modeana < 1 ? (
    outl = spl0;
    outr = spl1;
  ) :
  modeana < 2 ? ( 
    outl = spl0 - (spl0-spl1);
    outr = spl1 - (spl1-spl0);
  //  outl = outr = spl0+spl1 - (spl0-spl1);
  ) :
  modeana < 3 ? (   
    outl = (spl0 - spl1) ;
    outr = 0;
  //  outr = (spl0 - spl1) ;
  ) :
  modeana < 4 ? (   
    outl = outr = spl0;
//    outl = outr = spl0 * (spl0-spl1)*2;
  ) :
  modeana < 5 ? (   
    outl = outr = spl1;
//    outl = outr = spl1 * (spl1-spl0)*2;
  );
    
  //outl *= roofgain;
  //outr *= roofgain;
  
  outl > 2 ? outl = 2;
  outl < -2 ? outl = -2;
  outr > 2 ? outr = 2;
  outr < -2 ? outr = -2;
  
  
  noanal == 0 ? (
  
    abs(recpos[]=(outl+outr)) > minvol ? update=1;
    //recpos[]=outl+outr;
    recpos = ((recpos+1) >= histsize ? 0 : (recpos+1));
  );
  
  
  

  // OSCILLOSCOPE
  //gmem[101] = ypx *100;
  //gmem[102] = zerog *100;
  //gmem[102] = ygr *100;
  //gmem[103] = yy *100;
  //gmem[104] = f *100;
  //gmem[103] = yy *100;
  //gmem[104] = y2y *100;
  
  

  
  
  
  fpsc += 1;
);

points == 0 ? (

  outl > pkL_ ? pkL_ = outl;
  outr > pkR_ ? pkR_ = outr;

  rmsL = rmsL.rms(outl);
  rmsR = rmsR.rms(outr);
);


devmode ? (
  (mtrc ) < rate ? (
    mtroutsrc = max(mtroutsrc, max(abs(spl0),abs(spl1)) );
  ):(
    mtrout = mtroutsrc;
    mtroutsrc = 0;
    mtrc = 0;
  );
);





//spl0 = sin(tmpc += 1000/srate) * autopoolpx *.01 ;
//spl1 = sin(tmpc) * autovoldb *.1 ;




@gfx 460*ret 257*ret


mouse_cap == 17 ? (
  code_ver = 0;
  codebyp = codeshape = codest = codesel = codedynena = codedynknee = codedynsol = 0;
);
  
//encode_all_all();
/*
sleepc == sleepcold ? sleep = 1;
sleepcold = sleepc;
*/


mouse_cap > 0 ? sleep = 0;

fps = srate/fpsc;
fpsc = 0;

ret = gfx_ext_retina;

gfx_wlim = max( min(gfx_w,1025*ret) , 335*ret);
dbw = 22*ret;


sleep == 0 ? update = 1 : update = 0;

/*
verold < .845 ? (
  import();
  _imported_gfx += 1;
);
*/


modeana = slider59;
old_srate < 1000 || old_srate != srate ? old_srate = srate;
  
mouse_cap > 0 ? (
//  mouse_cap == 5 || mouse_cap == 13 ? (precise = 0.2) : (precise = 1);
  moucmd > 0 ? (precise = 0.2) : (precise = 1);
  preciseold != precise ? oldrag = 0;
//  preciseold = precise;
  clickingc += 1;
);

gfx_wlim != old_w || gfx_h != old_h ? resize = 1;


function lito(th xp1 yp1 xp2 yp2 xp3 yp3 xp4 yp4)
  instance(th xp1 yp1 xp2 yp2 xp3 yp3 xp4 yp4 xst yst n)(
  xst = gfx_x;  yst = gfx_y;
  n = 0;
  loop(th,
    gfx_line(gfx_x,gfx_y-n,gfx_x+xp1 , gfx_y-yp1-n);
    (xp2 != 0 || yp2 != 0) ? (
      gfx_line(gfx_x+xp1,gfx_y-yp1-n,gfx_x+xp1+xp2 , gfx_y-yp1-yp2-n);
      (xp3 != 0 || yp3 != 0) ? (
        gfx_line(gfx_x+xp1+xp2,gfx_y-yp1-yp2-n,gfx_x+xp1+xp2+xp3 , gfx_y-yp1-yp2-yp3-n);
        (xp4 != 0 || yp4 != 0) ?
          gfx_line(gfx_x+xp1+xp2+xp3,gfx_y-yp1-yp2-yp3-n,gfx_x+xp1+xp2+xp3+xp4 , gfx_y-yp1-yp2-yp3-yp4-n);
      );
    );
    n += 1;
  );
  gfx_x = xst+xp1+xp2+xp3+xp4;
  gfx_y = yst-yp1-yp2-yp3-yp4;
);

function fonts()(
//    font = "Arial";
//    font2 = "Arial";
    font = "Verdana";
    font2 = "Verdana";
//    gfx_setfont(1,font,14*ret,'b');  // buttons, List "x"
    gfx_setfont(1,font,15*ret,'');  // buttons, List "x"
    gfx_setfont(2,font2,20*ret,'bi'); // Boxn
    gfx_setfont(3,font,18*ret,'b');  // Default Bold (Box values)
    gfx_setfont(4,font,16*ret);      // Box non-Bold
    gfx_setfont(5,font,12*ret,'i');  // Showf
    gfx_setfont(6,font,18*ret,'bi');  // Multiedit f, Hz, 10th node
    gfx_setfont(7,font2,22*ret, 'i');      // Multiedit dB
    gfx_setfont(8,font2,14*ret,'i'); // common Stere/Link
    gfx_setfont(9,font,14*ret); // Help, box lists
    gfx_setfont(10,font2,16*ret,'i'); // Multiedit Note
    nprevw = gfx_texth;
    gfx_setfont(11,font2,16*ret,'bi'); // Multiedit f cap, NODES
    gfx_setfont(12,font,13*ret);  // Rulers, List "x"
    gfx_setfont(13,font,10*ret);  // -100 dB
    gfx_setfont(14,font,14*ret, 'b'); // lists chosen
    gfx_setfont(15,font2,13*ret,'bi'); // 10th NODE
    gfx_setfont(16,font2,15*ret,'bi'); // Dynamics values
//    upsliders();
);

function gofloor(sli)
  instance(floored)(
  sli == 55 ? (
    slider(sli) < 100 ? floored = floor(slider(sli)/5 +.5) *5 :
    slider(sli) < 1000 ? floored = floor(slider(sli)/10 +.5) *10 :
    floored = floor(slider(sli)/100 +.5) *100 ;
  ) : (
    floored = floor(slider(sli) +.5) ;
  );
  
  mouse_cap == 0 ? (
    slider(sli) = floored;
    willgofloor = 0;
  ):(
    willgofloor = sli;
  );
);






//fonts();

// GFX INIT

gfxini > 0 || resize > 0 || noob == 0 ? (

  gfxini > 0 ? gfxini -= 1;
//  resize = 0;

  noob == 0 ? (
    fonts();
  );
  
  // Initialize framebuffer for points
  gfx_setimgdim(6,-1,-1);   gfx_setimgdim(6,gfx_wlim,gfx_h); 
  
  gfx_setfont(1);


  but_h = gfx_texth * 1.25;
  but_x = gfx_texth * 0.2;
  helpy = gfx_h-25*ret;
  
    // Info Box Init
  gfx_setfont(4);


  zerog = gfx_h/2;
  scaleg = gfx_h*0.5 /(gainmax = slider64);

//  boxw = (280*ret + (gfx_wlim-335*ret)*0.3 );
  boxw = (330*ret + (gfx_wlim-335*ret)*0.3 );
  boxx1 = (gfx_wlim/2 - boxw *0.5);
//  boxh = floor(gfx_texth * 0.43) *6;
  boxh = 40*ret;
  boxh_ = 14*ret;
  boxytop = floor(gfx_h - gfx_texth - boxh);
  boxy1 = boxytop + gfx_texth *0.1;
  boxybot = boxytop + boxh;
  boxymid = (boxybot+boxytop)/2;
  
  boxy2 = boxymid -2*ret;
  
  boxymid = boxytop + boxh/2;
  lower = 2*ret;
/*
  boxx2hi = boxx1+ max(75*ret, boxw *0.32);
  boxx2lo = boxx2hi + 4*ret;
  boxx2a = boxx2lo-gfx_texth*1.05;
  boxx2b = boxx2lo+gfx_texth*1.05;
  boxx3 = boxx1+ boxw *0.59;
  boxx4 = boxx1+ boxw *0.74;
  boxx5 = boxx1+ boxw *0.9;
*/
  boxx2hi = boxx1+ max(75*ret, boxw *0.26);
  boxx2lo = boxx2hi + 4*ret;
  boxx2a = boxx2lo-gfx_texth*1.05;
  boxx2b = boxx2lo+gfx_texth*1.05;
  boxx3 = boxx1+ boxw *0.49;
  boxx4 = boxx1+ boxw *0.62;
  boxx5 = boxx1+ boxw *0.75;
  boxx6 = boxx1+ boxw *0.91;
  
  gfx_setfont(1);
  dynx = boxx1;
  dyny = boxytop - gfx_texth -2*ret;
  dynw = boxw;
  dynh = gfx_texth;

  gfx_setfont(12);
  gfx_measurestr("-22",gainw,0);
  gainx = gfx_wlim - gainw;
  
//  nprevx = boxx2a - nprevw;
//  nnextx = boxx2b + nprevw;
  
  notem = 2^(1/12);
  notem2 = 2^(0.5/12);
  oct_ = 31.7722;
  //oct_ = 27.5*2^(2.5/12);
  //oct_c = 27.5*notem^3;
  oct_c = 32.7032;

//  wsc=gfx_wlim/log(1+480) +gfx_wlim*0.01;
  
//  wsc=wscmou=(gfx_wlim/log(1+480))+gfx_wlim* 0.0103582;
  wsc=wscmou=(gfx_wlim/log(1+480))+gfx_wlim* 0.0149142;
//  wsc=wscmou=(gfx_wlim/log(1+480))+gfx_wlim* 0.01;
  
/*
  // Redundant?
  eqx.x = log(1.0+i*(800/(fftsize-4)))*wsc    - 0.2*wsc;
  //  4096*(800/8188)
  eqx2.x = log(1.0+1000)*wsc   - 1.2*wsc;
  eqx3.x = (log(1.0+( 1000 /old_srate*2.0)*400)*wsc)  - wsc*0.2;
*/

  
  // SHAPE IMAGES
  gfx_dest = 4;
  gfx_setimgdim(4,-1,-1);  gfx_setimgdim(4,240*ret,30*ret);
  gfx_set(0.2,0,0,1,0);
  



  // High pass
  gfx_x = 0*ret + 3*ret;
  gfx_y = 18*ret - 2*ret;
  lito(th = 5*ret, 3*ret,5*ret, 2*ret,2*ret, 3*ret,1*ret ,9*ret,0);
//  lito(th, 2*ret,-3*ret, 2*ret,2*-ret, 2*ret,-ret, 4*ret,-0.01);
  //    lito(th, 3*ret,0, 0,0, 0,0, 0,0);

  // Low shelf
  gfx_x = 30*ret + 3*ret;
  gfx_y = 18*ret - 12*ret;
  lito(th = 5*ret, 3*ret,-.01, 2*ret,-ret, 2*ret,-2*ret ,0,0);
  lito(th, 2*ret,-3*ret, 2*ret,2*-ret, 2*ret,-ret, 4*ret,-0.01);
  //    lito(th, 3*ret,0, 0,0, 0,0, 0,0);

  // Peak
  gfx_x = 60*ret + 3*ret;
  gfx_y = 18*ret - 2*ret;
  lito(th = 5*ret,  3*ret,2, 1*ret,ret, 2*ret,3*ret, 2*ret,4*ret);
  lito(th, 1*ret,1*ret, 0,0, 0,0, 0,0);
  lito(th, ret,-ret, 2*ret,-4*ret, 2*ret,-3*ret, 1*ret,-ret);
  lito(th, 3*ret,-1*ret, 0,0, 0,0, 0,0);

// Flat Top
  gfx_x = 90*ret + 3*ret;
  gfx_y = 18*ret - 3*ret;
  lito(th = 5*ret, 2*ret,1, 2*ret,3*ret, ret,2*ret, ret,3*ret);
  lito(th, ret,1*ret, 5*ret,-.011*ret, 0,0 , 0,0);
  lito(th, 1*ret,1*-ret, ret,-3*ret, ret,-2*ret, 2*ret,-3*ret);
  lito(th, 2*ret,-1*ret, 0,0, 0,0, 0,0);
  
  
  // High shelf
  gfx_x = 120*ret + 3*ret;
  gfx_y = 18*ret - 3*ret;
  lito(th = 5*ret, 4*ret,0, 2*ret,ret, 2*ret,2*ret ,2*ret,3*ret);
  lito(th, 2*ret,2*ret, 2*ret,ret, 3*ret,ret/2, 0,0);
  //    lito(th, 2*ret,0, 0,0, 0,0, 0,0);
  
  // Low pass
  gfx_x = 150*ret + 3*ret;
  gfx_y = 18*ret - 9*ret;
  lito(th = 5*ret ,9*ret,0 , 3*ret,-1*ret , 2*ret,-2*ret, 3*ret,-5*ret);
  
  
  // Infinite
  gfx_x = 180*ret + 3*ret;
  gfx_y = 18*ret - 7*ret;
  lito(th = 4*ret, 1*ret,-2*ret, 1*ret,-1*ret, 2*ret,-1*ret ,2*ret,1*ret);
  lito(th, 1*ret,1*ret, 4*ret,6*ret, 1*ret,1*ret, 2*ret,1*ret);
  lito(th, 2*ret,-1*ret, 1*ret,-1*ret, 1*ret,-4, 0,-2*ret);
  gfx_x = 180*ret + 3*ret;
  gfx_y = 18*ret - 7*ret;
  lito(th, 0*ret,2*ret, 2*ret,3*ret, 2*ret,1*ret ,2*ret,-1*ret);
  lito(th, 1*ret,-1*ret, 4*ret,-6*ret, 1*ret,-1*ret, 2*ret,-1*ret);
  lito(th, 2*ret,1*ret, 1*ret,1*ret, 1*ret,3, 0,0);
  
  
  // Link
  gfx_x = x = 210*ret + 5*ret;
  gfx_y = y = 18*ret - 2*ret;
  gfx_triangle(x,y , x+5*ret,y-5*ret , x-4*ret,y-6*ret);
  x2 = x + 2*ret;
  y2 = y - 15*ret;
  gfx_triangle(x2,y2 , x2-5*ret,y2+5*ret , x2+4*ret,y2+6*ret);
  gfx_triangle(x2+0*ret,y2+4*ret , x+1*ret,y-4*ret , x-1*ret,y-4*ret , x2-2*ret,y2+4*ret);


  slider63 == -1 ? (
    slider63 = points = 0;
    newpoints();
  );

  sli55.gofloor(55);
  willsetzoom = 1;
  _dragxxx += 1;
  

);


























// FUNCTIONS

function xy(x y )
  instance(x y)(
  gfx_x = x;
  gfx_y = y;
);

function topbar()
  instance(x1 x2 x3 x4 x5 x6 x7 x12 x23 x34 x45 x56 x67 w h wa wb wc dark dark2 gr gr2 xspa pad
  byptmp )(
  topbarok = 1;
  willtopbar = 0;
  
  gfx_dest = 8;
  gfx_setimgdim(8,-1,-1); gfx_setimgdim(8,w=gfx_wlim-dbw*2-2*ret,h=dbw);
  gfx_setfont(12);

  gfx_measurestr( sprintf(#vol," %.1fdB ",(slider42+0.001*sign(slider42))) , wb,0 );
  wb = max(wb, 55*ret + .1*(gfx_wlim/ret-335) );
  wa = ceil( (w-wb) * .5 );
  wc = w - wa - wb;
  xspa = floor(wa/3);
  x1 = floor(xspa * .4);
  x2 = ceil(x1 + (wa-x1)/3) ;
  x3 = floor((wa+wa+x2)/3);
//  x3 = x2 + xspa;

//  wb = ceil(w * .15);
  x4 = floor(wa + wb/2);
  xspa = floor(wc/3);
//  x5 = wa + wb +x1;
//  x6 = x5 + xspa;
//  x7 = floor((w+x6) *.5);
  x5 = ceil(wa+wb + xspa*.55 );
  x6 = ceil(x5 + xspa*1.25  );
  x7 = floor( w - dbw*.5 - .1*(gfx_wlim/ret-335) );
  
  x12 = (x1+x2)/2 +dbw;
  x23 = (x2+x3)/2 +dbw;
  x34 = (x3+x4)/2 +dbw;
  x45 = (x4+x5)/2 +dbw;
  x56 = (x5+x6)/2 +dbw;
  x67 = (x6+x7)/2 +dbw;
  
  pad = 3*ret;
  
  topa = .5;
  
  
  xy(0,0); //tmp
  dark = .1;
  dark2 = .2;
  gr = .07 * (1+slider50);
//  gfx_set(gr*.5,gr,gr*2,1);
  gfx_gradrect(0,0,wa,h , gr*.7,gr,gr*(.8+slider50),1 , 0,.05/wa,.0/wa,0 , -dark/h,-dark/h,-dark/h,0);

  gr = .24;
  slider41 == 0 ? (
    gr = .1;
    gr2 = .2;
    gfx_set(gr,gr,gr,1);
  ):(
    gr2 = .2 ;
    gfx_set(gr2,gr2,gr2,1);
//    gr2 = gr = .25;
    gr2 = gr = .3 * max(0,slider41);
  );

//  gfx_set(gr,gr,gr,1);
  gfx_gradrect(wa,0,wb,h , gr2,gr,gr,1 , 0,0,0,0 , -dark2/h,-dark2/h,-dark2/h,0);
  gfx_rect(wa+pad,pad,wb-pad*2,h-pad*2 , 1);  
  
  gr = .1;
//  gfx_set(gr,gr*2,gr*.5,1);
  gfx_gradrect(wa+wb,0,wc,h , gr +dark/2,gr*2 +dark/2,gr*.5,1 , -dark/2/wc,-dark/2/wc,0,0 , -dark/h,-dark/h,-dark/h,0);
  
  gr = topa;
  gfx_set(gr,gr,gr,1);
  gfx_rect(0,0,w,h , 0);

  
  // VALUES
  gr = topa;
  gfx_set(gr,gr,gr,1);
  gfx_x = x1;
  gfx_y = ret;
  gfx_drawstr( sprintf(#,"%dK",1<<(slider51)) , 257 ,gfx_x,gfx_y);
  gfx_x = x2;
  
  slider55 > 1000 ? (
    gfx_drawstr( sprintf(#,"%.1fs", sli55.floored/1000 +.0001) , 257 ,gfx_x,gfx_y);
  ):(
    gfx_drawstr( sprintf(#,"%dms", sli55.floored) , 257 ,gfx_x,gfx_y);
  );
  
  modeana < 1 ? sprintf(#mode," Stereo ",0):
  modeana < 2 ? sprintf(#mode,"   Mid   ",0):
  modeana < 3 ? sprintf(#mode,"   Side  ",0):
  modeana < 4 ? sprintf(#mode," L        ",0):
  modeana < 5 ? sprintf(#mode,"        R ",0);
  gfx_x = x3;
  gfx_drawstr(#mode , 257 ,gfx_x,gfx_y);
  
  gr = topa +.1;
  gfx_set(gr,gr,gr,1);
  gfx_x = x4;
  gfx_drawstr( #vol , 257 ,gfx_x,gfx_y);
  
  gfx_x = x5;  
  gr = topa ;
  gfx_set(gr,gr,gr,1);
  sprintf(#linkpr," %d%% ",(slider48*100+0.001*sign(slider48)));
  gfx_drawstr(#linkpr, 257 ,gfx_x,gfx_y);
  
  gfx_x = x6;  
  slider57 < .5 ? (
    #master = " Single ";
    dragtaken != 26 && slider49 < .5 ? (
      gr = .02 ;
      gfx_set(gr,gr,gr,1);
      gfx_rect(x6-masterstrw*.55 , pad,masterstrw*1.1 , dbw-pad*2);  
    );
  ) :
  slider57 > 1.5 ? (
    #master = " Slave ";
    dragtaken != 26 && slider49 > 1.5 ? (
      gr = .4;
      gfx_set(gr,gr*1.2,gr/3,.8);
      gfx_rect(x6-masterstrw*.55 , pad,masterstrw*1.1 , dbw-pad*2);  
    );
  ) :
  #master = " Master ";
  gfx_measurestr(#master , masterstrw,0);
  
  dragtaken != 26 ? (
    slider57 > 1.5 ? (
      gr = .8;
      gfx_set(gr,gr,gr,1);
    ) :
    slider57 < .5 ? (
      gr = topa;
      gfx_set(gr,gr,gr,1);
    ):(
      gr = .65;
      gfx_set(gr,gr,1,1);
    );
  );
  gfx_drawstr(#master, 257 ,gfx_x,gfx_y);
  
  gmaster == 1 ? byptmp = min(3,bypass) : byptmp = min(1,bypass);
  byptmp == 1 ? (
    gfx_set(.4,0,0,1);
    gfx_circle(x7,dbw*.5, dbw*.4 ,1);
    gr = .5;
    gfx_set(gr,gr,gr,1);
  ):
  byptmp == 2 ? (
    gfx_set(.8,1,.5,.4);
    gfx_circle(x7,dbw*.5, dbw*.4 ,1);
    gfx_set(1,0,0,1);
  ):
  byptmp == 3 ? (
    gfx_set(.6,0,0,1);
    gfx_circle(x7,dbw*.5, dbw*.4 ,1);
//    gfx_set(0,.6,1,1);
    gfx_set(.3,0,0,1);
  ):(
    gr = .8;
    gfx_set(gr,gr,1,1);
  );
      
  gfx_circle(x7,dbw*.5, dbw*.3);
  gfx_circle(x7,dbw*.5, dbw*.3 -1);
  gfx_rect(x7-1,dbw*.35,3,dbw*.3 +1 ,1);
  
  gfx_dest = -1;
  
);




function topbarmenu(x w cols rows_ r g b rg gg bg tit )
  instance(titx tity titax titay titbx titcx gr h)(

  rows = rows_;
  gfx_setfont(12);
  h = (rows+2.5)*gfx_texth;
  barx = dbw + 2*ret;
  barw = w;
  itemw = barw/cols;
  gr = .08;
  gfx_gradrect(x,topbar.h,w,h , r,g,b,bara , rg/barw,gg/barw,bg/barw,0 , -dark/h,-dark/h,-dark/h,0);
  
/*
  xy(barx + barw , bary+h);
  gfx_drawstr(tit, 256,barx+barw,bary);
*/
  gfx_setfont(15);
  xy( x+w/2 , topbar.h + h);
  gr = .4;
  gfx_set(gr,gr,gr,bara);
  gfx_drawstr(tit, 265,gfx_x,gfx_y);
  
  mouse_cap > 0 && mouse_capold == 0
  && (mouse_x < x || mouse_x > x+w || mouse_y > topbar.h+h) ? barmenu = 0;
  
  xy(itemx=x+itemw/2,topbar.h +4*ret);
  
);

function topbarmenuitem(tit s1 v1 s2 v2 s3 v3 s4 v4 s5 v5 s6 v6 taken sli)
  instance(bri slistrt itemx itemh)(
  gfx_setfont(12);
  

  
  itemx = gfx_x;
  itemy = gfx_y;
  textw = 0;
  taken != 30 ? (
    gr = .7;
    gfx_set(gr,gr,gr,bara);
  );
  v1 == -98 ? gfx_a = dimitem;
  gfx_drawstr(s1, 257,gfx_x,gfx_y);
  textw = max(textw,gfx_x-itemx);
  xy(itemx,gfx_y += gfx_texth);
  gfx_a = bara;
  
/*
  sli == 43 ? (
    gr = .2;
    gfx_set(.8,.5,.3,bara);
  );
*/
  v2 != -99 ? (
    v2 == -98 ? gfx_a = dimitem;
    gfx_drawstr(s2, 257,gfx_x,gfx_y);
    textw = max(textw,gfx_x-itemx);
    xy(itemx,gfx_y += gfx_texth);
  );
  v3 != -99 ? (
    v3 == -98 ? gfx_a = dimitem;
    gfx_drawstr(s3, 257,gfx_x,gfx_y);
    textw = max(textw,gfx_x-itemx);
    xy(itemx,gfx_y += gfx_texth);
  );
  v4 != -99 ? (
    v4 == -98 ? gfx_a = dimitem;
    gfx_drawstr(s4, 257,gfx_x,gfx_y);
    textw = max(textw,gfx_x-itemx);
    xy(itemx,gfx_y += gfx_texth);
  );
  v5 != -99 ? (
    v5 == -98 ? gfx_a = dimitem;
    gfx_drawstr(s5, 257,gfx_x,gfx_y);
    textw = max(textw,gfx_x-itemx);
    xy(itemx,gfx_y += gfx_texth);
  );
  v6 != -99 ? (
    v6 == -98 ? gfx_a = dimitem;
    gfx_drawstr(s6, 257,gfx_x,gfx_y);
    textw = max(textw,gfx_x-itemx);
    xy(itemx,gfx_y += gfx_texth);
  );
  
  taken != 30 ? (
    gr = .7;
    gfx_set(gr,gr,gr,bara);
  );
  gfx_a = bara;
  
  gfx_roundrect(itemx1=floor(itemx-textw/2-3*ret),itemy,itemrw=ceil(textw+6*ret),itemh=gfx_y-itemy +2*ret , 6);
  
  
//  sli > 0 && (sli != 158 || taken == 29) ? (   // Position shade
  sli > 0 && taken != 130 ? (   // Position shade
/*
    sli == 41 ? (
//      slider(sli) < (v1+v2)/2 ? ( bri = 0) : (bri = 1);
      slider58 = 1-slider41;
      sli = 58;
    ) :
* /
    sli == 43 ? ( // Bypass
      gmaster == 1 ? (bri = min( 3 , bypass))
      : (bri = min( 1 , bypass));
*/
    sli == 43 ? ( // Bypass
      bri = bypass;
    ):(
      slider(sli) > (v2) ? ( slider(sli) == v1 ? bri = 0 : bri = 1-(slider(sli)-v2)/(v1-v2); ) :
      slider(sli) > (v3) ? ( slider(sli) == v2 ? bri = 1 : bri = 2-(slider(sli)-v3)/(v2-v3); ) :
      slider(sli) > (v4) ? ( slider(sli) == v3 ? bri = 2 : bri = 3-(slider(sli)-v4)/(v3-v4); ) :
      slider(sli) > (v5) ? ( slider(sli) == v4 ? bri = 3 : bri = 4-(slider(sli)-v5)/(v4-v5); ) :
      slider(sli) > (v6) ? ( slider(sli) == v5 ? bri = 4 : bri = 5-(slider(sli)-v6)/(v5-v6); ) :
      ( slider(sli) == v6 ? bri = 5 : bri = 6-(slider(sli)-0)/(v6-0); );
    );
    nobri = 0;
    taken == 31 ? ( // Make single
      drag == 58 && mouse_x > itemx-textw/2 -3*ret+1 && mouse_y > itemy
      && mouse_x < itemx + textw/2 +6*ret-1 ? (
        mouse_y < (itemy + gfx_texth) ? (bri = 0; colmaster == 10 ? nobri = 1;) :
        mouse_y < itemy + 2*gfx_texth ? bri = 1 :
        nobri = 1;
      ):(
        nobri = 1;
      );
    ) :
    taken == 30 ? (
      drag == 58 && mouse_x > itemx-textw/2 -3*ret+1 && mouse_y > itemy
      && mouse_x < itemx + textw/2 +6*ret-1 ? (
        mouse_y > (itemy + gfx_texth) ? (bri = 1; gmaster != 1 ? nobri = 1;) :
        mouse_y < itemy + gfx_texth ? bri = 0 :
        nobri = 1;
      ):(
        nobri = 1;
      );
    );
    nobri == 0 ? (
      gfx_set(1,1,1,.2*bara,1);
      gfx_rect(itemx-textw/2 -3*ret+1,itemy +ret + bri*gfx_texth , textw +6*ret-1,gfx_texth ,1);
    );
  );
  
  
//  mouse_cap > 0 && mouse_capold == 0 && mouse_x > itemx-textw/2 && mouse_x < itemx+textw/2
//  mouse_cap > 0 && mouse_capold == 0 && mouse_x > itemx1 && mouse_x < itemx1+itemrw   
  dblclk == 0 && mouse_x > itemx1 && mouse_x < itemx1+itemrw   
  && mouse_y > itemy && mouse_y < gfx_y+gfx_texth +3*ret ? (

    mouse_cap > 0 && mouse_capold == 0 ? slistrt = slider(sli);
    
  
//    sli == 41 ?  ( (slider(sli) += 1) > 1 ? slider(sli) = 0; ) :

/*
    sli == 43 ? (
      gmaster == 1 ? (
        slider43 == 0 ? slider43 = max(1,gmasterbypass) : slider43 = 0;
      ):(
        (slider43 += 1) > 1 ? slider43 = 0;
      );
//      slider43 = floor((mouse_y-itemy) / gfx_texth);
//      bypass = slider43;
    ) :
*/
        
    
    sli == 58 ? (
      dragonly = 0;
      colmaster == 10 ? v1 = 0;
    );

    
    mouse_cap == 0 && mouse_capold > 0 && dragonly == 0 ? (
      taken == 27 ? willbypass = 1;
      
      
  
      
      mouse_y < itemy +2*ret + gfx_texth ? slider(sli) = v1 :
      v2 != -99 ? mouse_y < itemy +2*ret + 2*gfx_texth ? slider(sli) = v2 :
      v3 != -99 ? mouse_y < itemy +2*ret + 3*gfx_texth ? slider(sli) = v3 :
      v4 != -99 ? mouse_y < itemy +2*ret + 4*gfx_texth ? slider(sli) = v4 :
      v5 != -99 ? mouse_y < itemy +2*ret + 5*gfx_texth ? slider(sli) = v5 :
      v6 != -99 ? mouse_y < itemy +2*ret + 6*gfx_texth ? slider(sli) = v6;
      
      v2 != -99 && v3 == -99 && slistrt == slider(sli) && sli != 58 ? (
        (slider(sli) += 1) > 1 ? slider(sli) = 0;
      );
      
//      taken == 27 ? drag = dragtaken = -1;
      
      taken == 27 ? (
        slider(sli) == bypass ? (
          bypass == 0 ? bypass = gmasterbypass : bypass = 0 ;
          slider(sli) = bypass;
        );
          gmaster == 1 && bypass == 1 ? gmasterbypthis = 1;
      );
      
    
    
    );
    
/*
    taken == 29 ? (
      slider41 = 1-slider58;
      sli = 41;
    );
*/    

//    sli == 43 && mouse_capold == 0 ? (
    sli == 43 ? (
/*
      slider43 == slistrt ? (
        slider43 == 0 ? (
          slider43 = ( gmaster == 1 ? gmasterbypass : 1 );
        ):(
          slider43 = 0;
        );
      ); 
*/
      

      willbypass = 0;
    );

    
    slider_automate(slider(sli));
    
    mouse_cap > 0 && mouse_capold == 0 ? (
      drag = sli;
      dragtaken = taken;
      
  //    drag == 51 ? memset(buf_slo,-100,fftsize/2);
      slistrt != slider(sli) ? (
        drag == 51 || drag == 59 ? memset(buf_slo,-100,fftsize/2);
      );
    );
    
    mouse_cap > 0 || mouse_capold > 0 ? ( 

      upbufs();
      barc = -1;
      topbarok = 0;
//    topbar();
      upgraph = 1;
      willdrawpoints = 1;
      upauto();
    );
  );
  
  gfx_y += 4*ret;
  gfx_setfont(13);

  taken != 30 ? (
    gr = .7;
    gfx_set(gr,gr,gr,bara,0);
  );  
  gfx_drawstr(tit, 257,gfx_x,gfx_y);
  
  xy(gfx_x = itemx+itemw , itemy);
  
);

function setzoom(dragging)
  instance(stopzdrag)(
  
  _drag += 1;

  noanal == 0 ? (
    zoomode = 2;
    drag = dragtaken;
  
    my = mouse_y/gfx_h;
    resize == 0 && dragging == 1 ? (
      dragtaken == 19 ? (
        slider52 = floorstart - (floordbup = ((mouse_x-moustartx)*precise/5)  );
      ):(
        dblclk = 19;
      );
    );
    slider52 > 150 ? slider52 = 150;
    slider52 < 30 ? (slider52 = 30; stopzdrag = 1; ):(stopzdrag = 0;);
    floordb_  = (slider52/10)^2;
    db2px = slider60/ ((slider60/gfx_h) * floordb_) ;//* (slider60/gfx_h);
    roofdbpx1 = slider60/gfx_h;
    dragdbx = (mouse_x-moustartx)*precise;
    floordbup2 = sign(floordbup)* abs(floordbup)^0.8 *(1 + slider52/gfx_h *2);
    resize == 0 && stopzdrag == 0 ? 
      slider60 = roofstart + (moustarty-mouse_y)*precise * (slider52/gfx_h)
      + floordbup2*2 * ((moustarty/gfx_h) *1.5 +0)*(1+slider60/3000 *0);
  
    slider60 > 150 ? (slider60 = 150; stopzdrag = 1;);
    slider60 < -slider52*0.8 ? (slider60 = -slider52*0.8; stopzdrag = 1; ):(stopzdrag = 0;);
    willautomate = 60.52;
  
    liftdbpx = slider60 * db2px;
    liftdb = liftdbpx / db2px;
  
    upgrid = 1;
  );
);






function captopbar()
  instance(sliold mou)(
  
  mouse_cap > 0 && mouse_capold == 0 ? (
  
//    bara > .5 ? barmenu = 0;
    
    moustartx = mouse_x;
    moustarty = mouse_y;
    
    mouse_cap >= 1 ? (
      mouse_x < topbar.x12 ? ( dragtaken = 21 ; drag = 51; ) :
      mouse_x < topbar.x23 ? ( dragtaken = 22 ; drag = 55; ) :
      mouse_x < topbar.x34 ? ( dragtaken = 23 ; drag = 59; ) :
      mouse_x < topbar.x45 ? ( dragtaken = 24 ; drag = 42; ) :
      mouse_x < topbar.x56 ? ( dragtaken = 25 ; drag = 48; ) :
      mouse_x < topbar.x67 ? ( dragtaken = 26 ; drag = 57; ) :
      (dragtaken = 27; drag = 43; );
      p=0;
    );
    
    dragtaken >= 21 && dragtaken <= 23 && mouse_cap == 17 ? (
      slider50 == 0 ? slider50 = 1 : slider50 = 0;
      
      noanal = 1-(slider50);
//      setzoom(0);
      willsetzoom = 1;
      dragtaken = drag = 0;
    );
    
    mouse_x > topbar.x34 && mouse_x < topbar.x45 ? ( dragtaken = 24 ; drag = 42; );
    dragtaken == 24 ? (
      mouse_cap == 17 && gmaster != 2 ? (
//        (slider41 += 1) > 1 ? slider41 = 0;
//        (noauto = slider41 ) > 0 ? upauto();
        (slider41 *= -1) == 0 ? slider41 = 1;
        noauto = (slider41 <= 0);
        upauto();
        barmenu = 0;
        drag = dragtaken = -1;
      );
/*
    ):

    dragtaken == 27 ? (
      willbypass = 1;
//      (slider43 += 1) > 1 ? slider43 = 0;
//      (bypass = slider43 );
*/
    );
//    drag == 43 ? memset(buf_slo,-100,fftsize/2);
    

  );
  
  cap_drag = 1;

  
  dragtaken == 26 ? willgmaster = 1;
  
  
);




function dragtop(taken sli mini maxi res spd)
  instance(mou slistrt miniold moutmp cnt)(
  
  
  (mouse_cap > 0 && mouse_capold == 0) ? (
    moustartx = mouse_x;
    moustarty = mouse_y;
    slistrt = slider(sli);
    cnt = 0;
  );

  (cnt += 1) > 10 ? dragonly = 1 : dragonly = 0;
  
/*  
//  (drag == 47 && slistrt == 0) || (drag == 51 && mouse_capold == 0) ? (
  (drag == 47 && slistrt == 0) || (drag == 59 && mouse_capold == 0) ? (
//  (drag == 47 && slistrt == 0) ? (
    memset(buf_slo,-100,fftsize/2);
  );
*/  
  drag == 55 ? sli55.gofloor(55);
  
  sliold = drag;
  mou = (moux = mouse_x - moustartx) + (mouy = moustarty - mouse_y);
  
  mou != 0 ? barc = -1;
  moutmp = mou/spd;
  abs(moutmp) > res ? ( // drag lists
    dragonly = 1;
    slider(sli) += floor( abs(moutmp)/res) * res * sign(moutmp);
    moutmp = 0;
    moustartx = mouse_x;
    moustarty = mouse_y;
    
    drag == 51 || drag == 59 ? memset(buf_slo,-100,fftsize/2);
    
  );


    
  slider(sli) < mini ? slider(sli) = mini;
  slider(sli) > maxi ? slider(sli) = maxi;
  
  
  slider_automate(slider(sli));
);




function checkbox(chx chy a sel)
  instance(chw chh gr)(

  chw = 12*ret;
  chh = chw * 1.1;
  gr = .7;
  gfx_set(gr,gr,gr,1,0);
  gfx_rect(chx , chy , chw,chh);
  gr = .9;
  gfx_set(gr,gr,gr,1,0);
  gfx_line(chx,chy+chh,chx+chw,chy+chh);
  gfx_line(chx+chw,chy+chh,chx+chw,chy);
  gr = .5;
  gfx_set(gr,gr,gr,1,0);
  gfx_line(chx,chy+chh,chx,chy);
  gfx_line(chx,chy,chx+chw,chy);
  
  a >= 1 ? gfx_set(0,0,0,1,0) :
    gfx_set(0,0,0,.3,0);

  sel >= 1 ? (
//    gfx_x = chx+2*ret; gfx_y = chy+4*ret;
//    lito(4*ret , 3*ret,-6*ret , 1*ret,0 , 2*ret,4*ret , 3*ret,3*ret);
    gfx_x = chx+1*ret; gfx_y = chy+6*ret;
    lito(5*ret , 4*ret,-7*ret , 1*ret,0 , 2*ret,5*ret , 5*ret,5*ret);
  );
);





// INFO BOX / DETAIL BOX / DRAW BOX

function drawbox()
  instance(r g b a h rg gg bg gr chx2 val)(
  gfx_dest = 5;
  gfx_setimgdim(5,-1,-1); gfx_setimgdim(5, boxx1+boxw+2,boxytop+boxh+2);

  gfx_set(.9,.65,.27,.9,0);
  multiedit == 1 ? gfx_b = .35;
//  gfx_rect(boxx1,boxytop,boxw,boxh);
  gfx_a -= .03;
  r = gfx_r; g = gfx_g; b = gfx_b; a = gfx_a; h = boxh/3 * 0 +13*ret;
  rg = 0.1; gg = 0.25; bg = 0.15; ag = 0.01;
  gfx_gradrect(boxx1,boxytop,boxw,boxh_*1, r-rg,g-gg,b-bg,a+ag , 0,0,0,0 , 
  rg/h,gg/h,bg/h,-ag/h);
  gfx_rect(boxx1,boxytop+boxh_*1,boxw,boxh_);
  gfx_gradrect(boxx1,boxytop+boxh_*2,boxw,boxh_*1, r,g,b,a , 0,0,0,0 , 
  -rg/h,-gg/h,-bg/h,ag/h);

  multiedit == 1 ? gfx_set(1,.3,0,1,0) : gfx_set(1,.6,0,1,0);
  gfx_rect(boxx1,boxytop,boxw,boxh,0);
  gfx_rect(boxx1-1,boxytop-1,boxw+2,boxh+2,0);
  multiedit == 1 ? gfx_rect(boxx1+1,boxytop+1,boxw-2,boxh-2,0);


  // CHECKBOX
  
  nodechk.checkbox(boxx1 +ret*4 ,boxymid +ret*3 ,
    (bufbyp[dragprev]==0)*(multiedit==0)+(multiedit*multisameb),
    (bufbyp[dragprev]==0) + (multiedit==1)*(multisameb==0) );
    
/*  
  
  chw = 12*ret;
  chh = chw * 1.1;
  gr = .7;
  gfx_set(gr,gr,gr,1,0);
  gfx_rect(chx = boxx1 +4*ret , chy = boxymid + 3*ret , chw,chh);
  gr = .9;
  gfx_set(gr,gr,gr,1,0);
  gfx_line(chx,chy+chh,chx+chw,chy+chh);
  gfx_line(chx+chw,chy+chh,chx+chw,chy);
  gr = .5;
  gfx_set(gr,gr,gr,1,0);
  gfx_line(chx,chy+chh,chx,chy);
  gfx_line(chx,chy,chx+chw,chy);
  
  multiedit == 0 ? (gfx_set(0,0,0,1,0)):
    (multisameb == 1 ? (gfx_set(0,0,0,1,0)):
    gfx_set(0,0,0,.3,0);
  );

  bufbyp[dragprev] == 0 || (multiedit == 1 && multisameb == 0) ? (
//    gfx_x = chx+2*ret; gfx_y = chy+4*ret;
//    lito(4*ret , 3*ret,-6*ret , 1*ret,0 , 2*ret,4*ret , 3*ret,3*ret);
    gfx_x = chx+1*ret; gfx_y = chy+6*ret;
    lito(5*ret , 4*ret,-7*ret , 1*ret,0 , 2*ret,5*ret , 5*ret,5*ret);
  );
*/  
  
  shapex = boxx1 + boxw*0.08;



  // CHECKBOX DYNAMICS
  
  gfx_setfont(4);
  gfx_measurestr("Dyn",bufdynw,0);
  gfx_set( gr=.6 +.1*(showdyn>0),gr-.05,gr-.2 ,1,0);
  bufshape[dragprev] == 0 || bufshape[dragprev] == 5 ? gfx_set(gr=.7,gr,gr,.6);
  
  gfx_rect(boxx5 -bufdynw *.6 ,boxytop + 2*ret , bufdynw*1.2,gfx_texth  ,  1);
  gfx_set( (gr=.2),gr-.05,gr-.1);
  gfx_rect(boxx5 -bufdynw *.6 ,boxytop + 2*ret , bufdynw*1.2,gfx_texth  ,  0);
  
  
  multiedit == 1 ? gfx_set(1,.3,0) : gfx_set(1,.6,0);
  gfx_rect(boxx5,boxybot,boxw,boxh,0);
  gfx_rect(boxx5-1,boxybot-1,boxw+2,boxh+2,0);
  multiedit == 1 ? gfx_rect(boxx5+1,boxybot+1,boxw-2,boxh-2,0);

  dynchk.checkbox(boxx5 -4*ret, boxymid + 3*ret,
    (bufdynena[dragprev]==1)*(multiedit==0)+(multiedit*multisamed),
    (bufdynena[dragprev]==1) + (multiedit==1)*(multisamed==1) );
    
  
/*  
  chw = 12*ret;
  chh = chw * 1.1;
  (multiedit == 0 && (bufshape[dragprev] == 0 || bufshape[dragprev] == 5)) ? gr = .55 : gr = .7;
  gfx_set(gr,gr,gr);
  gfx_rect(chx2 = boxx5 -4*ret , chy = boxymid + 3*ret , chw,chh);
  gr = .9;
  gfx_set(gr,gr,gr);
  gfx_line(chx2,chy+chh,chx2+chw,chy+chh);
  gfx_line(chx2+chw,chy+chh,chx2+chw,chy);
  gr = .5;
  gfx_set(gr,gr,gr);
  gfx_line(chx2,chy+chh,chx2,chy);
  gfx_line(chx2,chy,chx2+chw,chy);
  
  multiedit == 0 ? (gfx_set(0,0,0,1,0)):
    (multisamed == 1 ? (gfx_set(0,0,0,1,0)):
    gfx_set(0,0,0,.3,0);
  );

  bufdynena[dragprev] == 1 || (multiedit == 1 && multisamed == 0) ? (
//    gfx_x = chx2+2*ret; gfx_y = chy+4*ret;
//    lito(4*ret , 3*ret,-6*ret , 1*ret,0 , 2*ret,4*ret , 3*ret,3*ret);
    gfx_x = chx2+1*ret; gfx_y = chy+6*ret;
    lito(5*ret , 4*ret,-7*ret , 1*ret,0 , 2*ret,5*ret , 5*ret,5*ret);
  );
*/
  
    
  
  
  
  
  gmaster == 1 ? (
    gfx_setfont(4);
    gfx_x = boxx6 - gfx_texth;
    gfx_y = boxy2 +ret;
    
    gfx_drawstr("Link  ",256,gfx_x,gfx_y);
    
    // CHECKBOX 2
    gr = .7;
    gfx_set(gr,gr,gr,1,0);
    gfx_rect(chx2 = boxx1 +boxw-chw*1.5 , chy2 = boxymid + 4*ret , chw,chw);
    gr = .9;
    gfx_set(gr,gr,gr,1,0);
    gfx_line(chx2,chy2+chw,chx2+chw,chy2+chw);
    gfx_line(chx2+chw,chy2+chw,chx2+chw,chy2);
    gr = .5;
    gfx_set(gr,gr,gr,1,0);
    gfx_line(chx2,chy2+chw,chx2,chy2);
    gfx_line(chx2,chy2,chx2+chw,chy2);
    
    multiedit == 0 || multisamelm == 1 ? (
      gfx_set(0,0,0,1,0)
    ):(
      gfx_set(0,0,0,.3,0);
    );
    
    multiedit == 1 || buflm[dragprev] == 0 ? (
      gfx_x = chx2+2*ret; gfx_y = chy2+5*ret;
      lito(4*ret , 3*ret,-6*ret , 1*ret,0 , 2*ret,4*ret , 3*ret,3*ret);
    );
  
  
  );

  multiedit > 0 ? (
    multidima = .5;
    
    gfx_setfont(2);
    gfx_x = boxx1 + 4*ret + boxw*0.05;
    gfx_y = boxytop -ret;
    gfx_set(0.2,0,0,multidima,0);
    mouse_cap > 0 ? gfx_a = .8;
    sprintf(boxnstr,"%.f..",dragprev);  
    gfx_drawstr(boxnstr,256,gfx_x,gfx_y);
    
    // Shape
    multisames == 1 ? (
      gfx_set(0,0,0,1,0);
      gfx_blit(4,1,0, bufshape[dragprev]*(30*ret),0,30*ret,30*ret , shapex,boxymid,30*ret,30*ret);
    ):(
      gfx_a = multidima;
      gfx_blit(4,1,0, 6*(30*ret),0,30*ret,30*ret , shapex,boxymid,30*ret,30*ret);
    );
/*    
    (dragtaken >= 10 && dragtaken <= 13 && moushft == 0) 
    && (dragtaken != 12 || multisameg == 0)
    && (dragtaken != 13 || multisamew == 0) ? (
      gfx_setfont(2);
      gfx_x = boxx1 + 8*ret + boxw*0.05;
      gfx_y = boxytop -ret;
      gfx_set(0.2,0,0,multidima);
      sprintf(boxnstr,"%.f",dragprev);  
      gfx_drawstr(boxnstr,256,gfx_x,gfx_y);
    );    
*/
    gfx_set(0,0,0,multidima,0);
    dragtaken == 11 && moushft == 0 ? (
//      mous > 0 ? (
      gfx_x = boxx2hi;
      gfx_setfont(11);
      gfx_y = boxy1+ret;
      sprintf(buffstr,"%.f",buff[dragprev]+.1);
      gfx_measurestr(buffstr,buffw,0);
      gfx_drawstr(buffstr,257,gfx_x,gfx_y);
      gfx_setfont(10);
      gfx_x -= buffw/2 - 1*ret; 
      gfx_drawstr("Hz",256,gfx_x,gfx_y);
    ):(
      gfx_setfont(6);
      // Hz
      gfx_x = boxx2lo; gfx_y = boxytop-ret*2*0;
      gfx_drawstr("< Hz >",257,gfx_x,gfx_y);        
    );
//    ):(
    dragtaken == 20 || multisamenote == 1 ? (
      multisamenote == 1 ? gfx_set(0,0,0,1,0) : gfx_set(0,0,0,multidima,0);
      gfx_x = boxx2a;
      gfx_y = boxy2;
      gfx_setfont(11);
      gfx_drawstr("<",258,gfx_x,gfx_y);
      gfx_x = boxx2a -ret * noteoct/10;
      gfx_drawstr(notename,256,gfx_x,gfx_y);
      gfx_setfont(10);
      gfx_x = (boxx2b) +ret * noteoct/10;
      gfx_y += ret;
      sprintf(noteoctstr,"%.f",noteoct);
      dragtaken == 20 ? gfx_drawstr(noteoctstr,258,gfx_x,gfx_y);
      gfx_setfont(10);
      gfx_y -= ret;
      gfx_x = boxx2b;
      gfx_drawstr(">",256,gfx_x,gfx_y);
//      nnextx = gfx_x;
    ):(
      gfx_setfont(10);
      gfx_x = boxx2lo; gfx_y = boxymid;
      gfx_drawstr("< Note >",257,gfx_x,gfx_y);
    );
//    willdrawbox = 1;
    
    willstartnote = 1;
//    );
    
    
    // dB
    multisameg == 1 || (multisameg == 0 && dragtaken == 12) ? (
      dragtaken == 12 && multisameg == 0 ?(
        gfx_setfont(11);
        gfx_a = multidima;
      ):(
        gfx_setfont(3);
        gfx_a = 1;
      );

      sprintf(gstr,"%.1f",bufg[dragprev]);
    //  gfx_x = boxx4 = boxx1+ boxw *0.46;
      gfx_x = boxx3;
      gfx_y = boxy1 -ret;
    //  boxxg = gfx_x;
      gfx_drawstr(gstr,257,gfx_x,gfx_y);
      gfx_setfont(4);
      gfx_x = boxx3;
      gfx_y = boxy2 +ret;
      gfx_drawstr("dB", 257,gfx_x,gfx_y);
    ):(
      gfx_a = multidima;
      gfx_setfont(7);
      gfx_x = boxx3;
      gfx_y = boxy2 +ret;
      gfx_drawstr("dB", 261,gfx_x,gfx_y);
    );

    
    // Oct
    multisamew == 1 || (multisamew == 0 && dragtaken == 13)? (    
      dragtaken == 13 && multisamew == 0 ?(
        gfx_setfont(11);
        gfx_a = multidima;
      ):(
        gfx_setfont(3);
        gfx_a = 1;
      );
      gfx_x = boxx4;
      gfx_y = boxy1 -ret;
//      gfx_setfont(3);
      sprintf(widstr,"%.1f",bufw[dragprev]);
      gfx_drawstr(widstr,257,gfx_x,gfx_y);
      gfx_setfont(4);
      gfx_x = boxx4;
      gfx_y = boxy2 +ret;
      gfx_drawstr("Oct",257,gfx_x,gfx_y);
    ):(
      gfx_a = multidima;
      gfx_setfont(7);
      gfx_x = boxx4;
      gfx_y = boxy2 +ret;
      gfx_drawstr("Oct",261,gfx_x,gfx_y);
    );
    
    // Dynamics
    
    bufshape[dragprev] == 0 || bufshape[dragprev] == 5 ? gfx_a = .2 : gfx_a = 1;
    gfx_x = boxx5;
    gfx_y = boxy1 -ret;
    gfx_setfont(4);
    gfx_drawstr("Dyn",257,gfx_x,gfx_y);
    
    
    // Mode
    gfx_setfont(4);
    gfx_a = 1;
    gfx_x = boxx6;
    gfx_y = boxy1;
    multisamem == 1 ? (
      gfx_a = 1;
      bufm[dragprev] == 0 ? gfx_drawstr("Stereo",257,gfx_x,gfx_y);
      bufm[dragprev] == 1 ? gfx_drawstr("Mid",257,gfx_x,gfx_y);
      bufm[dragprev] == 2 ? gfx_drawstr("Side",257,gfx_x,gfx_y);
      bufm[dragprev] == 3 ? gfx_drawstr("Left",257,gfx_x,gfx_y);
      bufm[dragprev] == 4 ? gfx_drawstr("Right",257,gfx_x,gfx_y);
    ):(
      gfx_a = multidima;
      gfx_setfont(8);
      gfx_drawstr("Mode?",257,gfx_x,gfx_y);
    );

    // Link
    gmaster == 2 ? gfx_a = 1 : gfx_a = .5;
    gfx_x = boxx6;
    gfx_y = boxy2;
    
    gmaster == 1 ? multisametmp = multisamelm
    : multisametmp = multisamel;


    multisametmp == 1 || (multisametmp == 0 && dragtaken == 15)? (    
    
      gmaster != 1 ? (
        slavealone == 1 || gmaster == 0 ? gfx_a = .5 : gfx_a = 1;

        bufl[dragprev] == 0 ? (
          gfx_drawstr("Link 0%",257,gfx_x,gfx_y);
        ):(
          gfx_x -= gfx_texth + 8*ret;
          gfx_blit(4,1,0 , 210*ret,0,10*ret,20*ret , gfx_x,gfx_y+2*ret);
          val = slider(4+(dragprev-1)*4) *100;
          val > 0 && val < 10 ? gfx_x += gfx_texth*.75 :
          val >= 10 && val < 100 ? gfx_x += gfx_texth*.5 :
          val == 100 ? gfx_x += gfx_texth*.25 :
          val < 0 && val > -10 ? gfx_x += gfx_texth*.375 :
          val <= -10 && val > -100 ? gfx_x += gfx_texth*.125;
          gfx_x += 8*ret;
          gfx_drawnumber( val,0);
          gfx_drawstr("%");
        );
      );

    ):(
      gfx_a = multidima;
      gfx_setfont(8);
      gfx_drawstr("Link?",257,gfx_x,gfx_y);
    );



  ):( // No multiedit

    // Node number:  
    dragprev < 10 ? gfx_setfont(2) : gfx_setfont(6);

    gfx_x = boxx1 + 2*ret + boxw*0.05 -gfx_texth*.7;
    gfx_y = boxytop -2*ret;
    sprintf(boxnstr,"%.f",dragprev);  
    boxnL = "<";
    boxnR = ">";
    npad = 5;
    gfx_set(0.2,0,0,1,0);
    nprevx = gfx_x;
    gfx_drawstr(boxnL);
    nprevw = gfx_x-nprevx +3*0;
//    gfx_x += npad*0;
    gfx_drawstr(boxnstr);
//    gfx_x += npad*0;
    gfx_x += ret;
    nnextx = gfx_x;
    gfx_drawstr(boxnR);
    nnextw = gfx_x-nnextx +3;
    nprewh = gfx_texth*.8;
    


    // Shapes
    bufshape[dragprev] == 0 ? (
      gfx_blit(4,1,0, 0,0,30*ret,30*ret , shapex,boxymid,30*ret,30*ret);
    ) :
    bufshape[dragprev] == 1 ? (
      gfx_blit(4,1,0, 1*(30*ret),0,30*ret,30*ret , shapex,boxymid,30*ret,30*ret);
    ) :
    bufshape[dragprev] == 2 ? (
      gfx_blit(4,1,0, 2*(30*ret),0,30*ret,30*ret , shapex,boxymid,30*ret,30*ret);
    ) :
    bufshape[dragprev] == 3 ? (
      gfx_blit(4,1,0, 3*(30*ret),0,30*ret,30*ret , shapex,boxymid,30*ret,30*ret);
    ) :
    bufshape[dragprev] == 4 ? (
      gfx_blit(4,1,0, 4*(30*ret),0,30*ret,30*ret , shapex,boxymid,30*ret,30*ret);
    ) :
    bufshape[dragprev] == 5 ? (
      gfx_blit(4,1,0, 5*(30*ret),0,30*ret,30*ret , shapex,boxymid,30*ret,30*ret);
    );
      
  
    // Frequency
    gfx_x = boxx2hi;
    gfx_set(0,0,0,1);
    gfx_setfont(3);
    gfx_y = boxy1 -ret;
    sprintf(buffstr,"%.f",buff[dragprev]+.1);
    gfx_measurestr(buffstr,buffw,0);
  //  boxx1f = gfx_x - buffw*0.6;
    gfx_drawstr(buffstr,257,gfx_x,gfx_y);
  //  boxx2f = gfx_x = boxx1f + buffw*1.15;
    gfx_setfont(4);
  //  gfx_x = boxx2;
  //  gfx_y = boxy2;
    gfx_y += ret;
    gfx_x -= buffw/2 - 1*ret;
    gfx_drawstr("Hz",256,gfx_x,gfx_y);
  //  gfx_x += 2*ret;
  
    // Note name
    gfx_x = boxx2a;
    noteprevx = gfx_x - nprevw;
    gfx_y = boxy2;
    gfx_a = notea1^4 * notea2^0.25;
    gfx_setfont(3);
    gfx_drawstr("<",258,gfx_x,gfx_y);
    gfx_a = notea ;
    gfx_setfont(3);
  //  gfx_x = boxx2a;
    gfx_x = boxx2a -ret * noteoct/10;
    gfx_drawstr(notename,256,gfx_x,gfx_y);
    gfx_setfont(4);
  //  gfx_x += gfx_texth * 0.1;
    gfx_x = (boxx2b) +ret * noteoct/10;
    gfx_y += ret;
    sprintf(noteoctstr,"%.f",noteoct);
    gfx_drawstr(noteoctstr,258,gfx_x,gfx_y);
    gfx_a = notea1^0.25 * notea2^4;
    gfx_y -= ret;
    gfx_setfont(3);
    gfx_x = boxx2b;
    gfx_drawstr(">",256,gfx_x,gfx_y);
    notenextx2 = gfx_x + 3*ret;
    gfx_a = 1;
  
    gfx_setfont(3);
    gfx_measurestr("-39 dB",bufgw,0);
    
    (bufshape[dragprev] == 0 || bufshape[dragprev] == 5) ? (
      #gstr = "-6.0";
      gfx_a = multidima;
    ):(
      sprintf(#gstr,"%.1f",bufg[dragprev]);
    );
    gfx_measurestr(#gstr,gstrw,0);
  //  gfx_x = boxx4 = boxx1+ boxw *0.46;
    gfx_x = boxx3;
    gfx_y = boxy1 -ret;
  //  boxxg = gfx_x;
    gfx_drawstr(#gstr,257,gfx_x,gfx_y);
    gfx_setfont(4);
    gfx_x = boxx3;
    gfx_y = boxy2 +ret;
    gfx_drawstr("dB", 257,gfx_x,gfx_y);
    
    gfx_a = 1;
    gfx_x = boxx4;
    gfx_y = boxy1 -ret;
    gfx_measurestr("4.0 Oct",bufww,0);
    gfx_setfont(3);
    sprintf(widstr,"%.1f",bufw[dragprev]);
    gfx_drawstr(widstr,257,gfx_x,gfx_y);
    gfx_setfont(4);
    gfx_x = boxx4;
    gfx_y = boxy2 +ret;
    gfx_drawstr("Oct",257,gfx_x,gfx_y);
    
    
    bufshape[dragprev] == 0 || bufshape[dragprev] == 5 ? gfx_a = .5 : gfx_a = 1;
    gfx_x = boxx5;
    gfx_y = boxy1 -ret;
    gfx_setfont(4);
    gfx_drawstr("Dyn",257,gfx_x,gfx_y);

    
    
  
    gfx_x = boxx6;
    gfx_y = boxy1;
    gfx_a = 1;
    gfx_measurestr("Stereo",opmodew,0);
    bufm[dragprev] == 0 ? gfx_drawstr("Stereo",257,gfx_x,gfx_y);
    bufm[dragprev] == 1 ? gfx_drawstr("Mid",257,gfx_x,gfx_y);
    bufm[dragprev] == 2 ? gfx_drawstr("Side",257,gfx_x,gfx_y);
    bufm[dragprev] == 3 ? gfx_drawstr("Left",257,gfx_x,gfx_y);
    bufm[dragprev] == 4 ? gfx_drawstr("Right",257,gfx_x,gfx_y);
  
    gfx_x = boxx6;
    gfx_y = boxy2 +ret;

    gmaster != 1 ? (    

      slavealone == 1 || gmaster == 0 ? gfx_a = .5 : gfx_a = 1;
      
      bufl[dragprev] == 0 ? (
        gfx_drawstr("Link 0%",257,gfx_x,gfx_y);
      ):(
        gfx_x -= gfx_texth + 8*ret;
        gfx_blit(4,1,0 , 210*ret,0,10*ret,20*ret , gfx_x,gfx_y+2*ret);
        val = slider(4+(dragprev-1)*4) *100;
        val > 0 && val < 10 ? gfx_x += gfx_texth*.75 :
        val >= 10 && val < 100 ? gfx_x += gfx_texth*.5 :
        val == 100 ? gfx_x += gfx_texth*.05 :
        val < 0 && val > -10 ? gfx_x += gfx_texth*.375 :
        val <= -10 && val > -100 ? gfx_x += gfx_texth*.125;
        gfx_x += 8*ret;
        gfx_drawnumber( val,0);
        gfx_drawstr("%");
      );
      gfx_a = 1;
    );      
        
    gfx_measurestr("-39 dB",bufgw,bufgh);
  );
  showdyn > 0 ? willdrawdyn = 1;
  
  gfx_dest = -1;
);



function drawdyn()
  instance(x y w h x1 x2 x3 x4 x5 )(
  
  
  
  dynid = 10; // Blit
  dynfont = 8;
  dynfontb = 16;
  gfx_dest = dynid;
  gfx_setimgdim(dynid,-1,-1);
  gfx_setimgdim(dynid,dynw,dynh +2*ret);
  gfx_setfont(1);
  
  gfx_x = gfx_y = 0;
//  gfx_set(.1,.5,1,.85);
  gfx_set(.15,.4,.65,.85);
  gfx_rect(0,0,dynw,dynh);
  gfx_set(.45,.65,1,1);
  gfx_rect(0,0,dynw,dynh ,0);
  
  gfx_set(0,0,0,.95);
  gfx_rect(0,dynh,dynw,2*ret ,1);

  x1 = 3*ret;
  x2 = .135 *dynw;
  x3 = .27 *dynw;
  x4 = .51 *dynw;
  x5 = .75 *dynw;
  
  gfx_set(gr=.8,gr,gr,.5 +.4 * (bufdynena[dragprev]==1) );

  xy(x1, gfx_y -= ret);
  bufdynsol[dragprev] == 1 ? gfx_setfont(dynfontb) : gfx_setfont(dynfont);
  gfx_drawstr("Solo");
  
  gfx_x = x2;
  bufdynknee[dragprev] == 1 ? (
    gfx_setfont(dynfontb);
    gfx_drawstr("Hard");
  ):(
    gfx_x += ret *6;
    gfx_setfont(dynfont);
    gfx_drawstr("Soft");
  );
  
  gfx_x = x3;

  gfx_setfont(dynfont);
  gfx_drawstr("Att: ");
  gfx_setfont(dynfontb);
  attms[dragprev] < 1 ? gfx_drawstr( sprintf(#dest, "%.2f", attms[dragprev]) ) :
    gfx_drawstr( sprintf(#dest, "%.1f", attms[dragprev]) );
  
  
  gfx_x = x4;
  gfx_setfont(dynfont);
  gfx_drawstr("Rel: ");
  gfx_setfont(dynfontb);
  relms[dragprev] >= 100 ? gfx_drawstr( sprintf(#dest, "%.f", relms[dragprev]) ) :
    gfx_drawstr( sprintf(#dest, "%.1f", relms[dragprev]) );

  gfx_x = x5;
  gfx_setfont(dynfont);
  gfx_drawstr("Thr: ");
  gfx_setfont(dynfontb);
  gfx_drawstr( sprintf(#dest, "%.1f", thrdb[dragprev]) );
  
  
  
  gfx_dest = -1;

);



function note(f)
  instance(nn stop nnn nn2 )(
  noteoct = 0; stop = 0;
  nn = 0;
  while(stop == 0)(
    f > oct_*2^nn ? noteoct += 1 : stop = 1;
    nn += 1;
  );
//  note == max(0,(f-ab=getf(ab))/(getf(a)-ab)  )
  noten = 0;
  nnn = 0;
  stop = 0;
  while(stop == 0)(
    f > (oct_*2^(noteoct-1) *notem^nnn) ? (noten += 1) : (stop = 1);
    nnn += 1;
  );
  
  noten == 1 ? notename = "C ";
  noten == 2 ? notename = "C#";
  noten == 3 ? notename = "D ";
  noten == 4 ? notename = "D#";
  noten == 5 ? notename = "E ";
  noten == 6 ? notename = "F ";
  noten == 7 ? notename = "F#";
  noten == 8 ? notename = "G ";
  noten == 9 ? notename = "G#";
  noten == 10 ? notename = "A ";
  noten == 11 ? notename = "A#";
  noten == 12 ? notename = "B ";
  
  nn2 = oct_*2^(noteoct-1) *notem^(noten-1);
  
  notea2 = min(1, max(0, f - nn2) / (nn2*notem2 - nn2) );
  notea1 = 1- min(1, max(0, f - nn2*notem2) / (nn2*notem - nn2*notem2) );
  notea = notea1 * notea2;
  noten;

);

function multisame_old()
  instance(z)(

  // Count "multis" when Cmd-click or Shift-click
  multisumg = multisumw = multisumm = multisuml = multisums = multisumb
    = multis = 0;
  z = 1;
  loop(points,
    multiselect[z] > 0 ? (
      multisumg += bufg[z];
      multisumw += bufw[z];
      multisumm += bufm[z];
      multisuml += bufl[z];
      multisums += bufshape[z];
      multisumb += bufbyp[z];
      (multis += 1);
    );
    z += 1;
  );
  multisameg = (multisumg/multis == bufg[dragprev]);
  multisamew = (multisumw/multis == bufw[dragprev]);
  multisamem = (multisumm/multis == bufm[dragprev]);
  multisamel = (multisuml/multis == bufl[dragprev]);
  multisamelm = (multisumlm/multis == buflm[dragprev]);
  multisames = (multisums/multis == bufshape[dragprev]);
  multisameb = (multisumb/multis == bufbyp[dragprev]);
);

function multisame()
  instance(z)(
  multisaming += 1;
  // Count "multis" when Cmd-click or Shift-click
  multisameg = multisamew = multisamem = multisamel = multisamelm = multisames = multisameb
    = multisamenote = multisamed = 1;
  multis = 0;
  z = 1;
  loop(points,
    multiselect[z] > 0 ? (
      bufg[z] != bufg[dragprev] ? multisameg = 0;
      bufw[z] != bufw[dragprev] ? multisamew = 0;
      bufm[z] != bufm[dragprev] ? multisamem = 0;
      bufl[z] != bufl[dragprev] ? multisamel = 0;
      buflm[z] != buflm[dragprev] ? multisamelm = 0;
      bufshape[z] != bufshape[dragprev] ? multisames = 0;
      bufbyp[z] != bufbyp[dragprev] ? multisameb = 0;
      bufdynena[z] != bufdynena[dragprev] ? multisamed = 0;
      
      note(buff[z]) != note(buff[dragprev]) ? multisamenote = 0;
      
      (multis += 1);
    );
    z += 1;
  );
);


function widespacef()
  instance(z larl f tmpx x xposz)(
  
  points <= 2 ? (
    xpos[2] - xpos[1] > gfx_w/3 ? x = (xpos[1] + xpos[2])/2 :
    xpos[1] > (gfx_w - xpos[2]) ? x = xpos[1]/2 :
    x = xpos[2] + (gfx_w - xpos[2]) /2;
  ):(
    z = larl = 0;
    tmpx = xpos[points +1];
    xpos[points +1] = gfx_w;
    loop(points,
      (xpos[z+2] - xpos[z+1]) > (xpos[larl+1] - larl) ? larl = z+1;
      z += 1;
    );
    x = (xpos[larl] + xpos[larl +1]) /2;
    xpos[points +1] = tmpx;
  );
    
  f = min(freqmax , max(freqmin,
 ((exp((x-ret -0*3+gfx_wlim/28.275)/wscmou))-1)/800*old_srate+1*0   ));
);


function cappoint(ncp)(

  cap_drag == 0 && mouse_x > x1buf[ncp] && mouse_x < x2buf[ncp]
   && mouse_y > y1buf[ncp] && mouse_y < y2buf[ncp] && barmenu == 0 ? (
    
    pointing = 1;
    mouselist == 0 && mouse_capold == 0 ? (
      moustartx = mouse_x;
      moustarty = mouse_y;
    );
    (mouse_cap == 13 || mouse_cap == 2) && mouse_capold == 0 ? (  // Right- or Cmd-Shift-clicking a point
      listfloat = ncp;
      listchoose = 17;
      floatnode = ncp;
      listforcestay = 17;
      listnostay = nolist = 0;
    ):(
      mouse_cap == 1 ? listchoose = listchooseold = listforcestay = 0;
  
      listchooseold == 0 && choselistitem == 0 ? (
      
        mouse_cap > 1 ? (
          mouse_cap == 2 ? listforcestay = 17;
          mouse_cap == 9 ? ( // Shift-click
    
    //        dblcnt < 15 ? willshift = ncp : willshift = 0;    
            multiselect[ncp] > 0 ? (
              draggedf = 1;
              dragtaken = willshift = willshiftsel = ncp;
            ):(
              willshiftsel = ncp;
            );
            stop = 1;
          ) :
    
          mouse_cap == 5 ? ( // Cmd-click
    
            // Cmd-Clicking an already selected point
            ((multiselect[ncp] += 1) > 1) ? (
              multiselect[ncp] = 0;
              
              multis -= 1;
    
              multis <= 0 ? (
                dragprev = multis = multiedit = 0;
                forcedragprev = -1;
              ):(
                multis == 1 ? (
                  multiedit = 0;
    
                  z = 1;
                  while(z <= maxpoints)(
                    multiselect[z] > 0 ? forcedragprev2 = z;
                    z += 1;
                    z > maxpoints ? dragprev = 0;
                  );
    
                ):(   // Still multiedit
                  
                  // Select nearest
                  nearest();
                );

              );
    
            // Cmd-Clicking an unselected point
            ):(
    //          dragtaken == 0 ? (
              multiselect[ncp] = 1;
              multis += 1;
    //          dragprev = ncp;
              multis > 1 ? (
                multiedit = 1;
                dragprev = ncp;
              );
            );
            dragtaken = ncp;
          ) :
    
          mouse_cap == 17 ? (   // Alt-click
    /*
            multiedit > 0 &&  multiselect[ncp] > 0 ? (  // Clicking selected removes all selected
              z = 1;
              loop(points,
                multiselect[z] > 0 ? (
                  bufbyp[z] = 99;
                  willremove += 1;
                );
                z += 1;
              );
              dragprev = nearest();
              multiedit = 0;
              multis = 1;
            ):(
              rempoint(ncp);
            );
    */
              
            rempoint(ncp);
    
          ):(
            willshift == 0 ? multisame();
          );
    
    
    
          
        ):(   // Regular clicking a point
    
          multiselect[ncp] == 0 ? (
            zp2 = 1;
            loop(points,
              ncp == zp2 ? (
                multiselect[zp2] = 1;
              ):(
                multiselect[zp2] = 0;
              );
              zp2 += 1;
            );
            multiedit = 0;
            multis = 1;
          ); 
    
          multiedit == 1 ? (
            caploop = points;
            zp = 1;
          ):(
            caploop = 1;
            zp = ncp;
          );
          loop(caploop,
            multiselect[zp] > 0 ? (
          xpz += 1;
              bufstartx[zp] = xpos[zp]
    //            = (log(1.0+(buff[zp]/old_srate*2.0)*400)*wsc)  - wsc*0.2 +ret;
                = (log((buff[zp]-1*0)/old_srate*800+1)*wscmou-gfx_wlim/28.275+3*0);
    
    //            ((exp(((xpos[nf] )-0*3+gfx_w/28.275)/wscmou))-1)/800*old_srate+1*0 
              bufstartg[zp] = bufg[zp];
              bufstartw[zp] = bufw[zp];
              
            );
            zp += 1;
          );
          drag = dragtaken = forcedragprev = ncp;
    
    
        );
        dragnotemp = ncp;
        stop == 0 ? (
          note(buff[ncp]);
          startnoteoct[ncp] = stnoteoctmp = noteoct;
          startnote[ncp] = stnotemp = noten;
        );
        stop = 0;
        mouoffxw = mouse_x - xpos[ncp];
    
        gmaster == 2 && bufl[n] != 0 ? (
          note(buff[ncp]);
        );        
    
        drawbox();
      );
    );
  );        
    
//  drawpoints();
//  showdyn == 1 && bufdynena[drag] == 0 ? showdyn = 0;
  gfx_dest = -1;
);



function dragf(nf,dir)
  instance(gmaxmul fmaxmul)(
  
//  multiedit > 0 ? freqmax(nf);
  
  (gmaster != 2 || bufl[nf] == 0) ? (
  
    mou = 0;
    dir == "x" || dir == "xy" ?  (mou = (mouse_x-mouxold)*precise) :
    dir == "y" || dir == "xy" ?  (mou = (mouyold-mouse_y)*precise);
    
//    freqmax(nf);
    mou > 0 ? (
      xpos[nf] += min(maxinc,mou);
    ) :
    mou < 0 ? (
      xpos[nf] += max(mininc,mou);
    );
    
//    dragstop == 0 ? (
    
    buff[nf]
    
//    = min(freqmax, ((exp(((xpos[nf] )-0*3+gfx_wlim/28.275)/wscmou))-1)/800*old_srate+1*0 );
    =  ((exp(((xpos[nf] )-0*3+gfx_wlim/28.275)/wscmou))-1)/800*old_srate+1*0 ;

//    slider(willautomate = 1+(nf-1)*4) = buff[nf];
    slider(forceauto = 1+(nf-1)*4) = buff[nf];
    willreorder = 1;
      
//    );
  );
//  freqmax(nf);
  
  note(buff[nf]);
  willstartnote = nf;
  
  multiedit == 0 ? dragprev = nf;
  dragp = points;
  dragtaken > 0 && dragtaken <= 10 && dblcnt > 10 ? showf = 2;
  
  showdyn == 1 ? drawdyn();
);

function dragg(n,dir)
  instance(n)(

  (gmaster != 2 || bufl[n] == 0) && (bufshape[n] != 0 && bufshape[n] != 5) ? (

    
  //    mouoffy = moustarty - (zerog-bufg[n]*scaleg);
  //  dragtaken == 12 ? (
  //    mou = ((mouse_x-moustartx)+(moustarty-mouse_y))) : (mou = (moustarty-mouse_y));
  
  //  slider(2+(n-1)*4) = bufg[n] = tmpdrag = (zerog-(mouse_y-mouoffy))/scaleg;
  //  bufg[n] = tmpdrag = bufstartg[n] + ((mou*precise)/scaleg);
    dir == "x" || dir == "xy" ? bufg[n] += (mouse_x-mouxold)*precise /scaleg;
    dir == "y" || dir == "xy" ? bufg[n] += (mouyold-mouse_y)*precise /scaleg;
//    bufshape[n] == 0 || bufshape[n] == 5 ? bufg[n] = -6;
    bufshape[n] == 1 || bufshape[n] == 4 ? grange = 30;
    bufshape[n] == 2 ? grange = 40;
    bufshape[n] == 3 ? grange = 30;

    bufg[n] > grange ? bufg[n] = grange;
    bufg[n] < -grange ? bufg[n] = -grange;
    slider(wa = 2+(n-1)*4) = bufg[n];
    willautomate == 0 ? willautomate = wa : willautomate = floor(willautomate) + (wa*.01);
  );
);

function dragw(n,dir)
  instance(mouw)(

  gmaster != 2 || bufl[n] == 0 ? (
    mouw = 0;
    dir == "xy" ? mouw = (mouse_x-mouxold) + (mouyold-mouse_y);
    dir == "x" ? mouw = (mouse_x-mouxold);
    dir == "y" ? mouw = (mouyold-mouse_y);
  
    
    bufw[n] += ( mou = (mouw*precise)/(gfx_wlim/15) ) *(bufw[n]/2+.1);
    (bufshape[n] == 0 || bufshape[n] == 5) ? (
      bufw[n] > wmaxhplp ? bufw[n] = wmaxhplp;
      bufw[n] < wminhplp ? bufw[n] = wminhplp;
    ):(
      bufw[n] > wmax ? bufw[n] = wmax;
      bufw[n] < wmin ? bufw[n] = wmin;
    );
    

    slider(willautomate = 3+(n-1)*4) = bufw[n];
  );
);

function dragm(n)
  instance(n)(

  clickold == 0 ? (bufm[n] += 1);
  bufm[n] > 4 ? bufm[n] = 0;
//  slider_automate(slider(32+n));
//  bufm[n] = slider(32+n);
  clickold = 1;
);
function dragl(n)(
  moul = ((mouse_x-mouxold)+(mouyold-mouse_y))*precise /(75*ret);
  bufl[n] == 0 ? zp1 = 1 : zp1 = 0;
  bufl[n] += moul;
  bufl[n] == 0 ? zp2 = 1 : zp2 = 0;
//  ownpoints += zp2-zp1;
  bufl[n] < -1 ? bufl[n] = -1;
  bufl[n] > 1 ? bufl[n] = 1;
  slider(4*n) = bufl[n];
  willautomate = 4*n;
//  slider_automate(slider(4*n));
  showbox > 0 ? drawbox();
);

function dragnote(point,step)
  instance(noteup noteoctup notedown thispoint )(
  
  ( gmaster != 2 || bufl[point] == 0 ) ? (
  

    thispoint = point;
    
    step != 0 ? (
      dragtaken = -1;
      noteup = step;
    
    ):(
      mou = (mouse_x - moustartx) + (moustarty - mouse_y);
      freqmax(0);
      mou > 0 ? (
        dragstop == 2 ? (
          moustartx = mouse_x;
          moustarty = mouse_y;
          step = mou = 0;
        ):(
          step = 1;
        );
      ) :
      mou < 0 ? (
        dragstop == 2 ? (
          dragstop = 0;
          moustartx = mouse_x;
          moustarty = mouse_y;
        );
        step = -1;
      );
    //  startnoteocttmp = startnoteoct[point];
    //  startnotetmp = startnote[point];
      mou != 0 ? (
        cap_drag = 1;
        noteup = floor(mou/(gfx_wlim/120)) ;
        (startnote[point] + noteup -notedown) >= 12 ? (
          noteoctup += 1;
          notedown += 12;
        );
        (startnote[point] + noteup) <= -12 ? (
          noteoctup -= 1;
          notedown -= 12;
        );
      ):(
        noteoctup = noteup = notedown = 0;
      );
    );

    multis > 1 ? (
      l = points;
      z = 1;
    ):(
      l = 1;
      z = point;
    );
    
    loop(l,
      multiselect[z] > 0 ? (
        notef =  ( (oct_c)*2^(notemp1= startnoteoct[z]-1 +noteoctup)
        *notem^(notemp2 = startnote[z]-1 +noteup -notedown ))  ;
    
        notef < oct_c ? notef = oct_c;
//        notef > 19912.13 ?   notef = 19912.13;
//        notef = freqmax(z);

        
        buff[z] = notef;
        slider(willautomate = 1+(z-1)*4) = notef;
        note(notef);
      );
      z += 1;
    );
    willstartnote = point;
    drawbox();
    
    step != 0 ? (
      multis > 1 ? (
        eqini_all();
      ):(
        eqini_one(dragprev);
      );

      upgraph += 1;
    );
  //  noteshould = buff[dragprev];
  );
);




function capbox()
  instance(y1a y1b caploop zp zb z cn ndir cbg cbw)(
  
  boxdrag = 1;
  y1a = boxy1+3;
  y1b = boxy2-3;


  multiedit == 1 ? (
    caploop = points;
    zp = 1;
  ):(
    caploop = 1;
    zp = dragprev;
  );
  loop(caploop,
    multiselect[zp] > 0 ? (
      multicap += 1;
      bufstartx[zp] = xpos[zp]
//            = (log(1.0+(buff[zp]/old_srate*2.0)*400)*wsc)  - wsc*0.2 +ret;
//        = (log((buff[zp]-1)/old_srate*800+1)*wscmou-gfx_wlim/27.5+3);
        = (log((buff[zp]-1*0)/old_srate*800+1)*wscmou-gfx_wlim/28.275+3*0);
      bufstartg[zp] = bufg[zp];
      bufstartw3[zp] = bufw[zp]^(1/3);
    );
    zp += 1;
  );



  moustartx = mouse_x;
  moustarty = mouse_y;

//  mouoffx = mouse_x-(log((buff[n]-1)/old_srate*800+1)*wscmou-gfx_w/27.5+3);
//  mouoffx = mouse_x-(log((buff[dragprev]-1)/old_srate*800+1)*wscmou-gfx_wlim/27.5+3);
  mouoffx = mouse_x-(log((buff[dragprev]-1*0)/old_srate*800+1)*wscmou-gfx_wlim/28.275+3*0);
                  
  dragtaken == 12 ? mouoffy = mouse_y - (zerog-bufg[dragprev]*scaleg);
  dragtaken == 13 ? mouoffy = 0;
//å


//  // Bypass Checkbox
  listchoose == 0 ? (
    
    mouse_x > boxx1 && mouse_x < min(noteprevx-5, shapex + (35*ret)) ? (

      mouse_y < boxymid ? (             // Next/Prev node
        mouse_x < nprevx+nprevw && multiedit == 0 ? (
          (mouse_cap & 12) && (dragprev > 1) ? (
            multiedit = 1;
            multis += 1;
            multiselect[dragprev] = 1;   
            dragprev -= 1;
            multiselect[dragprev] = 1;        
          ):(
            dragprev -= 1;
            dragtaken = -1;
          );
        ):(
          mouse_x > nnextx && multiedit == 0 ? (
            (mouse_cap & 12) && (dragprev < points) ? (
              multiedit = 1;
              multis += 1;
              multiselect[dragprev] = 1;        
              dragprev += 1;
              multiselect[dragprev] = 1;        
            ):(
              dragprev += 1;
              dragtaken = -1;
            );
          ):(
            listchoose = dragtaken = 16;
          );
        );
        note(buff[dragprev]);
        drawbox();
      ):(
        
        // Shape
        mouse_x > chx+chw+ret ? (
          listchoose = dragtaken = 17;

        // Bypass
        ):(
          multiedit > 0 ? (

            zb = 1;
            loop(points,
              multiselect[zb] > 0 ? (bufbyp[zb] = (bufbyp[zb] + 1) > 1 ? 0 : 1);
              zb += 1;
            );


            multisameb = 1;
          ):(
            (bufbyp[dragprev] += 1) > 1 ? (bufbyp[dragprev] = 0);
          );
          dragtaken = -1;
          drawbox();
          mutespls = 200;
          
          upgraph += 2;
          
        );
          
      );
    ) :
    
    
    



    (mouse_x > (boxx4+boxx5)/2 && mouse_x < (boxx5+boxx6)/2) ? (    // Dynamics
      mouse_y > boxymid ? (
        dragtaken = 101 ;
/*        
        (bufdynena[dragprev] += 1) > 1 ? (
          bufdynena[dragprev] = showdyn = 0 ;
        );
        
        multiedit > 0 ? (
/*
          cbw = 1;
          loop(points,
            multiselect[cbw] > 0 ? (
              (bufdynena[cbw] += 1) > 1 ? bufdynena[cbw] = 0 ;
            );
            cbw += 1;
          );
* /
          cbw = 1;
          loop(points,
            multiselect[cbw] > 0 ? bufdynena[cbw] = bufdynena[dragprev] ;
            cbw += 1;
          );
        );
*/
      ):(
        dragtaken = 100;
      );
    ) :








    

    mouse_x > (boxx5+boxx6)/2 && mouse_x < (boxx1+boxw) ? ( // Stereo mode
      mouse_y < boxymid ? (
        listchoose = dragtaken = 14;
      ):(    
        /*gmaster == 2 ?*/ dragtaken = 15;
        gmaster == 1 ? (
          multiedit > 0 && moualt == 0 ? (
            
/*            
            z = 1;
            loop(points,
              multiselect[z] > 0 ? (
                (buflm[z] += 1) > 1 ? (buflm[z] = 0);
              );
              z += 1;
            );
*/
            multisamelm == 0 ? (
              z = 1;
              loop(points,
                multiselect[z] > 0 ? (
                  (buflm[z] = 1);
                  multisamelm = 1;
                );
                z += 1;
              );
            ):(
              z = 1;
              loop(points,
                multiselect[z] > 0 ? (
                  (buflm[z] += 1) > 1 ? (buflm[z] = 0);
                );
                z += 1;
              );
            );

          ):(
            (buflm[dragprev] += 1) > 1 ? (buflm[dragprev] = 0);
          );

        );
        willdrawbox += 1;
        whatmultibuf += 1;

      );      
    
    );
  );
  
  dragtaken == 0 ? (
    (mouse_x > (boxx1+boxx2b)/2 && mouse_x < (boxx2lo+boxx3)/2 && mouse_y < boxymid) ? (
      dragtaken = 11 ) : // Frequency


    
    (mouse_x > (noteprevx) && mouse_x < (notenextx2) && mouse_y > boxymid) ? (
      dragtaken = 20; // Note

//      (mouse_x > (boxx2a) && mouse_x < (boxx2b)) || (multiedit == 1 && multisamenote == 0) ? (
      (mouse_x > (boxx2a) && mouse_x < (boxx2b)) ? (
        cn = 1;
        loop(points,
          multiselect[cn] > 0 ? (
            note(buff[cn]);
            startnoteoct[cn] = noteoct;
            startnote[cn] = noten;
          );
          cn += 1;
        );
        ndir = 0;
      
      ) :

      mouse_x < boxx2a ? ndir = -1 :
      mouse_x > boxx2b ? ndir = 1 ;
//      ndir = 0;

      multiedit == 0 ? (
        dragnote(dragprev, ndir);
      ):(
        cn = 1;
        loop(points,
          note(buff[cn]);
          dragnote(cn, ndir);
          cn += 1;
        );
      );                


    ) :
    
    
    
    (mouse_x > (boxx2lo+boxx3)/2 && mouse_x < (boxx3+boxx4)/2) ? (    // Gain
      dragtaken = 12;
      multiedit > 0 ? (
        cbg = 1;
        loop(points,
          multiselect[cbg] > 0 ? bufstartg[cbg] = bufg[cbg];
          cbg += 1;
        );
      ):(
        bufstartg[dragprev] = bufg[dragprev];
      );
    ) :
    (mouse_x > (boxx3+boxx4)/2 && mouse_x < (boxx4+boxx5)/2) ? (    // Width
      dragtaken = 13;
      multiedit > 0 ? (
        cbw = 1;
        loop(points,
          multiselect[cbw] > 0 ? bufstartw3[cbw] = bufw[cbw]^(1/3);
          cbw += 1;
        );
      );
    ) ;

/*
    (mouse_x > (boxx4+boxx5)/2 && mouse_x < (boxx5+boxx6)/2) ? (    // Dynamics
      mouse_y > boxymid ? (
        dragtaken = 101 ;
//        multiedit > 0 ? (
          cbw = 1;
          loop(points,
            multiselect[cbw] > 0 ? (
              (bufdynena[cbw] += 1) > 1 ? (
                soloid == cbw ? soloid = 0;
//                bufdynena[cbw] = bufdynsol[cbw] = 0 ;
              );
                
            );
            cbw += 1;
          );
//        );
      ):(
        dragtaken = 100;
      );
      willdrawpoints = 1;
    );
*/
  
  
  );

);

function capdyn()
  instance()(
  
  mouse_cap > mouse_capold && mouse_capold == 0 ? (
    mouse_x < dynx + drawdyn.x2 ? drag = 102 :
    mouse_x < dynx + drawdyn.x3 ? drag = 103 :
    mouse_x < dynx + drawdyn.x4 ? drag = 104 :
    mouse_x < dynx + drawdyn.x5 ? drag = 105 :
    drag = 106;
  );    
  dragtaken = drag ;
  
);


function dragbox(dra)(

  moux = mouse_x - mouoffx;
  mouy = mouse_y - mouoffy;

  (dragtaken == 11 ) ? (
    

    multiedit > 0 && moualt == 0 ? (
      freqmax(0);
      z = 1;
      loop(points,  
        multiselect[z] > 0 ? (
          moushft == 0 ? dragf(z,"xy") : ( dragg(z,"y"); dragw(z,"x"); );
          eqini_one(z);
          
        );
        z += 1;
      );
    ):(
      freqmax(dragprev);
      moushft == 0 ? dragf(dragprev,"xy") : ( dragg(dragprev,"y"); dragw(dragprev,"x"); );
      eqini_one(dragprev);
      
    );
  );
  
  
  dragtaken == 20 ? (
  
/*
    multiedit == 1 && moualt == 0 ? (
      moualt != moualtold ? ( 
        z = 1;
        loop(points,
          multiselect[z] > 0 ? (
            note(buff[z]);
            startnoteoct[z] = noteoct;
            startnote[z] = noten;
          );
          z += 1;
        );
      );
      mounote = startnote[2];
      moualt == 0 ? (
        z = 1;
        loop(points,
          (multiselect[z] == 1) ? (
            dragnote(z,0);
          );
          z += 1;
        );
      ):(
        dragnote(dragprev,0);
      );
        
    ):(
      dragnote(dragprev,0);
      p=0;
    );
    note(buff[dragprev]);
    gmaster != 2 ? reorder_all();
*/

    multiedit == 1 ? (
      moualt != moualtold ? ( 
        moustartx = mouse_x;
        moustarty = mouse_y;
        z = 1;
        loop(points,
          multiselect[z] > 0 ? (
            note(buff[z]);
            startnoteoct[z] = noteoct;
            startnote[z] = noten;
          );
          z += 1;
        );
      );
      mounote = startnote[2];

      moualt == 0 ? (
        z = 1;
        loop(points,
          (multiselect[z] > 0) ? (
            dragnote(z,0);
          );
          z += 1;
        );
      ):(
        dragnote(dragprev,0);
      ); 
    ):(
      dragnote(dragprev,0);
    );
    note(buff[dragprev]);
//    gmaster != 2 ? reorder_all();
    gmaster != 2 ? willreorder = 1;
  );


  dragtaken == 12 ? (
  
    multiedit > 0 && moualt == 0 ? (
      z = 1;
      loop(points,
        multiselect[z] > 0 ? (
        
          moushft == 0 ? dragg(z,"xy") : dragw(z,"xy");
          eqini_one(z);
          
        );
        z += 1;
      );
    ):(
      moushft == 0 ? dragg(dragprev,"xy") : dragw(dragprev,"xy");
      eqini_one(dragprev);
      
    );
  );
  dragtaken == 13 ? (
    multiedit > 0 && moualt == 0 ? (
      z = 1;
      loop(points,
        multiselect[z] > 0 ? (
          moushft > 0 ? dragg(z,"xy") : dragw(z,"xy");
          eqini_one(z);
        );
        z += 1;
      );
    ):(
      moushft > 0 ? dragg(dragprev,"xy") : dragw(dragprev,"xy");
      eqini_one(dragprev);
      
    );
  );
  

  dragtaken == 15 ? ( // Link

    gmaster != 1 ? (  // SLAVE Link
      ccc = color*100;
      multiedit > 0 && moualt == 0 ? (
//        ownpoints = 0;
        z = 1;
        loop(points,
          multiselect[z] > 0 ? dragl(z);
          multisamel = 1;
          gmaster == 2 && bufl[z] != 0 && gmem[ccc+ z*10+2] != 0 ? (
            buff[z] = (gmem[ccc+z*10+1]*.1);
            bufg[z] = (gmem[ccc+z*10+2]*.1-100) *bufl[z];
            eqini_one(z);
          );
          z += 1;
        );
//        gmemslave();
      ):(
//        bufl[dragprev] == 0 ? zp1 = 1 : zp1 = 0;
        multiselect[dragprev] > 0 ? dragl(dragprev);
//        bufl[dragprev] == 0 ? zp2 = 1 : zp2 = 0;
//        ownpoints += zp2-zp1;
        gmaster == 2 && bufl[dragprev] != 0 && gmem[ccc+ dragprev*10+2] != 0 ? (
          buff[dragprev] = (gmem[ccc+ dragprev*10+1]*.1);
          bufg[dragprev] = (gmem[ccc+ dragprev*10+2]*.1-100) *bufl[dragprev];
//          bufggg = bufg[3];
          eqini_one(dragprev);
        );
      );
      drawpoints();
      upsliders();
    );
  

  );  

  z = 1;
  loop(points,
    multiselect[z] > 0 ? (
      buff[z] < freqmin || bufg[z] < -gainmax || bufw[z] < wmin ? dragstop = 1;
      buff[z] > freqmax(z) || bufg[z] > gainmax || bufw[z] > wmax ? dragstop = 2;
      dragstop > 0 ? eqini_one(z);
    );
    z += 1;
  );


//  multiedit > 0 ? (eqini_all(); dragprev = dra;) : eqini_one(dragprev=dra);
  upgraph < 10 ? upgraph += 1;
  

);

function dragdyn()
  instance(mou n spd)(
  
  mou = (mouse_x-mouxold) + (mouyold-mouse_y);
  spd = .003 / (1+ 3*(mouse_cap > 1));
  
  drag == 102 && bufdynena[dragprev] == 1 ? (
    soloid == dragprev ? (
      bufdynsol[dragprev] = soloid = 0;
    ) :
    soloid == 0 ? (
      bufdynsol[dragprev] = 1;
      soloid = dragprev;
    ):(
      bufdynsol[soloid] = 0;
      bufdynsol[dragprev] = 1;
      soloid = dragprev;
    );      
    drag = dragtaken = -1;
  ) :

  drag == 103 ? (
    (bufdynknee[dragprev] += 1) > 1 ? bufdynknee[dragprev] = 0;

    multiedit > 0 ? (
      n = 1;
      loop(points,
        bufdynknee[n] = bufdynknee[dragprev];
        n += 1;
      );
    );  
    drag = dragtaken = -1;
  ) :
  
  drag == 104 ? (
    multiedit > 0 ? (
      n = 1;
      loop(points,
        bufdynena[n] > 0 ? (
          bufdynatt[n] += mou *spd;
          bufdynatt[n] = max(0, min(1, bufdynatt[n]));
        );
        n += 1;
      );
    ):(
      bufdynatt[dragprev] += mou *spd;
      bufdynatt[dragprev] = max(0, min(1, bufdynatt[dragprev]));
    );
  ) :

  drag == 105 ? (
    multiedit > 0 ? (
      n = 1;
      loop(points,
        bufdynena[n] > 0 ? (
          bufdynrel[n] += mou *spd;
          bufdynrel[n] = max(0, min(1, bufdynrel[n]));
          
        );
        n += 1;
      );
    ):(
      bufdynrel[dragprev] += mou *spd;
      bufdynrel[dragprev] = max(0, min(1, bufdynrel[dragprev]));
    );
  ) :

  drag == 106 ? (
    multiedit > 0 ? (
      n = 1;
      loop(points,
        bufdynena[n] > 0 ? (
          bufdynthr[n] += mou *spd;
          bufdynthr[n] = max(0, min(1, bufdynthr[n]));
        );
        n += 1;
      );
    ):(
      bufdynthr[dragprev] += mou *spd;
      bufdynthr[dragprev] = max(0, min(1, bufdynthr[dragprev]));
    );
  );
  
  multiedit > 0 ? compini_all() : compini_1(dragprev);
  
  willautomate = 61;
/*
  dragprev == 1 ? eq1.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
  dragprev == 2 ? eq2.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
  dragprev == 3 ? eq3.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
  dragprev == 4 ? eq4.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
  dragprev == 5 ? eq5.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
  dragprev == 6 ? eq6.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
  dragprev == 7 ? eq7.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
  dragprev == 8 ? eq8.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
  dragprev == 9 ? eq9.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
  dragprev == 10 ? eq10.compini( bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev );  
*/
);
  

function chooselist(list)(
  listh = gfx_texth*1.1;
  listedge = 3*ret;
  imgr = gfx_texth*.35;
  listpad = 15*ret;
  listw = listpad + imgxoff*2;
  
  
  list == 14 ? (
    gfx_measurestr("Stereo",listw_,0);
    listw += listw_;
    listytop = (listybot = boxytop) - (items=5)*listh;
    listx = boxx6 -5*ret;
    imgxoff = imgr *1.3 ;
    );
/*
  list == 15 ? (
    gfx_measurestr(" Bypass Link ",listw,0);
    listytop = (listybot = boxymid) - (items=2)*listh;
    listx = (boxx5+boxx4)/2;
    imgxoff = 0 ;
  );
*/
  list == 16 ? (
    gfx_setfont(1);
    gfx_measurestr("10",listw_,0);
    listw += listw_;
    listh = gfx_texth *1;
    listw > boxx1 ? listx = boxx2a +gfx_texth *.8 : listx = boxx1 - listw;

    listhtot = min(maxpoints +1, items=points +2)*listh;
    listytop = (listybot = boxytop +listh) - (listhtot );

    imgxoff = imgr *2 ;
  );

  list == 17 ? (
    gfx_measurestr("High Shelf",listw_,0);
    listw += listw_;
    listh = gfx_texth *1.2;

    listfloat > 0 ? ( // listfloat
//      listx = max(listw, min(gfx_w-listw/2-20, moustartx ));
      imgxoff = imgr *2 ;
      multiedit > 0 && multiselect[listfloat] > 0 ? items = 7 : items = 6;
//      moustarty < gfx_h/3-5*ret ? listytop = moustarty : listytop = moustarty - listh*items;
//      listytop = (moustarty/gfx_h) * (gfx_h-listh*items);
      listytop = ((moustartx/gfx_wlim)*.2+.8*(moustarty/gfx_h)) * (gfx_h-listh*items);
      listytop = max(moustarty-listh*(items-.5) , min(moustarty-listh*.5, listytop) );
      moustartx < gfx_wlim/2 ? listx = moustartx+listw*.72 : listx = moustartx - listw*.5;
      listybot = listytop + (items) *listh;
    ):(
      multiedit > 0 ? (
        listytop = (listybot = boxymid) - (items=7)*listh;
      ):(
        listytop = (listybot = boxymid) - (items=6)*listh;
      );
      listx = boxx2a;
      imgxoff = imgr *2 ;
    );
    
  );
  listhtot = listybot-listytop +ret;
  
  listx1 = listx - listw/2 -imgxoff - listpad/2 *0;
  listx2 = listx1 + listw;
  imgx = listx1 + imgr*1.5;
  
  showbox == 1 && listchoose == 17 && listfloat > 0 && dragprev != listfloat ? (
    multiedit == 1 && multiselect[listfloat] == 1 ? darklist = 0 : darklist = 1;
  ):(
    darklist = 0;
  );
  
  darklist ? gfx_set(.5,.1,.05,1,0) : gfx_set(.5,.25,.0,1,0);
  gfx_rect(listx1-listedge,listytop-listedge,listw+listedge*2,listhtot+listedge*2);
  darklist ? gfx_set(.457,.42,.37,1,0) :
  multiedit == 1 ? gfx_set(.65,.5,.3,1,0) :
    gfx_set(.68,.52,.22,1,0);
  gfx_rect(listx1,listytop,listw,listhtot);
  gfx_set(.55,.3,.0,.5,0);
  list == 16 ? gfx_line(listx-18*ret,listytop+listh,listx-18*ret,listybot);
  z = 1;
  loop(items-1,
    gfx_line(listx1,listytop+listh*z,listx2,listytop+listh*z);
    z += 1;
  );
  
  gfx_set(0,0,0,1,0);
  gfx_setfont(9);
  
  list == 14 ? (
    gfx_x = listx; gfx_y = listytop +ret;
    bufm[dragprev] == 4 ? ( gfx_setfont(14); gfx_y -= ret; ) : gfx_setfont(9);
    gfx_drawstr("Right",257,gfx_x,gfx_y);
    gfx_x = listx; gfx_y = listytop +ret+listh*1;
    bufm[dragprev] == 3 ? ( gfx_setfont(14); gfx_y -= ret; ) : gfx_setfont(9);
    gfx_drawstr("Left",257,gfx_x,gfx_y);
    gfx_x = listx; gfx_y = listytop +ret+listh*2;
    bufm[dragprev] == 2 ? ( gfx_setfont(14); gfx_y -= ret; ) : gfx_setfont(9);
    gfx_drawstr("Side",257,gfx_x,gfx_y);
    gfx_x = listx; gfx_y = listytop +ret+listh*3;
    bufm[dragprev] == 1 ? ( gfx_setfont(14); gfx_y -= ret; ) : gfx_setfont(9);
    gfx_drawstr("Mid",257,gfx_x,gfx_y);
    gfx_x = listx; gfx_y = listytop +ret+listh*4;
    bufm[dragprev] == 0 ? ( gfx_setfont(14); gfx_y -= ret; ) : gfx_setfont(9);
    gfx_drawstr("Stereo",257,gfx_x,gfx_y);
    
    gfx_set(.25,.15,.0,1);
    r=0;
    loop(2*ret,   gfx_arc(imgx,listytop + 0.5* listh, imgr-r, .5,2.64);   r += 1;   );
    r=0;
    loop(2*ret,   gfx_arc(imgx,listytop + 1.5* listh, imgr-r, -2.54,-.6);   r += 1;   );
    r=0;
    loop(2*ret,   gfx_arc(imgx,listytop + 2.5* listh, imgr-r, -2.34,-.8);   r += 1;   );
    r=0;
    loop(2*ret,   gfx_arc(imgx,listytop + 2.5* listh, imgr-r, .7,2.44);   r += 1;   );
    r=0;
    loop(2*ret,   gfx_arc(imgx,listytop + 3.5* listh, imgr-r, -1,.9);   r += 1;   );
    r=0;
    loop(2*ret,   gfx_circle(imgx,listytop + 4.5* listh, imgr-r);   r += 1;   );
  );
/*  
  list == 15 && gmaster == 1 ? (
    gfx_x = listx; gfx_y = listytop;
    bufl[dragprev] != 0 ? ( gfx_setfont(1); gfx_y -= ret; ) : gfx_setfont(9);
    gfx_drawstr("Active",257,gfx_x,gfx_y);
    gfx_x = listx; gfx_y = listytop+listh*1;
    bufl[dragprev] == 0 ? ( gfx_setfont(1); gfx_y -= ret; ) : gfx_setfont(9);
    gfx_drawstr("Bypass Link",257,gfx_x,gfx_y);
  );
*/
  list == 16 ? (
    
    nr = .2; ng = nb = 0; 
    rr = .7; rg = rb = 0;
    wr = wg = wb = .8;

    orderchk.checkbox(listx1 + ret*4 , listytop + ret*2 , 1, reorder );
    
    gfx_set(nr,ng,nb,1);
    xy(listx1 + listw -ret*4 ,listytop);
    gfx_setfont(5);
    gfx_drawstr("Order",258,gfx_x,gfx_y);

    points < maxpoints ? (
      multiedit == 0 ? (
        gfx_x = listx ;
        gfx_y = listytop +listh + ret;
        gfx_set(nr,ng,nb,.5);
        gfx_setfont(9);
        gfx_drawstr("+");
      ):(
        gfx_x = listx -0*ret;
        gfx_y = listytop +listh + ret;
        gfx_set(nr,ng,nb,.5);
        gfx_setfont(12);
        gfx_drawstr("Multi:",257,gfx_x,gfx_y);
        
      );
    );
    gfx_a = 1;
    pz = points;  
    loop(points,
      gfx_set(nr,ng,nb);
      gfx_x = listx;
      gfx_y = listytop + listh* (points-pz+2);
      points == maxpoints ? gfx_y -= listh;
      
/*
      multiedit == 0 ? (
        pz == dragprev ? gfx_setfont(1) : gfx_setfont(9);
      ):(
*/
      gfxy = gfx_y;
      gfxx = gfx_x;
      multiselect[pz] > 0 ? (
        gfx_setfont(3);
        
        gfx_y -= 2*ret;
        gfx_x -= 1*ret;
      ):(
        gfx_setfont(4);
      );
      pz >= 10 ? gfx_x -= gfx_texth *.45;
//      );
      
      gfx_drawnumber(pz,0);
      gfx_y = gfxy;
      gfx_x = gfxx;
//      gfx_drawstr("8",257,gfx_x,gfx_y);
      gfx_set(rr,rg,rb);
      gfx_circle(imgx+ret,gfx_y += listh/2+1, imgr , 1,1);
      gfx_set(wr,wg,wb);
      gfx_setfont(14);
      gfx_y -= 2;
      gfx_x = imgx+ret +1;
      gfx_drawstr("x",261,gfx_x,gfx_y);
      pz -= 1;
    );
  );

  list == 17 ? (
    floatwas == 0 ? floatwas = listfloat;
    listytop17 = listytop;
  
    listfloat > 0 ? (
      nf = listfloat;
      multiedit > 0 && multiselect[listfloat] > 0 ? nfn = 1 : nfn = 0;
    ) :    
    (multiedit > 0 && multiselect[dragprev] > 0) ? (
      nf = dragprev;
      nfn = 1;
    ):(
      nf = dragprev;
//      nf = listfloat;
      nfn = 0;
    );
    
    (multiedit > 0 && nfn == 1) ? (
      gfx_setfont(9);
      gfx_x = listx; gfx_y = listytop17 = listytop +ret;
      gfx_drawstr("Auto",257,gfx_x,gfx_y);
    );
    bufshape[nf] == 5 ? gfx_setfont(14) : gfx_setfont(9);
    gfx_x = listx; gfx_y = listytop17 + listh*(0+nfn);
    gfx_drawstr("Low Pass",257,gfx_x,gfx_y);
    bufshape[nf] == 4 ? gfx_setfont(14) : gfx_setfont(9);
    gfx_x = listx; gfx_y = listytop17+listh*(1+nfn);
    gfx_drawstr("High Shelf",257,gfx_x,gfx_y);
    bufshape[nf] == 3 ? gfx_setfont(14) : gfx_setfont(9);
    gfx_x = listx; gfx_y = listytop17+listh*(2+nfn);
    gfx_drawstr("Flat Top",257,gfx_x,gfx_y);
    bufshape[nf] == 2 ? gfx_setfont(14) : gfx_setfont(9);
    gfx_x = listx; gfx_y = listytop17+listh*(3+nfn);
    gfx_drawstr("Peak",257,gfx_x,gfx_y);
    bufshape[nf] == 1 ? gfx_setfont(14) : gfx_setfont(9);
    gfx_x = listx; gfx_y = listytop17+listh*(4+nfn);
    gfx_drawstr("Low Shelf",257,gfx_x,gfx_y);
    bufshape[nf] == 0 ? gfx_setfont(14) : gfx_setfont(9);
    gfx_x = listx; gfx_y = listytop17+listh*(5+nfn);
    gfx_drawstr("High Pass",257,gfx_x,gfx_y);
    
    gfx_set(.25,.15,.0,1);
    (multiedit > 0 && nfn == 1) ? (
      gfx_blit(4,1,0, 6*(30*ret),0,30*ret,30*ret , listx1,listytop17,30*ret,30*ret);
//      gfx_blit(4,1,0, 2*(30*ret),0,30*ret,30*ret , listx1,listytop17+listh*2,30*ret,30*ret);
    );
    gfx_blit(4,1,0, 5*(30*ret),0,30*ret,30*ret , listx1,listytop17+listh*(0+nfn),30*ret,30*ret);
    gfx_blit(4,1,0, 4*(30*ret),0,30*ret,30*ret , listx1,listytop17+listh*(1+nfn),30*ret,30*ret);
    gfx_blit(4,1,0, 3*(30*ret),0,30*ret,30*ret , listx1,listytop17+listh*(2+nfn),30*ret,30*ret);
    gfx_blit(4,1,0, 2*(30*ret),0,30*ret,30*ret , listx1,listytop17+listh*(3+nfn),30*ret,30*ret);
    gfx_blit(4,1,0, 1*(30*ret),0,30*ret,30*ret , listx1,listytop17+listh*(4+nfn),30*ret,30*ret);
    gfx_blit(4,1,0, 0*(30*ret),0,30*ret,30*ret , listx1,listytop17+listh*(5+nfn),30*ret,30*ret);

  );
);



function dragpoint(n)
  instance(n dpm)(


  gmaster != 2 || bufl[n] == 0 ? (
    gmeeee += 1;
    dragtaken == n ? (
      removing == 0 ? (
        multiedit == 0 || moualt > 0 ? (
          moushft > 0 ? (  // Shift-drag
            dragw(n,"xy");
            bufw[n] < wmin ? bufw[n] = wmin;
            bufw[n] > wmax ? bufw[n] = wmax;
          ):(                    // Drag or Cmd-Drag
            freqmax(n);
            
            dragf(n,"x");
            dragg(n,"y");
//            buff[n] > freqmax ? buff[n] = freqmax;
//            buff[n] < freqmin ? buff[n] = freqmin;
          //    bufg[n] > dbran ? bufg[n] = dbran;
          //    bufg[n] < -dbran ? bufg[n] = -dbran;
          );
          eqini_one(n);
        ):(
          freqmax(0);
          
          dpm = 1;
          loop(points,
            multiselect[dpm] > 0 ? (
              mouse_cap == 9 || mouse_cap == 13 ? ( // Shift-drag
                dragw(dpm,"xy");
              ):(
              multitmp = dpm;
                dragf(dpm,"x");
//                buff[dpm] > freqmax ? buff[dpm] = freqmax;
//                buff[dpm] < freqmin ? buff[dpm] = freqmin;
                dragg(dpm,"y");
              );
              eqini_one(dpm);
            );
            dpm += 1;
          );
        );
      );
    );
    drawbox();
  ):(
    dragprev = n;
    willdrawbox += 1;
  );
);


function mouhlp(x y w h id)(
  mouse_x < but_h || mouse_x > gfx_w-but_h || mouse_y < but_h*1.2 ? dragtaken = cap_drag = 98;

  
  mouse_cap > mouse_capold && mouse_capold == 0 ? (
  
    mouse_x >  gfx_w-but_h && mouse_y >  gfx_h-but_h && helpa > .5 ? (
      help = -1;
    ):(
  
      mouse_x < but_h ? helpage == 1 ? helpage = 0 : helpage = 1;
      
      mouse_x > x && mouse_y > y && mouse_x < x+w && mouse_y < y+h ? (
        helpage == id ? helpage = 0 : helpage = id;
        drag = 0;
        dragtaken = 98;
        nocap = 1;
      );
    );
  );
);

// END FUNCTIONS






































// MOUSE CAP MODES

mouse_cap > 1 ? (

  mourght = (mouse_cap & 2 ? 1 : 0);
  moucmd = (mouse_cap & 4 ? 1 : 0);
  moushft = (mouse_cap & 8 ? 1 : 0);
  moualt = (mouse_cap & 16 ? 1 : 0);
);
mouse_cap > 0 ? (
  mous = 1;
  mouse_cap == 1 ? mourght = moucmd = moushft = moualt = 0;
):(
  mous = 0;
);



willdragpoint > 0 ? (
  willdragpoint = 0;
  mouse_cap > 0 ? (
    drag = dragtaken = forcedragprev = dragprev;
  );
);
  
    

// MOUSE CAPS

help == 0 ? (

  listchoose == 17 && mouselist == 0 && mouse_cap > mouse_capold && mouse_capold == 0 ? (
    listchoose = listchooseold = choselistitem = 0;
    nolist = 1;
  );

  dblcnt > 0 && dblcnt < 15 ? dblcnt += 1;
  dblcnt >= 15 ? (dblstage = -5 );
  
  mouse_cap > 0 ?  dralone0 = dragprev;
  
  (mous > 0 || forcedrag > 0) && help == 0 ? ( // Mouse is clicked
    noadd > 0 && dblstage == 0 ? noadd = 0;
    
    mous == 1 ? forcedrag = 0;
  
  
    // DOUBLE-CLICKS
    dblcnt == 0 ? (
      dblcnt = 1;
    );
    dblcnt > 0 ? (
      dblstage == 0 ? dblstage = nuclk = 1;
      dblstage == 2 ? (
        dblstage = 3;
  //      dbltgt = dragtaken;
        
      );
    );
    //////////////////
    
  //  dragtaken > 0 && dragtaken < 20 ? cap_mode = 0;
    
  
  
    // CAPTURES
    
    
    (dragtaken == 0 || dragtaken == 17) && forcedragprev2 == 0 && mouselist == 0 ? (
      ncp = 1;
      loop(points,
        cappoint(ncp);
        ncp += 1;
      );
    );

    drag > 0 && drag <= maxpoints && showdyn == 1 && bufdynena[drag] == 0 ? (
      showdyn = 0;
      upgraph += 1;
    );
    
    dragtaken > 0 && dragtaken < 100 && dyns > 0 ? (
//      (bufdynthr[dragprev] == 1 || multiedit > 0) ? (
    
      multiedit > 0 ? (
        dyns = 0;
        ncd = 1;
        loop(points,
          bufdynena[ncd] == 1 && bufdynthr[ncd] == 1 ? (
            bufdynena[ncd] = 0;
            willdrawbox = 1;
          );
          bufdynena[ncd] == 1 ? dyns = 1;
          ncd += 1;
        );
      ):(
        bufdynthr[dragprev] == 1 ? bufdynena[dragprev] = showdyn = 0;
      );
      
    );
  
    // Mouse Capture Redirects
    ((dragtaken == 0 && cap_drag == 0) && listchoose == 0) ? (
  
      showbox > 0 && mouse_x > boxx1 && mouse_x < (boxx1+boxw) && mouse_y > boxytop && mouse_y < boxybot
  //    && (last_mouse_cap == 0 && mouse_cap > 0)
      ? (
        listchoose == 0 && barmenu == 0 ? (
          capbox();
        );
      ) :
      
      showdyn > 0 && mouse_x > dynx && mouse_x < (dynx+dynw) && mouse_y > dyny && mouse_y < dyny+dynh
  //    && (last_mouse_cap == 0 && mouse_cap > 0)
      ? (
        listchoose == 0 ? (
          capdyn();
        );
      ) :
  
      mouse_x < dbw && mouse_y > but_h && mouse_y < coly ? (
        dragtaken = 19;
      ) :
  
      mouse_x > gainx && mouse_y > but_h ? (
        mouse_y < helpy ? dragtaken = 18
        :(
          dragtaken = 99; // HELP
          help = 1;
        );
      );
      
      
  //    mouse_y > zerog-20*ret && mouse_y < zerog+20*ret && mouse_x > dbw ? dragtaken = 91; 
    );
      
    
  //  listchoose > 0 && dragtaken == listchoose ? (
    (last_mouse_cap == 0 && mouse_cap > 0) && (dragtaken == dragtakenold)
    && chooselist == 0 ? (
      anolist += 1;
      nolist = -1;
    );
  //ää
    
  
  
  
    // DRAGGING
    forcedragprev2 == 0 ? (
      dragtaken > 0 ? ( 
        dragtaken <= 10 ? (
          dragpoint(dragtaken);
//          eqini_one(dragtaken);
          upgraph += 2;
          
        ) :
        dragtaken < 18 || dragtaken == 20 ? (
          dragbox();
        );
      );  
    );
    
  
  
    drawpoints();
  
  
  ):(                   // Mouse is not clicked:
  
    // DOUBLE-CLICKS (released)
    dblcnt > 0 ? (
      dblstage == 1 ? dblstage = 2;
      dblstage == 3 ? (
        dblclk = dbltgt;
        last_mouse_cap == 9 ? dblclkshft = 1;
        dblstage = dblcnt = 0;
      );
    ); /////////////////////////
  
    
    willreorder > 0 ? (
      willreorder -= 1;
      reorder == 1 ? reorder_all();
    );
    willdrawpoints > 0 ? (
      willdrawpoints -= 1;
      drawpoints();
    );
  
    (dragtaken == 11 || drag > 0)  ? (
      reorder == 1 ? reorder_all();
      upsliders();
    //  upgraph += 1;
    );
    dralone3 = dragprev;
  );
);



dblstage > 0 && cap_mode > 0 ? noadd = 1;

listchoose > 0 ? (
  noadd = 1;
  dragtaken = listchoose;
);



//dbltgt > 0 ? dragaa += 1;
dblclkshft == 0 ? (
  dblclk == 18 ?  (
    slider64 = 15;
    slider_automate(slider64);
  );
  
  
  (dblclk > 0 && dblclk <= maxpoints) ? (
    multiedit > 0 ? (
      z = 1;
      loop(points,
        multiselect[z] > 0 ? (
          (bufbyp[z] += 1) > 1 ? (
            bufbyp[z] = 0;
            soloid == z ? soloid = bufdynsol[z] = 0;
          );
          eqini_one(z);
        );
        z += 1;
      );
      multisameb = 1;
    ):(
//      bufg[dragprev] = 0;
      (bufbyp[dragprev] += 1) > 1 ? (
        bufbyp[dragprev] = 0;
        soloid == dblclk ? soloid = bufdynsol[dblclk] = 0;
      );
      eqini_one(dragprev);
      upgraph += 1;
      
    );
    willdrawpoints += 1;
    update += 1;
  //  mouse_cap == 0 ? dblpointstage = dblpointcnt = showf = 0;
    showbox == 1 && dragprev > 0 && sleep == 0 ? drawbox();  
  ) :
  
  dblclk >= 21 && dblclk <= 29 ? (
    dblclk == 21 ? slider51 = 3 : // FFT Resolution
    dblclk == 22 ? slider55 = 500 : // Integrate/Averaging time
    dblclk == 24 ? slider42 = 0 : // Volume
    dblclk == 25 ? slider48 = 0 : // Volume link scale
    dblclk == 28 ? slider47 = .5 : // Peak decay
    dblclk == 29 ? (
      willdrawpoints += 1;
      slider41 = .75; // Auto Volume
    );
    slider_automate(slider(dblclk));
    upbufs();
    upauto();
    topbarok = 0;
    mouse_y < topbar.h ? willbarmenu = -1;
  ) :
  
  
  dblclk > 101 ? (

    dblclk == 104 ? (
      multiedit > 0 ? (
        dn = 1;
        loop(points,
          bufdynena[dn] == 1 ? (
            bufdynatt[dn] = .2;
          );
          dn += 1;
        );
      ):(
        bufdynatt[dragprev] = .2;
      );
    ) :
  
    dblclk == 105 ? (
      multiedit > 0 ? (
        dn = 1;
        loop(points,
          bufdynena[dn] == 1 ? (
            bufdynrel[dn] = .4;
          );
          dn += 1;
        );
      ):(
        bufdynrel[dragprev] = .4;
      );
    ) :
  
    dblclk == 106 ? (
      multiedit > 0 ? (
        dn = 1;
        loop(points,
          bufdynena[dn] == 1 ? (
            bufdynthr[dn] = 1;
          );
          dn += 1;
        );
      ):(
        bufdynthr[dragprev] = 1;
      );
    );
  );
  
  
  // ADD POINT
  dblclk == 91 && mouse_capold == 1 && noadd == 0 ? (
    dradd += 1;
    mouoffx = 0;
  
    gmaster == 2 ? (
      addpoint(0,1,0,1);
      ownpoints += 1;
    ):(
      addpoint(0,1,1,1);
      reorder == 1 ? reorder_all();
    );
//    showf = 0;
  );
);




(dragtaken > 10 && dragtaken < 21 && listfloat == 0) ? drawbox();

dragtaken == 100 ? (
//  willdrawbox = 1;
  bufshape[dragprev] != 0 && bufshape[dragprev] != 5 ? (
    mouse_cap > mouse_capold && mouse_capold == 0 && showdyn == 1 ? (
      showdyn = 0;
      bufdynthr[dragprev] == 1 ? bufdynena[dragprev] = 0;
      upgraph += 1;
      
      dyns = 0;
      dh = 1;
      loop(points,
        bufdynena[dh] > 0 ? dyns = 1;
        dh += 1;
      );
    ):(
      showdyn = 1;
      bufdynena[dragprev] = 1;
      compini(bufdynthr[dragprev],bufdynatt[dragprev],bufdynrel[dragprev],dragprev);
      drawdyn();
      dyns = 1;
    );
    drawbox();
  //    willdrawdyn = 1;
  );
//  drag = dragtaken = -1;
  showdyn == 1 ? drag = dragtaken = 106 : drag = dragtaken = -1;
);
dragtaken == 101 ? (
  bufshape[dragprev] != 0 && bufshape[dragprev] != 5 ? (
    
    multiedit > 0 ? (
  
      cbw = 1;
      loop(points,
        multiselect[cbw] > 0 ? (
          (bufdynena[cbw] += 1) > 1 ? (
            soloid == cbw ? soloid = 0;
            bufdynena[cbw] = bufdynsol[cbw] = 0 ;
            cbw == dragprev ? showdyn = 0;
          );
        );
        cbw += 1;
      );
  /*
      cbw = 1;
      loop(points,
        multiselect[cbw] > 0 ? bufdynena[cbw] = bufdynena[dragprev] ;
        cbw += 1;
      );
  */
    ):(
      
      (bufdynena[dragprev] += 1) > 1 ? (
        soloid == dragprev ? soloid = 0;
        bufdynena[dragprev] = bufdynsol[dragprev] = showdyn = 0 ;
      ):(
        showdyn = 1;
      );
      
    );
  
    upgraph();
    drawbox();
    drawdyn();
  );
//  drag = dragtaken = -1;
  
  dyns = 0;
  dh = 1;
  loop(points,
    bufdynena[dh] > 0 ? dyns = 1;
    dh += 1;
  );
//  dyns > 0 ? showdyn = 1;
  showdyn == 1 ? drag = dragtaken = 106 : drag = dragtaken = -1;
  
);

drag > 101 && drag <= 106 ? (
  dragdyn();
  drawdyn();
);



//dragtaken > 0 && dragtaken < 100 ? showdyn = 0;
showbox == 0 ? (
  showdyn == 1 ? upgraph += 1;
  showdyn = 0;
);


(dragtaken > 0 && dragtaken <= 17  && listfloat == 0) ||
(dragprev > 0 && dragprev < 9) ? (
  showbox = 1;
);
multis == 0 || dragprev == 0 ? showbox = 0;







//noob == 0 && resetall == 0 ? setzoom();
//noob == 0 ? setzoom();

willsetzoom > 0 ? (
  willsetzoom = 0;
  setzoom(0);
);

//dragtaken == 21 ? willsetzoom = 1;





slider55 > 1000 && slider55 < 5000 ? (
  s5timer1 > 60 ? (
    slider55 = floor(slider55/100)*100;
    slider_automate(slider55);
    s5timer1 = 0;
  ) : (
    s5timer1 += 1;
  );
);

slider55 > 5000 ? (
  s5timer5 > 60 ? (
    slider55 = floor(slider55/1000)*1000;
    slider_automate(slider55);
    s5timer5 = 0;
  ) : (
    s5timer5 += 1;
  );
);
///////


















// DB SCALE ZOOM
//dragtaken == 17 || dragtaken == 0 && (mouse_x < (dbw) ) && (mouse_cap > 0) && (oldrag == 0) ? (cap_mode = 601);
//mouse_cap > 0 && ((cap_mode == 601) || (cap_mode == 60) || (cap_mode == 61)) ? (






dragtaken == 19 && noanal == 0 ? (
  oldrag == 0 ? (
    oldrag = 1;
  //  cap_mode = 60 ;
//    x=y=0;
    w=dbw;
    h=gfx_h;
    cap_last_x = mouse_x;
    cap_last_y = mouse_y;
    moustartx = mouse_x;
    moustarty = mouse_y;
    roofstart = slider60;
    floorstart = slider52;
    floor_start = floordb_;
    zoomstart = slider62;
    liftstart = liftdbpx;
    oldrag = 1;
    
  );
  setzoom(1);
  (mouse_cap & 8) || slider56 == 1 ? (   // Meaning moushft == 1 ? 
    slider64 = gainmax = floordb_/1.92;
    slider_automate(slider64);
    scaleg = gfx_h*.5 / gainmax;
  );
  
);


dblclk == 15 ? (
  multiedit == 1 && moualt == 0 ? (
    z = 1;
    loop(points,
      multiselect[z] > 0 ? (  
        bufl[z] = 0;
      );
      z += 1;
    );
  ):(
    bufl[dragprev] = 0;
  );
  eqini_one(dragprev);
  upsliders();
  drawpoints();
);

dblclk == 18 || dblclk == 42 ? (
  slider64 = gainmax = 15;
  slider_automate(slider64);
  scaleg = gfx_h*0.5 /gainmax;
//  upgraph += 1;
);

(dblclk == 60 || dblclk == 19) && noanal == 0 ? (
  
  slider52 = 108;
  floordb_  = (slider52/10)^2;
  slider60 = liftdb = -10.5;
  db2px = slider60/ ((slider60/gfx_h) * floordb_) ;
  liftdbpx = slider60 * db2px;
  liftdb = liftdbpx / db2px;
//  liftdbpx = -65.535;
  
  slider_automate(slider52);
  slider_automate(slider60);


//    setzoom();
  update = 1;
//    upgraph = 2;
  old_w = 0;
);
 


//nozerof();















// DRAWINGS

// DRAW EQ DRAW GRAPH EQ GRAPH DRAW EQ CURVE DRAW CURVE
//å

resize > 0 || drag > 0 || autopoolold != autopool ? (
//  code_ver = 1;
  
  upgraph = 1;
  resize > 0 ? setzoom(0);
  topbarok = 0;
//  resize > 0 ? upgrid = 1;
);
autopoolold = autopool;

/*
//(mouse_cap > 0 && mouse_x == mouxold && mouse_y == mouyold) ? (
upgraph > 0 ? (
  noup = min(1,noupc);
  (noupc += 1) >= 1 ? noupc = 0;
):(
  noupc = 0;
);
*/




//noob == 0 || ( 0 && sleep == 0) ? (
noob == 0 || (upgraph > 0) || autovolold != autovoldb || dyns > 0 ? (
  upgraph();
  autovolold == autovoldb ? upgraph = 0;
  autovolold = autovoldb;
  
);


gfx_dest = -1;





mouse_cap > 0 ? update = 1;

cap_mode && cap_timer < 20 ? cap_timer += 1;

mouse_cap > 0 && mouse_x > dbw && mouse_x < gainx && mouse_y > dbw && bara <= 0 
&& dragtaken == 0 && cap_mode == 0 && barmenu == 0 ? dragtaken = 91;

points == 0 && mouse_cap == 17 && dragtaken == 91 && mouse_capold == 0 ? rstpk = 1;


  eqx.mou = mouse_x;
  
  
  
  
  
  
  
  
  
  
  



// HORIZONTAL GRIDLINES:
upgrid > 0 || noob <= 2 || (dragtaken == 17) || old_w != gfx_wlim || old_h!=gfx_h ? (
//noob==0?(

  upgrid > 0 ? upgrid -= 1;
  upgrid2 = 1;
  gfx_setimgdim(3,-1,-1);   gfx_setimgdim(3,gfx_wlim,gfx_h); 
  gfx_dest = 3; gfx_a = 1;
  gfx_setfont(12);

  sc=(gfx_h-20)*20/(floordb_ * log(10));
  
  gfx_r=gfx_g=gfx_b=0.6;
  gfx_a=0.4;         // mrelwood: Roof horizontal line
  gv=16;
  cnt=100;
  gfx_y =min(-liftdbpx,a)-gfx_texth;
  
  
  
  // VERTICAL GRID + DB SCALE / ANALYZER RULER
  
  yold = gfx_y = min(0,-liftdbpx)-gfx_texth - 24*db2px;
  wrote = 0; 
  an = 4;
  zerolinea = 0;
  
  noanal == 0 ? (
    
    while(
    
      yy =20-log(gv)*sc-14 - liftdbpx ;
      y2y =20-log(gv*.707)*sc-14 - liftdbpx ;

      yy > yold +5*gfx_ext_retina ? (
      
        gfx_a = .55; // Regular horizontal line
  
        (an += 1) >= 4 ? ( // -24, -48 etc
          gfx_a = .85;
          zerolinea == 1 ? gfx_a = 1;
          zerolinea += 1;
          an = 0;
        );
  
        gv == 1 ? (
          gfx_a = 1;
          gfx_line(dbw, yy -1,gfx_wlim, yy -1,0);
        );
        
        
        gfx_line(dbw, yy ,gfx_wlim, yy ,0);
        bottom_line = yold = yy ;
      );
      
      ( yy > (gfx_y + gfx_texth/2/2)) || (gv == 1)  ? (
    
        zx1 = dbw * 0.14;
        zxz = dbw * 0.25;
        zx2 = -1;
        zx3 = -3;
        gfx_y = yy -2 - gfx_texth/2 ;
        
        gfx_set(0.8,1,1,1);
        
        gvdb = floor( log10(gv)*19.94 +.5);
    
//        (gvdb & 2) ? gfx_a *= max(0, min(1, 2 - (gainmax/(gfx_h/ret/7)) )) ;
      
/*
        liftdbpx < 0 ? (
          gfx_x = zx1;
          n = 1;
          loop(2,
            ( (gvdb/(12*n)) == 1 ) ? (
              gfx_drawstr(" ");
              gfx_drawnumber(gvdb ,0);
              wrote += 1;
              gfx_y +=gfx_texth +1;
            );
            n += 1;
          );
        ):(
          wrote = 2;
        );
        gvdb == 0 ? (
          gfx_x = zxz;
          gfx_drawstr(" ");
          gfx_drawnumber(gvdb ,0);
          gfx_y +=gfx_texth +1;
        ):(
          gvdb < 0 ? (
            gvdb < -100 ? gfx_x = zx3 : gfx_x = zx2;
  
            n = 1;
            loop(9*wrote,
              ( (gvdb/( 24/wrote *n)) == -1 ) && ( yy > (gfx_y + gfx_texth/2)) ? (
                gv >= 1 ? gfx_drawstr(" ");
                gfx_drawnumber(gvdb ,0);
                gfx_y +=gfx_texth;
              );
              n += 1;
            );
          );
        );
*/
        topdb = -liftdb;
        botdb = -floordb_ + topdb;
        randb = topdb - botdb;

        (gvdb & 2) ? (
      //    gainmax > (gfx_h/ret/9) ? gfx_a = 0.5 : gfx_a = 1;
          gfx_a *= max(0, 1.9 - (randb/(gfx_h/ret/(3*spacing))) ) ;
        ):(
          gfx_a = 1;
        );
        
        gvdb < topdb && gvdb > botdb ? (
          gvdb < 0 && gvdb < -100 ? (
            gfx_x = zx3;
            gfx_setfont(13);
          ):(
            gfx_x = zx2;
          );
//          (gvdb & 3) ? (
          gvdb == 0 ? (
            gfx_setfont(1);
            gfx_x += gfx_texth*.4;
          ):(
            gvdb > 0 ? gfx_x += gfx_texth*.2;
            gvdb > -100 ? gfx_setfont(12);
          );
          gfx_drawnumber(gvdb ,0);
//            gfx_y +=gfx_texth +1;
          gvdb < 0 && gvdb < -100 ? gfx_x = zx3 : gfx_x = zx2;
          gfx_y += ( y2y - yy );
          gfx_a = max(0, 1.2 - (randb/(gfx_h/ret/(3.5*spacing))) );
          gfx_drawnumber(gvdb-3 ,0);
          
//          );
        );


      );
      gr = 0.6;
      gfx_set(gr,gr,gr,0.7 - slider52/1000 - (gfx_y/gfx_h)^1.5 *0.4);
    
      gfx_y > gfx_h-gfx_texth-20 ? (gfx_a=0.0);
    
      gv*=0.5;
    
      gfx_y<gfx_h && cnt-=1 > 0;
    );
    
    // Treble dimmer for horiz gridlines:
//    gfx_gradrect(dbw,0,gfx_wlim,gfx_h , 0,0,0,0 , 0,0,0,1/(gfx_wlim));
    points > 0 ? gfx_gradrect(gfx_wlim*.2,0,gfx_wlim*.9,gfx_h , 0,0,0,0 , 0,0,0,1/(gfx_wlim*.7));
    
    
  
  );
);

// BLIT HORIZONTAL GRID
//helpa > 0 ? rulera = helpa : rulera = 1-noanal;
rulera = max(helpa,1-noanal);
//helpa > 0 || noanal == 0 ? (
rulera > 0 ? (
  gfx_dest = -1;
  gfx_set(1,1,1,rulera,0);
  gfx_x = gfx_y = 0;
  gfx_blit(3,1,0);
);  










//noanal = 1;

// ANALYZER

// Peak reset also @ Marquee
//points == 0 && mouse_cap == 17 && drag == 91 && mouse_capold == 0 ? rstpk = 1;



sleep == 0 && noanal == 0 ? (
  gfx_dest = -1;

  p2 = histsize[recpos];
  p3 = recpos/50000;

//  dragtaken == 91 && mouse_capold == 0 && mouse_cap > 1 ? rstpk = 1 : rstpk = 0;
//  dragtaken == 91 && showf == 1 && mouse_cap > 1 ? rstpk = 1 : rstpk = 0;
//  dragtaken == 91 && dragmrq == 0 && mouse_cap > 1 ? rstpk = 1 : rstpk = 0;
/*
  dragtaken == 91 && mouse_cap > 1 ? (
    mrqw > 0 || mrqh > 0 || removing > 0 ? rstpkc = rstpk = 0;
    (rstpkc += 1) > 5 ? rstpk = 1;
  ):(
    rstpkc = rstpk = 0;
  );
  mouse_capold == 17 && dragtakenold == 91 && mouse_cap == 0 && removing == 0 ? (
    rstpk = 1;
  );
*/    
  
  update > 0 ? (
    update = 0;
    
    integrate_sc = 1;
    slider55 > 0 ? (
      integrate_now = time_precise();
      integrate_en ? (
        integrate_sc -= exp(-5 * 1000.0 * (integrate_now - integrate_lastt) / slider55);
      ) : (
        // force overwrite of buffer
        integrate_en = 1;
      );
      integrate_lastt = integrate_now;
    ) : (
      integrate_en = 0;
    );
  
/*
    roof != (slider58|0) ? (
      roof=slider58|0;
    );
*/
  
    fftidx != (slider51|0) ? (
      fftidx=slider51|0;
      fftsize=2^(min(max((fftidx+6),0),11)+4);
      integrate_sc=1;
    );
  
    windowsize != fftsize || windowtype != (slider54|0) ? (
      windowtype=slider54|0; 
      windowsize=fftsize;
      dwindowpos = $pi*2/fftsize;
      i=pwr=0;
      loop(fftsize*.5+1,
         windowpos=i*dwindowpos;
         pwr += (window[i] = (
           windowtype==1 ? 0.53836 - cos(windowpos)*0.46164 :
           windowtype==2 ? 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) :
           windowtype==3 ? 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) :
            1.0));
         i+=1;
      );
      pwr=.5/(pwr*2-window[i-1]);
      loop(fftsize*.5+1,window[i-=1]*=pwr);
      integrate_sc=1;
    );
  
  
    buf1=recpos-fftsize;
    buf1<0 ? buf1+=histsize;
    buf2=window;
    buf3=fftworkspace;
    loop(fftsize*.5 + 1,
      buf3[] = buf1[]*buf2[];
      buf3+=1;
  
      buf2+=1;
      (buf1+=1) >= histsize ? buf1 -= histsize;
    );
    buf2-=1;
    
    loop(fftsize*.5 - 1,
      buf3[] = buf1[]*(buf2-=1)[];
      buf3+=1;
      (buf1+=1) >= histsize ? buf1 -= histsize;
    );
  
  
    fft_real(fftworkspace,fftsize);
    fft_permute(fftworkspace,fftsize/2);
    fftworkspace[1]=0;
  
    ascale=gfx_h/$pi*0.25;
    xscale=800/(fftsize-4);
  
    
    buf3=fftworkspace; 
    buf2=integrate_buf;
  
        
    lx=0;
    i=0;
    fill_slmin=gfx_h;
    fill_slast=0;
    octavegain = floor(slope*10+0.5) * ((log(10)*2.0/10.0)/(log(2)*20.0));
    octavegainoffs = log(1 + octcenter * fftsize / srate);
    
    gyold = gfx_h;
  
    loop(fftsize*0.5,   
      ty = log(max(sqr(buf3[0])+sqr(buf3[1]),(10^(-500/20*2))) );
          
      octavegain > 0 ? ty += (log(i+1) - octavegainoffs)*octavegain;
      buf3+=2;
  
      
      // GRAPH DECAY and GRAPH SLOWNESS
      integrate_en >= 0 ? (
        islo = buf2-integrate_buf;
  //      buf_pk = buf2;
  //      ty = buf2[] += integrate_sc * (ty - buf2[]);
        ty = buf2[] += integrate_sc * (ty - buf2[]);
  
  
        buf2[] > buf_slo[islo] || buf_slo[islo] > 100 ? (
          buf_slo[islo] = buf_pk[islo] = buf2[];
        ):(
          rstpk == 1 ? (
            rstpk = 0;
            fpspd = 30/fps *1;
            memset(buf_slo,-100,fftsize/2);
            decay = max(0,buf_pk[islo]-buf_slo[islo]) ;// * .1 /(1+ slider55*.001);
            buf_slo[islo] -= (buf_pk[islo]- (buf_slo[islo]-(buf_slo[islo]-buf2[])*.5));
            
          ):(
            fpspd = 30/fps *1;
            slider47 < 1 ? fpspd *= slider47 / (1+ slider55*.0003) ;
            decay = fpspd*0 + max(0,buf_pk[islo]-buf_slo[islo]) ;// * .1 /(1+ slider55*.001);
            buf_slo[islo] -= (buf_pk[islo]- (buf_slo[islo]-(buf_slo[islo]-buf2[])*slider47*slider47*.5)) * slider47;
          );
        );
        buf2+=1;
      );
      
      ty = ty* -0.5*sc + 20;
      ty_slo = buf_slo[islo]* -0.5*sc + 20;
  //    ty_slo = ty;
      lx == 0 ? avgy = min(gfx_h*.75 , ty_slo*.5-liftdbpx );
  
  
  // mrelwood: Compensate graph X position:
      tx = log(1.0+i*xscale)*wsc    - 0.2*wsc;
      gfx_set(1,1,1,1,0);
      
  
    // ANALYZER FILL COLOURS:
       
      i ?
      ( 
          modeana < 1 ? gfx_set(1,1,1,a=0.04) :
          modeana < 2 ? gfx_set(.4,1,.4,a=0.05) :
          modeana < 3 ? gfx_set(1,1,0,a=0.03) :
          modeana < 4 ? gfx_set(.45,.65,1,a=0.05) :
          modeana < 5 ? gfx_set(1,.35,.3,a=0.1;) ;
        
        1/*fill?*/ ? (
          tx0=tx|0;
          lx0=lx|0;
          tx0>lx0? (
  
    // ANALYZER FILL BRIGHTNESS:
    
      // Dimmer on the right:
            // Analyzer after grid:
            gfx_a = a + .12 -(gfx_x/gfx_wlim)* (fftidx/200 +.0)*0;
  //          gfx_a = 1;
            // Analyzer with grid + dimminggradrect:
  //          gfx_a = a*2.5 - (lx0/gfx_wlim)* (fftidx/50 +.3);
  
            ly < (gfx_h+liftdbpx) || ty < (gfx_h+liftdbpx) ? gfx_triangle( lx0,max(gfx_h,ly), lx0,ly-liftdbpx, tx0-1,ty-liftdbpx, tx0-1,max(gfx_h,ty) );
  
          ) : (
            tx0 > fill_slast ? (
              fill_slast < gfx_h ? gfx_line(fill_slast,gfx_h,fill_slast,fill_slmin-liftdbpx);
              fill_slmin=gfx_h;
            ) : (
              fill_slmin=min(fill_slmin,ty);
            );
          );
          fill_slast=tx0;        
        );  
  
        gfx_x=lx; gfx_y=ly-liftdbpx;
  
  
    // ANALYZER EDGE BRIGHTNESS:
        gyold2 = gyold;
        txwlim = tx/gfx_wlim;
        tmpff = (fftidx*.2) * (fftidx*.2);
  
        gfx_a = 1/(1+ (tmp= fftidx *.35)*tmp *.2);
        
      // Darker when old line close:
  //      gyold +=   (gfx_y-gyold) * min(1, 20 * (gfx_x-gxold)/(gfx_wlim/(fftidx+10))  );
        gfx_a /= 1+ (tmpxs= max(0, 6-(tx-gxold) )*.17)*tmpxs *.5 * (txwlim);
  
        // Brighter above average:
  //      gfx_a *= 1 + (gfx_x/gfx_wlim)^.5 * ((fftidx+1)/6) * ( abs(gyold-gfx_y)/(slider52 ) + slider52/100 -1);
        
  //      gfx_a += .01*  (avgy-min(ty_slold,ty_slo)+liftdbpx) * (randb*.01) ;// * (txwlim=tx/gfx_wlim)*(txwlim);
        gfx_a *= 1+ (1-(tmp=tmpff*.15))*
        (tmp=max(0,avgy-(ty_slold+ty_slo)*.5+liftdbpx)*.06)
         * (randb*.01) * (txwlim)*(txwlim);
         
         
        tmp < -100 ? (
          gfx_a /= 1+ ( -min(0,tmp)*.1) * (randb*.01) * (txwlim)*(txwlim);
          p=0;
        );
  
        
        // Dimmer on the right:   
  //      gfx_a = (gfx_wlim/ (2000) +2-(fftidx*0.18)) * (1- gfx_x*(.85+fftidx/18)  /gfx_wlim)  ;// / (; // 1K
        gfx_a /= 1 + (txwlim*txwlim) * tmpxs * (2+tmpff*8);
  //      gfx_a = 1;
  
        gfx_a > 1 ? gfx_a = 1;
        gfx_a < 0.01 ? gfx_a = 0.01;
  
        
        gxold = gfx_x;
  //      gfx_lineto(tx,ty-liftdbpx,1) ;
        (newy=ty_slo-liftdbpx) < gfx_h ? sleepc = 0;
        gfx_line(gxold,ty_slold-liftdbpx,tx,newy);
        avgy += sign(ty_slo-liftdbpx-avgy) * (tx-gxold) * (1+ tx/gfx_wlim);
        ty_slold = ty_slo;
        
  /*
        //Helper avg graph:
        gfx_set(0,1,0,1);
        gfx_line(gxold,avgyold,tx,avgy);
        avgyold = avgy;
  */
  
        // TMP:
  //      gfx_set(.8,.6,0,.8);
      );
  
      ty<gfx_h ? update=1;
  
      lx=tx; ly=ty;
      i+=1;
    );
    
  );
);
/*
gfx_dest = -1;
gfx_set(1,1,1,1,0);
xy(0,0);
gfx_blit(9,1,0);
*/

    // Treble dimmer over horiz grid and analyzer:
//    gfx_gradrect(dbw,0,gfx_wlim,gfx_h , 0,0,0,0 , 0,0,0,.2/gfx_wlim);
//    gfx_gradrect(gfx_wlim*.25,0,gfx_wlim*.75,gfx_h , 0,0,0,0 , 0,0,0,.2/gfx_wlim);

// å

cola = .5;
  gfx_setfont(12);

h = gfx_h-(yc=gfx_h-(gfx_texth));
color == 1 ? gfx_gradrect(dbw,yc,gfx_wlim,h , .33,.18,.0,cola , .15/gfx_wlim,.05/gfx_wlim) :
color == 2 ? gfx_gradrect(dbw,yc,gfx_wlim,h , .4,.05,.05,cola , .15/gfx_wlim) :
color == 3 ? gfx_gradrect(dbw,yc,gfx_wlim,h , .5,.14,.0,cola , .2/gfx_wlim,.1/gfx_wlim) :
color == 4 ? gfx_gradrect(dbw,yc,gfx_wlim,h , .4,.25,.0,cola , .25/gfx_wlim,.25/gfx_wlim) :
color == 5 ? gfx_gradrect(dbw,yc,gfx_wlim,h , .05,.25,.0,cola , 0,.15/gfx_wlim) :
color == 6 ? gfx_gradrect(dbw,yc,gfx_wlim,h , 0,.15,.4,cola , 0,0,.3/gfx_wlim) :
color == 7 ? gfx_gradrect(dbw,yc,gfx_wlim,h , .18,0,.35,cola , .3/gfx_wlim,0,.2/gfx_wlim) :
color == 8 ? (
  gr = .2;
  grx = .05;
  gry = .1;
  gfx_gradrect(dbw,yc,gfx_wlim,h , gr,gr,gr,cola ,
   grx/gfx_wlim,grx/gfx_wlim,grx/gfx_wlim,.5/gfx_wlim ,
   gry/h,gry/h,gry/h,.5/h);
) :
color == 9 ? gfx_gradrect(dbw,yc,gfx_wlim,h , 0,.25,.25,cola , 0,.2/gfx_wlim,.2/gfx_wlim) :
color == 0 || color == 10 ? (
  gfx_set(0,0,0,cola);
  gfx_rect(dbw,yc,gfx_w,h);
);



upgrid2 > 0 ? ( // Vertical frequency grid
  upgrid2 = 0;
  gfx_setimgdim(7,-1,-1);   gfx_setimgdim(7,gfx_wlim,gfx_h); 
  gfx_dest = 7; gfx_a = 1;
  
  
  gfx_a = 0;
  gfx_x = 0;
  
//  wsc=gfx_wlim/log(1+480) +gfx_wlim*0.01;
  
  // draw vert grid
  f=20;
  gfx_x+=0;
  lx=gfx_x;
  
  gfx_set(1,1,1,0.8,0);
  gfx_setfont(1);
  
  
  while(
    
    // mrelwood: brighter frequency lines:
    
    gfx_a=0.4;
    
    f < 100 ? gfx_a *= 0.7;
    f > 500 ? ( f < 1000 ? gfx_a *= 0.85 );
    f > 5000 ? ( f < 10000 ? gfx_a *= 0.7 );
    
    f==500 || f==5000 || f==20000 ? gfx_a *= 1.5 ;
    f==50 ? gfx_a = 0.7 ;
    f==100 || f==1000 || f==10000 ? gfx_a = 0.8 ;
  
  
  
  // mrelwood: offset frequency scale, pixels
  //  tx = log(1.0+(f/srate*2.0)*400)*wsc; (-30)
    tx = (log(1.0+(f/old_srate*2.0)*400)*wsc)  - wsc*0.2;
  
  
  // mrelwood: Only show certain values on x-scale:
  
       
    wsc < 56 ? (
      dotext = tx > gfx_x && f!=90 && f!=20000 &&
        (f==100||f==1000||f==10000)
  
    ) : (
  
    wsc < 90 ? (
      dotext = tx > gfx_x && f!=15000 &&
        (f==50||f==100||f==1000||f==5000||f==10000||f==20000)
  
    ) : (
      dotext = tx > gfx_x && f!=40 && f!=4000 &&
        (f==50||f==100||f==500||f==1000||f==5000||f==10000||f==15000||f==20000)
    );
  );     

  tx > lx && f < 20000 ? ( lx=tx+4; gfx_line(tx,5,tx,gfx_h - ( dotext && (f<=10000) ? 8 :  gfx_texth-2 ) ,0); );
  dotext ? (
    gfx_x=tx +3;
    gfx_y = gfx_h-gfx_texth;
    uuu=gfx_y ;


// mrelwood: Frequency numbers brightness:
    gfx_a=0.7;
      f==20 || f==50 || f==100 || f==500 ? gfx_printf("%d",f*1);
      f==1000 ? gfx_printf("%d kHz",f*.001);
      f==5000 || f==10000 ? gfx_printf("%dk",f*.001);


      f==15000 || f==20000 ? (
        overkoff = gfx_texth*0.3;
        gfx_x -= overkoff;
        gfx_printf("%d",f*.001);
        gfx_x += overkoff;
      );

      gfx_a=0.4;
        
    );
    f += (f<100?10:f<1000?100:f<10000?1000:5000);
    f < old_srate*0.5;
  );


  gfx_dest = -1;

);


// BLIT VERTICAL GRID
gfx_set(1,1,1,1,0);
gfx_x = gfx_y = 0;
gfx_blit(7,1,0);








// EQ DB RULER
points > 0 || helpa > 0 ? (
//  helpa > 0 ? dba = helpa : dba = 1;
  points == 0 ? dba =  helpa : dba = 1;
  
  //gainmax = 18;
  gfx_set(.15,.4,0,.5*dba,0);
  gfx_setfont(12);
//  gfx_measurestr("-22",gainw,0);
  //gainw += 2*ret;
  gfx_rect(gainx , 0 , gainw,gfx_h);
  gfx_set(.6,.7,.4,dba,0);
  
  gfx_rect(gainx , 0 , gainw,gfx_h, 0);
  eg = cnt = 0;
  while((eg-abs(slider42)) < gainmax)(
    gfx_x = x = gainx + gainw/(eg > 10 ? 10 : 3.5);
    gfx_y = zerog - ((eg-slider42)/gainmax) * gfx_h/2 -gfx_texth/2;
    
  //  gainmax > 27 && (eg & 1) ? gfx_a = 0 : gfx_a = 1;
    
    (eg & 1) ? (
  //    gainmax > (gfx_h/ret/9) ? gfx_a = 0.5 : gfx_a = 1;
      gfx_a *= max(0, 1 - (gainmax/(gfx_h/ret/(7*spacing))) );
    ):(
      gfx_a = dba;
    );
    (eg & 2) ? gfx_a *= max(0, min(1, 2 - (gainmax/(gfx_h/ret/(7*spacing))) )) ;
    
    eg == 0 ? gfx_setfont(1) : gfx_setfont(12);
    
    gfx_drawnumber(eg,0);
    noanal == 0 ? dblx = gfx_wlim*.4 : dblx = 0;
  //  gfx_line(gfx_wlim/2,gfx_y+gfx_texth/2, gainx,gfx_y+gfx_texth/2);
    eg > 0 ? (
      cnt == 0 ? (
        noanal == 0 ? gfx_gradrect(dblx,gfx_y+gfx_texth/2, w=(gainx-dblx),2 , 0,0,0,0, 0,.5/w,0,.7*dba/w) :
        gfx_gradrect(dblx,gfx_y+gfx_texth/2, w=(gainx-dblx),2 , 0,.3,0,.7*dba, 0,.2/w,0,0);
      );

      gfx_x = x - ret * (eg < 10 ? 3 : 3);
      gfx_y = zerog + ((eg+slider42)/gainmax) * gfx_h/2 -gfx_texth/2;
      gfx_drawnumber(-eg,0);
    );
    cnt == 0 ? (
      eg == 0 ? (
        egz = ret;
      ):(
        egz = 0;
      );
      cnt = 1;
      noanal == 0 ? gfx_gradrect(dblx,gfx_y+gfx_texth/2 -egz, w=(gainx-dblx),2+egz , 0,.1*egz,0,0, 0,.5/w,0,.7*dba/w) :
      gfx_gradrect(dblx,gfx_y+gfx_texth/2 -egz, w=(gainx-dblx),2+egz , 0,.3,0,.7*dba, 0,.2/w,0,0);
    ):(
      cnt = 0;
    );
    eg += 3;
  );
);

dragtaken == 18 && dblclk == 0 && cap_mode == 0 ? (
  oldrag == 0 ? (
    oldrag = 1;
    dragtaken = drag = 18;
    cap_drag = 1;
    moustartx = mouse_x;
    moustarty = mouse_y;
    gainmaxstart = slider64;
  );

  slider64 = gainmax = gainmaxstart - ((mou = (mouse_x-moustartx)+(moustarty-mouse_y))*precise)/(gfx_h/2) * (gainmaxstart+gainmax);
  slider64 > grange ? slider64 = gainmax = grange;
  slider64 < 7.1 ? slider64 = gainmax = 7.1;
  slider_automate(slider64);
  
  
  scaleg = gfx_h*.5 / gainmax;
  
/*
  (mouse_cap & 8) ? (
    mouse_cap != last_mouse_cap ? floorstart = slider52;
    slider52 = floorstart - (floordbup = (((mouse_x-moustartx)+(moustarty-mouse_y))*precise/5)  );
    upgrid = 1;
  );    
*/
);



gr = 0.15;
grb=0.35;
gfx_set(gr*0.5,gr,grb,.5*rulera);
gfx_rect(0,0,dbw,gfx_h);
gfx_set(.5,.6,.5,rulera);
gfx_line(dbw,0,dbw,gfx_h);








lockzoom == 1 ? (butr=butg=butb=0.3):(butr=butg=butb=0);




// EQ ZERO EQ LINE
points > 0 ? (
  zli = -2;
  gr = .65;
  loop(4*ret,
    gfx_set(gr,gr,gr,1,0);
    gfx_line(0,ytmp= (zerog +zli +slider42/slider64 *gfx_h/2) , gfx_wlim,ytmp);
    gr -= .2/ret;
  //  gr /= 1+1/ret;
    zli += 1;
  );
);
























// Color button
gfx_set(0,0,0,1,0);
gfx_setfont(12);
gfx_rect(0,coly=gfx_h-(ch=gfx_texth+2)-4,dbw-0,ch+4 ,1);
gr = .8;
gfx_set(gr,gr,gr,1);
gfx_rect(3,gfx_h-(ch)-1,dbw-5,ch-2 ,0);

gfx_set(.6,.1,.1);
gfx_rect(5,gfx_h-(ch)+1,dbw*.5-5,ch*.5-3 ,1);
gfx_set(.1,.5,.1,1);
gfx_rect(dbw*.5+1,gfx_h-(ch)+1,dbw*.5-5,ch*.5-3 ,1);
gfx_set(.1,.2,.7,1);
gfx_rect(5,gfx_h-(ch*.5)-1,dbw*.5-5,ch*.5-3 ,1);
gfx_set(.55,.45,.1);
gfx_rect(dbw*.5+1,gfx_h-(ch*.5)-1,dbw*.5-5,ch*.5-3 ,1);

mouse_cap > 0 && mouse_capold == 0 && mouse_x < dbw && mouse_y > coly && help == 0 ?
 (choosecolor += 1) > 1 ? choosecolor = 0;






// BLIT BOX

gfx_dest = -1;
gfx_set(1,1,1,1,0);
dragprev > points ? dragprev = showbox = 0;
resize > 0 ? drawbox();
help > 0 ? boxa = helpa : boxa = 1;

gfx_a = 1;
gfx_set(1,1,1,boxa,0);
showbox == 1 || help > 0 ? gfx_blit(5,1,0 , boxx1-1,boxytop-1,boxw+2,boxh+2 , 
  boxx1-1,boxytop-1,boxw+2,boxh+2);
xy(dynx,dyny);

showdyn == 1 ? (
  gfx_blit(dynid,1,0);
  gfx_set(0,.8,.5,1);
  bufg[dragprev] != 0 ? (
    gfx_rect( floor(dynx + compg[dragprev] * dynw) , dyny+dynh , floor((1-compg[dragprev]) * dynw) , 2*ret ,1);
  );
);




// Doubleclick Frequency & Doubleclick Width

(dblclk == 11 && dblclkshft == 1) ? dblclk = 13;  
dblclk >= 11 && dblclk <= 13 ? (

//    dragstop = 20;
  dblclk == 11 ? (
    multiedit > 0 ? (
      spread = (gfx_wlim)/(multis+1);
      z = 1;
      zz = 1;
      loop(points,
        multiselect[z] > 0 ? (
          xpos[z] = gfx_wlim*.0 + zz*spread;
//          buff[z] = ((exp(((  xpos[z] )-3+gfx_wlim/27.5)/wscmou))-1)/800*old_srate+1;
          buff[z] = ((exp(((xpos[z] )-0*3+gfx_wlim/28.275)/wscmou))-1)/800*old_srate+1*0;
          note(buff[z]);
          
          zz += 1;
        );
        z += 1;
      );
      upsliders();
    ):(
      buff[dragprev] = 1000;
      note(buff[dragprev]);
      
    );
    reorder == 1 ? reorder_all();
  );

  dblclk == 12 ? (
    multiedit > 0 ? (
      z = 1;
      loop(points,
        multiselect[z] > 0 ? (
//          bufg[z] = 0;
          bufg[z] = 0;
          eqini_one(z);
        );
        z += 1;
      );
      multisameg = 1;
    ):(
//      bufg[dragprev] = 0;
      bufg[dragprev] = 0;
      eqini_one(dragprev);
      upgraph += 1;
      
    );
    upsliders();
  );


  dblclk == 13 ? (
    multiedit > 0 ? (
      z = 1;
      loop(points,
        multiselect[z] > 0 ? (
          bufw[z] = 1;
          eqini_one(z);
        );
        z += 1;
      );
      multisamew = 1;
      upsliders();
    ):(
      bufw[dragprev] = 1;
      upsliders();
      eqini_one(dragprev);
    );
  );

  upgraph += 1;
  
  drawbox();
  
);

aadbldragtmp += dblclk;



gfx_dest = -1;







// Blit top bar
gfx_dest = -1;
xy(dbw+1,0);
gfx_set(1,1,1,1);
gfx_blit(8,1,0);



willupgraph > 0 ? (
  willupgraph = 0;
  upgraph();
);


// BLIT EQ CURVE
gfx_a = 1;
gfx_x = 0;
//autopoolpx != autopoolpxold ? upauto();
gfx_y = autopoolpx -gfx_h*.5;
points > 0 ? gfx_blit(2,1,0);

noob == 0 || old_w != gfx_wlim || old_h != gfx_h ?   drawpoints();

// BLIT POINTS
gfx_x = gfx_y = 0;
gfx_blit(6,1,0);

gfx_w > gfx_wlim ? (
  gfx_set(0,0,0,1,0);
  gfx_rect(gfx_wlim,0, gfx_w-gfx_wlim,gfx_h);
);


// TOP BAR
  



topbarok == 0 || willtopbar > 0 ? topbar(); //tmp

drag == 0 && dragtaken == 0 && (
(mouse_cap > 0 && mouse_capold == 0 && mouse_y < topbar.h && mouse_x > dbw && mouse_x < gfx_wlim - dbw) ||
(dragtaken >= 21 && dragtaken <= 29) ) ? (
  captopbar();
);

dragtaken > 0 ? (
  (dragtaken >= 21 && dragtaken <= 29) ? (
    barc >= 0 ? barc += 1;
    
    barmenu == 0 ? (
      barc > 15 ? (

        dragtaken == 24 ? (
          drag = 41;
          dragtaken = 29;
          barmenu = 24;
        ):(
          barmenu = dragtaken;
        );

        willbypass = -1;
        barc = -1;
      );
    ):(
      barc > 15 ? (
        barmenu = 0;
        barc = -1;
        willbypass = -1;
//        dragtaken = -1;
      );
    );
    
  ):(
    barmenu = 0;
  );
);
mouse_cap == 0 ? (
//  dragtakenold >= 21 && dragtakenold <= 29 && (dragtakenold != 27 || gmaster == 1) ? (
  dragtakenold >= 21 && dragtakenold <= 29 ? (
    
    mouse_y < topbar.h && barc > 0 ? (
      dragtakenold >= 21 && dragtakenold <= 23 ? (
        barmenu == 0 ? barmenu = dragtakenold :
        barmenu >= 21 && barmenu <= 23 ? barmenu = 0;
      ) :
      dragtakenold == 24 ? (
        barmenu == 0 ? (
          barmenu = dragtakenold ;
//          forcedrag = 41;
//          dragtaken = 29;
        ):(
          barmenu == 24 ? barmenu = 0;
        );
      ) :
      dragtakenold >= 25 && dragtakenold <= 26 ? (
        barmenu == 0 ? barmenu = dragtakenold : 
        barmenu >= 25 && barmenu <= 26 ? barmenu = 0;
      );
    );
    
    dragtakenold == 27 && barc != -1 ? willbypass = 1 :
//    barc != -1 ? (
    barc >= 7 ? (
      bara < .5 ? barmenu = dragtakenold : barmenu = 0;
    );
  );
);


barmenu > 0 || bara > 0 ? (
  baraspd = .1;
  barmenu > 0 ? (
    bara += baraspd;
    barold = barmenu;
  ):(
    bara -= baraspd;
  );
  bara < 0 ? (
    bara = barmenu = barold = 0;
  );
  bara > 1 ? bara = 1;
  
  barold > 0 ? (
    bary = topbar.h;
    dark = .1;
    dimitem = .3;
  
    
    barold <= 23 ? (
      dragtaken >= 24 && dragtaken <= 27 ? (barmenu = dragtaken; barc = -1;) ;
//      mouse_cap == 0 && mouse_capold > 0 && barc >= 0 && dragtakenold >= 21 && dragtakenold <= 23 ? barmenu = 0;
    
      topbarmenu(dbw+2*ret,max(520,topbar.wa+topbar.wb),5,6 ,.04,.05*(1+slider50),.05*(1+slider50*3) , 0,.05,.08 , "Analyzer");
      fftdrag.topbarmenuitem("FFT
Resolution","32K",5,"16K",4,"8K",3,"4K",2,"2K",1,"1K",0, 21,51);
      gfx_x = floor(gfx_x - 5*ret);
      avgdrag.topbarmenuitem("Time","10s",10000,"2s",2000,"1s",1000,"500ms",500,"100ms",100,"0ms",0, 22,55);
      gfx_x = floor(gfx_x + 2*ret);
      drag == 47 ? (
        sprintf(#sli47,"%d",slider47*100 +.5);
        #sli47 += "%";
        decaydrag.topbarmenuitem( #sli47 ,"100%",1,"50%",.5,"25%",.25,"12%",.12,"5%",.05,"Hold",0, 28,47);
      ):(
        decaydrag.topbarmenuitem("Pk Decay","100%",1,"50%",.5,"25%",.25,"12%",.12,"5%",.05,"Hold",0, 28,47);
      );
      gfx_x = ceil(gfx_x +1);
      chandrag.topbarmenuitem("Channel","     R",4,"L     ",3,"Side",2,"Mid",1,"Stereo",0,"",-99, 23,59);
      gfx_x = tmpx = ceil(gfx_x);
      anaena.topbarmenuitem("Analyzer","On",1,"Off",0,"",-99,"",-99,"",-99,"",-99, 32,50);
      xy(gfx_x-itemw , itemy + (5)*gfx_texth);
      
      linkrulers.topbarmenuitem("Link Zooms ","On",1,"Off",0,"",-99,"",-99,"",-99,"",-99, 33,56);

      
      
    ) :
    barold == 24 ? (
      dragtaken >= 21 && dragtaken <= 28 && dragtaken != 24 ? (barmenu = dragtaken; barc = -1;);
      
      gr = .2;
      gra = .05;
      topbarmenu(dbw+topbar.wa-topbar.wb*.25,topbar.wb*1.5,1,7 ,gr,gr,gr , gra,gra,gra , "Volume");
//      topbarmenuitem("Auto volume","100%",0,"75%",.25,"50%",.5,"25%",.75,"Off",1,"",-99, 29,41);
//      auto.topbarmenuitem("Auto volume","150%",1.5,"100%",1,"50%",.5,"Off",0,"",-99,"",-99, 29,58);
//      auto.topbarmenuitem("Auto volume","150%",1.5,"100%",1,"50%",.5,"Off",0,"",-99,"",-99, 29,41);
      
      slider41 <= 0 ? noauto = 1 : noauto = 0;
      dragtaken == 29 ? (
        sprintf(#sli41,"%.0f",slider41*100);
        #sli41 += "%";
        auto.topbarmenuitem( #sli41,"150%",1.5,"100%",1,"88%",.88,"75%",.75,"50%",.5,"Off",0, 29,41);
  //      (slider41 = (1-slider58) ) == 1 ? noauto = 1 : noauto = 0;
      ):(
        auto.topbarmenuitem( "Auto Vol","150%",1.5,"100%",1,"88%",.88,"75%",.75,"50%",.5,"Off",0, 29,41);
//        gfx_drawstr("Auto Vol",257,gfx_x,gfx_y);
      );

//      xy(auto.itemx,gfx_y+auto.itemh);
      gfx_setfont(13);
      xy(auto.itemx-gfx_texth*1.7,gfx_y+auto.itemh + gfx_texth*1.2);
      gfx_drawstr("(");
      gfx_drawnumber(  ceil(-autovoldb *10 )/10 +.00001,1);
      gfx_drawstr("dB)");
    ) : 
    barold > 24 ? (
      dragtaken >= 21 && dragtaken <= 24 ? (barmenu = dragtaken; barc = -1;);
      
      wlim_ = gfx_wlim-55*ret;
      gr = .08;
      gra = -.05;
      wtmp = max(180*ret , topbar.wc);
      link.topbarmenu(gfx_wlim-dbw*1.1-wtmp,wtmp,3,7 ,gr,gr*3,gr/2 , gra,gra,gra , "Link");
      scale.topbarmenuitem("Vol Link","100%",1,"50%",.5,"0%",0,"-50%",-.5,"-100%",-1,"",-99, 25,48);
      mode.topbarmenuitem("Mode","Slave",2,"Master",1,"Single",0,"",-99,"",-99,"",-99, 26,57);
      
      gfx_setfont(12);
      gr = .4;
      gfx_set(gr,gr,1,1);
      xy(gfx_x-itemw , itemy + 4.5*gfx_texth);
      colmaster == 10 ? (
        rst.topbarmenuitem("Make Single","Group",-98,"All",2,"",-99,"",-99,"",-99,"",-99, 31,58);
      ):(
        rst.topbarmenuitem("Make Single","Group",1,"All",2,"",-99,"",-99,"",-99,"",-99, 31,58);
      );      
      gfx_y = topbar.h +4*ret;
      

      gmaster == 1 ? byp.topbarmenuitem("Bypass","-",0,"This",1,"Slaves",2,"Both",3,"",-99,"",-99, 27,43)
      : byp.topbarmenuitem("Bypass","-",0,"This",1,"Slaves",-98,"Both",-98,"",-99,"",-99, 27,43);
      gfx_setfont(12);
      gfx_set(1,0,0,1);
      xy(gfx_x-itemw , itemy + (5.5)*gfx_texth);
      gmaster == 1 ? rst.topbarmenuitem("Reset","Group",1,"All",2,"",-99,"",-99,"",-99,"",-99, 30,58)
      : rst.topbarmenuitem("Reset"," This ",1,"All",-98,"",-99,"",-99,"",-99,"",-99, 30,58);
      gfx_y = topbar.h +4*ret;
//åååå
    );
  );
);


dragtaken >= 21 && dragtaken <= 33 ? (
  drag > 0 ? (
    gfx_setfont(12);
    dragtaken == 21 ? (
      dragtop(dragtaken,drag,0,5,1,gfx_texth);
      willsetzoom = 1;
    ) :
/*
    dragtaken == 22 ? (
      slider55 < 100 ? dragtop(dragtaken,drag,0,100,5,gfx_texth/50 ) :
      slider55 < 500 ? dragtop(dragtaken,drag,95,500,10,gfx_texth/200 ) :
      slider55 < 1000 ? dragtop(dragtaken,drag,490,1000,50,gfx_texth/250 ) :
      slider55 < 2000 ? dragtop(dragtaken,drag,950,2000,100,gfx_texth/500 ) :
      slider55 <= 10000 ? dragtop(dragtaken,drag,1900,10000,100,gfx_texth/4000 );
    ) :
*/
    dragtaken == 22 ? dragtop(dragtaken,drag,0,10000,10,gfx_texth/50/(1+slider55*.01) ) :
    dragtaken == 28 ? dragtop(dragtaken,drag,0,1,.001,gfx_texth*50/(1+slider47*19)) :
    dragtaken == 23 ? dragtop(dragtaken,drag,0,4,1,gfx_texth) :
    dragtaken == 24 ? dragtop(dragtaken,drag,-30,12,.1,gfx_texth/2) :
    dragtaken == 29 ? (
      slider41 < .5 ? sli41spd = 1 :
      slider41 < .75 ? sli41spd = 2 :
      slider41 < .88 ? sli41spd = 4 :
      slider41 < 1 ? sli41spd = 4 :
       sli41spd = 1;
      
      dragtop(dragtaken,41,0,1.5,.01,gfx_texth*3.5 * sli41spd);
//      slider41 = 1-slider58;
    ) :
    dragtaken == 25 ? (
      dragtop(dragtaken,drag,-1,1,.01,gfx_texth*10);
      gmaster == 2 ? slider42 = (gmem[c10+9]/10 -20) * slider48; // Volout
      
    ) :
    dragtaken == 26 ? ( // Master
      dragtop(dragtaken,57,0,2,1,gfx_texth*2);
      willgmaster = 1;
    ) :
    dragtaken == 27 && willbypass >= 0  ? ( // Bypass
      gmaster == 1 ? (
        dragtop(dragtaken,drag,0,3,1,-gfx_texth);
      ):(
        dragtop(dragtaken,drag,0,1,1,-gfx_texth);
      );
//      dragtop.mou != 0 ? willbypass = 0 :
//      dragtop.mou != 0 ? willbypass = 0;
      bypass = slider43;

    ) :
    
/*    dragtaken == 29 ? (
      (slider41 += 1) > 1 ? slider41 = 0;
      dragtaken = 0;
    );
*/
    dragtaken == 30 ? ( // Reset
      resetall = slider58;
//      resetall = 1;
      slider58 = 0;
    ) :
    
//    dragtaken == 31 ? ( // Make single
    
    dragtaken >= 30 && dragtaken <= 33 ? (
      dragtaken = 0;

      upbufs();
      topbar();
      upgraph = 1;
    );
    
  );
);

slider58 > 0 ? ( // Make single
  makesingle = slider58;
  slider58 = 0;
);      


makesingle > 0 ? (  // Set to single

  (sli66c += 1) > 10 ? (
    sli66c = 0;
    tgt66 = 0;
  ):(
    tgt66 = -1;
  );

  sli66c <= 1 ? (
    makesingle == 1 ? gmem[color*100] = tgt66 :
    makesingle == 2 ? (
      z = 0;
      loop(10,
        gmem[z*100] = tgt66;
        z += 1;
      );
    );

    sli66c == 0 ? (
      gmaster = slider49 = slider57 = makesingle = 0;
      topbar();
    );
  );
  
);





// SHOW MOUSE CURSOR FREQUENCY
gfx_dest = -1;
drag == 0 && dragtaken == 91 && mouse_cap > 0 && colora == 0 ? showf = 1;
(drag > 8 || dragtaken > 8) && dragtaken != 91 ? showf = 0;
(dragtaken > 0 && dragtaken <= 10) ? showf = 2;
(dragtaken == 0 && mourght == 1) ? showf = 1;

showf > 0 ? (
  drag < 1 && dragtaken > 8 && (mouse_cap & 1) ? showf = 0;
  showmaxx = (log((freqmax-1*0)/old_srate*800+1)*wscmou-gfx_wlim/28.275+3*0);
  showminx = (log((freqmin-1*0)/old_srate*800+1)*wscmou-gfx_wlim/28.275+3*0);
  gfx_setfont(5);
  drag > 0 ? freq = buff[drag] : freq = min(freqmax , max(freqmin,
   ((exp((mouse_x-ret -0*3+gfx_wlim/28.275)/wscmou))-1)/800*old_srate+1*0   ));
  sprintf(freqstr,"%.f", freq+.1,0);
  gfx_measurestr(freqstr,freqw,freqh);
  gfx_measurestr(" Hz",hzw,hzh);

  gfx_r=gfx_g=gfx_b=0.0;gfx_a=0.5;
  showx = mouse_x - (mouse_x/gfx_wlim)* (freqw+dbw*2) +dbw;
  
  mouse_y >= zerog ? showy = mouse_y+gfx_texth*1.5;
  mouse_y < zerog ? showy = mouse_y-gfx_texth*2;

  (showy > boxytop-gfx_texth) ? showy = mouse_y-gfx_texth*2;
  (showy < but_h) ? showy = mouse_y+gfx_texth*1.5;

  gfx_rect(showx , showy, freqw+hzw+3 , gfx_texth);

  
  gfx_r=gfx_g=gfx_b=0.8;gfx_a=1;
  gfx_x = showx;
  gfx_y = showy;
  gfx_drawstr(freqstr);
  gfx_drawstr(" Hz");
      
  mouse_x < 0 || mouse_x > gfx_wlim || mouse_y < 0 || mouse_y > gfx_h ? showf = 0;
);



mouse_cap > 0 && pointing == 0 ? listforcestay = 0;


// MARQUEE SELECTION
//(dragtaken == 91 || drag == 0) && dragtakenold != 91 ? (
(dragtaken == 91 || drag == 0) && mouse_cap > 0 && mouse_cap <= 18 && last_mouse_cap == 0
&& boxdrag == 0 && barmenu == 0 && cap_mode == 0 && listforcestay == 0 && choosecolor == 0 ? (
  dragmrq = 1;
  mrqstrtx = mouse_x;
  mrqstrty = mouse_y;
//  mrqg1 = zerog - g*scaleg + autopoolpx;
);

dragmrq > 0 && mouse_cap == 0 ? dragmrq = -1;
dragmrq != 0 ? (

  dragmrq > 0 ? (
    dragtaken > 0 && dragtaken != 91 ? (
      dragmrq = 0;
    ):(
      gr = .6;
      gfx_set(1,.6,0,.6);
      gfx_rect(mrqx=min(mrqstrtx,mouse_x) , mrqy=min(mrqstrty,mouse_y) , 
        mrqw=max(mrqstrtx,mouse_x)-mrqx , mrqh=max(mrqstrty,mouse_y)-mrqy, 0);
      gfx_a = .1;
      gfx_rect(mrqx,mrqy,mrqw,mrqh,1);
    );    
  );  

  dragmrq < 0 && (mrqw > 10 || mrqh > 10) ? (

    mouse_cap != 17 && last_mouse_cap != 17 ? ( // No Alt
      multis = multiedit = 0;
      mm=1;
      loop(maxpoints,
        multiselect[mm] = 0;
        mm += 1;
      );
      
    );
    
    mm=1;
    loop(points,
      xpos[mm] >= mrqx && ypos[mm] >= mrqy && xpos[mm] <= mrqx+mrqw
      && ypos[mm] <= mrqy+mrqh ? (

        last_mouse_cap == 17 ? ( // While pressing Alt
/*
          s = mm-1;
          slider(1+s*4) = buff[mm] = 20001;
          slider(2+s*4) = bufg[mm] = 0;
      //    eqini_all();
      //    forcedragprev = forcedragprev2;
          slider63 -= 1;
          points = slider63; 
*/
          bufbyp[mm] = 99;
          multiselect[mm] == 1 ? (
            multiselect[mm] = 0;
            (multis -= 1) <= 1 ? multiedit = 0;
          );
          willremove += 1;

        ):(

          multiselect[mm] = 1;
          multis += 1;
          multis == 1 ? firstsel = mm;
          lastsel = mm;
//          newdragprev == 0 ? (
//          dragprev = mm;
//            mouse_y < mrqstrtx ? newdragprev = 1;
//          );
          mrqstrtx < mouse_x ? dragprev = lastsel : dragprev = firstsel;
        
        );
      ):(
        last_mouse_cap != 17 ? (
          multiselect[mm] > 0 ? multis -= 1;
          multiselect[mm] = 0;
        );
      );
      mm += 1;
    );
    
    last_mouse_cap == 17 && willremove == 0 ? rstpk = 1;
    
    
    
    
//    mrqstrtx < mouse_x ? dragprev = lastsel : dragprev = firstsel;
/*
    mrqrem > 0 ? (
      p=0;
    );
*/
    bufdynena[dragprev] == 0 ? (
      showdyn = 0;
      upgraph += 1;
    );
    
    last_mouse_cap != 17 ? (

      multis > 0 ? showbox = 1;
      multis > 1 ? (
        multiedit = 1;
        multisame();
      );
      
      multis > 0 ? (
        note(buff[dragprev]);
        (mouse_capold == 2 || mouse_capold == 13) ? (
          mrqsel = 1;
          listfloat = dragprev;
          listchoose = listforcestay = 17;
          moustartx = xpos[dragprev];
          moustarty = ypos[dragprev];
        );
      ):(
        dragprev = 0;
      );
    );
    drawpoints();
    drawbox();

  );
);



















//mouse_cap == 0 ? dragmrq = mrqw = mrqh = newdragprev = 0;
mouse_cap == 0 ? (
  barc = 0;
  
  gmaster == 1 && bypass > 0 ? gmasterbypass = bypass;
  willbypass == -1 ? willbypass = 0 :
  
  willbypass > 0 ? (
    willbypass = 0;
    bypass == 0 ? bypass = max(1,gmasterbypass) : bypass = 0;
    slider43 = bypass;
    upgraph = 1;
  );
  

  willgmaster > 0 ? (
    dragtaken = 0;
    willgmaster = 0;
    slider49 = gmaster = slider57;
    gmaster == 1 ? mygmem = (gmem[color*100] += 1);
    topbar();
    drawpoints();
  ):(
    slider57 = slider49;
    topbar();
  );
  
  willbarmenu != 0 ? (
    barmenu = max(0, willbarmenu );
    willbarmenu = 0;
  );


  willremove > 0 ? (
    willremove -= 1;
    last_mouse_cap == 17 ? (
      tmp_bypass = bypass;
/*
      dragprev > 0 ? (
        mrqdragprev = dragprev;
      );
*/
    );
        
    
    bypass = 1;
    mm = 1;
    
    bufbyp[dragprev] == 99 ? nearest();

        
      

    loop(points,
      bufbyp[mm] == 99 ? (
//        mm < mrqdragprev ? mrqdragprev -= 1;
        
        rempoint(mm);
        willremovenew = willremove - 1;
      );
      mm += 1;
    );
    willremovenew < 0 ? willremovenew = 0;
    willremovenew == willremove ? (
//      dragprev = mrqdragprev;
      bypass = tmpbypass;
    );
  );
  dragmrq = mrqw = mrqh = 0;
);


// CHOOSE COLOR


function colmou(r g b)
  instance(yx yn cn x y w h sqx sqy dbw2)(
  w = h = dbw;
  yx = yn = 0;
  cn = 1;
  loop(10,
    cn == 1 ? gfx_set(.28,.12,.0,colora) :
    cn == 2 ? gfx_set(.4,0,.0,colora) :
    cn == 3 ? gfx_set(.48,.2,.0,colora) :
    cn == 4 ? gfx_set(.42,.38,.0,colora) :
    cn == 5 ? gfx_set(.0,.35,.0,colora) :
    cn == 6 ? gfx_set(.05,.15,.45,colora) :
    cn == 7 ? gfx_set(.25,0,.4,colora) :
    cn == 8 ? gfx_set(.4,.4,.4,colora) :
    cn == 9 ? gfx_set(0,.35,.35,colora) :
    cn == 10 ? gfx_set(0,0,0,colora);
    
    gfx_rect(x=colx+2+yx*(dbw+2),y=coly+dbw+2+yn*(dbw+2),dbw,dbw ,1);
    mouse_cap != mouse_capold && mouse_x > x && mouse_x < x+w && mouse_y > y && mouse_y < y+h ? (
      color = cn;
      color == 10 ? color = 0;
      choosecolor = 0;
      gmaster == 1 ? (
        gmem[color*100] = (mygmem += 1);
        upmaster += 1;
      );
    );
    
    (yn += 1) > 4 ? (
      yx = 1;
      yn = 0;
    );
    cn += 1;
  );

  // Selected color square
/*
  gfx_set(1,1,1,1);
  gfx_circle(colx+2+dbw/2,coly+dbw+dbw/2 , dbw/8 ,1);
  gfx_circle(colx+2+dbw/2,coly+dbw+dbw/2 , dbw/4 ,0,0);
*/
  sqx = (color >= 6) + (color == 0);
  sqy = (color-1) - 5*(color >= 6) + 5*(color==0);

  
  mouse_x > colmou.x && mouse_x < colmou.x+colmou.w && mouse_y > colmou.y
  && mouse_y < colmou.y+colmou.h && choosecolor == 0 ?
    gfx_set(1,1,1,.9) : gfx_set(1,1,1,colora*.5+.4);

  dbw2 = dbw + ret;
  gfx_rect(colx+2*ret +sqx*dbw2,coly+dbw+2*ret +sqy*dbw2,dbw-2*ret,dbw-2*ret ,0);


  mouse_cap != mouse_capold && colora == 1 ? choosecolor = 0;
);

  
  
choosecolor == 0 ? ( colora > 0 ? colora -= .1 : colora = 0; );
choosecolor > 0 || colora > 0 ? (
  dragtaken = 97;
  choosecolor > 0 && colora < 1 ? colora += .1; colora > 1 ? colora = 1;
  
  colx = 4;
  coly = gfx_h-dbw*7-16;  
  colh = dbw*6+12;
  
  gfx_set(0,0,0,colora);
  gfx_rect(colx,coly ,colw= dbw*2+6,colh ,1);
  gr = .9;
  gfx_set(gr,gr,gr,colora);
  gfx_rect(colx,coly,colw,colh ,0);

  xy(colx+dbw,coly+dbw*.5);
  gfx_setfont(5);
  gr = .8;
  gfx_set(gr,gr,gr,colora);
  gfx_drawstr("Link Ch",261,gfx_x,gfx_y);
  
  colmou(.6,0,0);
  
):(
  dragtaken == 97 && mouse_cap == 0 ? dragtaken = 0;
);


gfx_setfont(1);




// FORCE LIST STAY with RIGHT CLICK
mouse_cap == 2 && (listchooseold == 17 || listchoose == 17) ? (
  listforcestay = 17;
    listnostay = 0;
);
//mouse_cap > 0 && mouse_cap != 2 ? listforcestay = 0;
listforcestay > 0 ? listchoose = listforcestay;








listchoose > 0 || listchooseold > 0 ? (
  nolist <= 0 ? chooselist(listchoose);

//
  listchoose == 16 ? crossbox = 24*ret : crossbox = 0;
  mouse_x > listx1 && mouse_x < listx2 ? (
//    multiedit == 1 ? zy = 1 : zy = 0;
    zy = 1;
    gfx_set(1,1,1,.1,1);
    while(zy < items)(
      (mouse_y > listytop + zy * listh) && (mouse_y < listytop + min(maxpoints+1,zy+1) * listh) ? (
        listchoose == 16 && ( mouse_x < listx1 + crossbox) ? (
//        listchoose == 16 &&( mouse_x < listx1 + crossbox) && (mouse_y > listytop + listh) ? (
          crossing = crossbox;
          choseremove = 1;
          gfx_set(1,.0,.0,.7,0);
        ):(
          crossing = 0;
          choseremove = 0;
          gfx_set(1,1,1,.1,1);
//          mouse_y < listytop + listh && multiedit == 1 ? gfx_a = 0;
        );

        listchoose == 16 && (mouse_y < listytop + (1+(points<maxpoints)) * listh) ? (
          (multiedit > 0 || crossing > 0) && (points < maxpoints) ||
          (points < maxpoints && crossing > 0) ? (
            gfx_a = 0;
          );
        );  
        gfx_rect(listx1+ret+crossbox-crossing , listytop +ret + zy * listh , listw-crossbox -crossing*.45 -2*ret , listh -ret*2);
        zy += 10;
      ):(
        zy += 1;
      );
    );
  );  
//åå
  mouse_x > listx1 && mouse_x < listx2 && mouse_y > listytop && mouse_y < listybot ? (
    mouselist = 1;
  ):(
    mouselist = 0;
  );
  


  // List hide at mouse release
  mouse_cap != 2 && mouse_cap != 13 && mouse_capold != 2 && mouse_capold != 13
  && listchoose != 17 && listchooseold != 17 ?(
    mouse_cap > 0 ? (
      listcnt >= 0 ? (
        (listcnt += 1) > 7 ? (
          dragtaken == listchoose ? listnostay = 1;
        ):(
          listnostay = 0;
        );
      );
      mouselist == 0 ? (  // Cursor NOT on top of list
        // only nostay if
        dragtaken > 0 && (dragtaken != listchoose) && listnostay == 0 ? (
          listchoose = listcnt = 0;
          listnostay = 1;
        );
  /*
        listnostay == 0 ? (
          listchoose = listcnt = 0;
          listnostay = 1;
        );
  */
      ):(
        listcnt == -1 ? (
          listnostay = 1;
        );
      );
      
    );
  );
  

  listchoose == 16 && (multiedit > 0 || mouse_cap > 1) ? (
    multiedit = 1;
    listnostay = nolist = 0;
  );
  



//  (listnostay == 0 && mouse_cap == 0) || (listnostay == 1 && mouse_cap > 0) ? (
//  (mouse_cap == 0 && listnostay == 1) || (mouse_cap > 0 && listnostay == 0) ? (
  ( (mouse_cap > last_mouse_cap) && last_mouse_cap == 0 && mouselist == 1) ||
  ( (mouse_cap == 0) && (last_mouse_cap > 0) && mouselist == 1) && mrqsel == 0 ? (
  
    mouselist == 1 ? (
      choselistitem = floor( (mouse_y - listytop) /listh) +1;
      listcnt = 0;
      
      mouse_cap <= 1 && multiedit == 0 ? (
        listnostay = 1;
        listforcestay = 0;
        mouselist = 0;
      ):(
        p= 0;
      );
      
      
    ):(
      listnostay == 1 ? (
        listchoose = nolist = 0;
      );
    );

  );
  nolist == 1 ? (
    nolist = listchoose = 0;
  );
  
  mouse_cap > 0 && mouselist == 0 && listcnt == -1 && listfloat == 0 ? (
    nolist = 1;  
    listchoose = listchooseold = 0;
  );
  
  choselistitem > 0 && nolist <= 0 && mrqsel == 0 ? (
    listchooseold == 14 ? (
      multiedit > 0 ? (
        z = 1;
        loop(points,
          multiselect[z] == 1 ? bufm[z] = 5-choselistitem;
          z += 1;
        );
        multisamem = 1;
      ):(
        bufm[dragprev] = 5-choselistitem;
      );
      upauto();
      upsliders();
      upgraph += 1;
      drawpoints();
    );


    
    listchooseold == 16 ? ( // Box Point number
    
      choselistitem == 1 && mouse_cap > 0 ? (
        mouse_capold == 0 ? (
          (reorder += 1) > 1 ? reorder = 0;
          slider61 = reorder;
          slider_automate(slider61);
          reorder == 1 ? reorder_all();
        );
        nolist = -1;

      ):(
      
        choselistitem > 0 ? multilistchoseorder = choselistitem;
        
        // Click to select
        multiedit == 0 && moucmd == 0 && moushft == 0 ? (
          points == maxpoints ? choselistitem += 1;
          
          choseremove == 1 ? (
            mouse_y > listytop + listh * (points < maxpoints) ? rempoint(points+3-choselistitem);
          ):( // No Remove
            choselistitem == 2 && choseremove == 0 ? ( // 2nd from top right item
              spacef = widespacef();
              gmaster == 2 ? (
                addpoint(spacef,0,0,1);
                ownpoints += 1;
              ):(
                addpoint(spacef,0,1,1);
              );
              willdragpoint = 1;
              nolist = 1;
  //            forcedrag = dragtaken = 11;
    //          dragtaken = dragprev;
            ):(
              multilistnormalclick += 1;
              choselistitem > 1 ? (
                forcedragprev = points+3-choselistitem;
                multiselect[dragprev] = 0;
                multiselect[forcedragprev] = 1;
              );
    //          note(buff[dragprev]);
            );
            note(buff[dragprev]);
            drawpoints();
          );
        ):(                              // Multiedit or Cmd- or Shft-
        
          mouse_cap > 0 && (last_mouse_cap == 0) ? (
          
            points == maxpoints ? choselistitem += 1;
            
            sz = points+3-choselistitem;        
            choseremove == 1 ? (  // Remove point 
              sz <= points ? rempoint(sz);
            ):(
    
              moushft == 0 ? (  // Cmd-clck or Multiedit to select points in list
                dragtest += 1;
                multiselect[sz] == 0 ? (
                  multiselect[sz] = 1;
                  dragprev = sz;
                  multis += 1;
                ):(
                  multiselect[sz] = 0;
                  (multis -= 1) == 1 ? (
                    listchoose = listchooseold = 0;
                  );
                    adragnear = dragprev;
                  dragprev == sz ? (
                    nearest();
                  );
                  
                );                
              ):(                 // Shift-click
                
                z = 1;
                multis = 0;
                loop(points,
                  (sz > z && dragprevold > z) || (sz < z && dragprevold < z) ? (
                    multiselect[z] = 0;
                  ):(
                    multiselect[z] = 1;
                    multis += 1;
                  );
                  z += 1;
                );
                dragprev = sz;
                multis > 1 ? multiedit = 1;
    //            multis = 2;
    //            nolist = listnostay = 0; // Doesn't work
    
              );
    
              multis < 2 ? multiedit = 0 : multiedit = 1;
              multisame();
            );
          );
            
          drawpoints();
          
        );
//        choselistitem = listnostay = 0;
  
        (multiedit == 1) && mouselist == 0 && mouse_cap > 0 ? (
          listchoose = listchooseold = dragtaken = 0;
        );
      );
      
    );



    




    // Shape
    listchooseold == 17 ? (
      
      listfloat > 0 && multiselect[listfloat] == 0  ? (
        bufshape[listfloat] = 6-choselistitem;
        bufshape[listfloat] == 1 || bufshape[listfloat] == 3 || bufshape[listfloat] == 4 ? (
          bufg[listfloat] = min(30,max(-30,bufg[listfloat]));
        );          
        eqini_one(listfloat);
        
      ):(
        
        multiedit > 0 ? (
          
          // Auto shapes
          choselistitem == 1 ? (
            z = zz = 1; // z = node, zz = #selected
            s = 0;
            loop(points,
              multiselect[z] > 0 ? (
/*
                (zz) > (multis/2) ? (
                  xpos[z] > gfx_wlim/2 ? s = 1;
                );
                bufshape[z] = 2+s;
*/
                xpos[z] < gfx_wlim*.15 && z == 1 && points > 4 ? s = 0 :
                xpos[z] < gfx_wlim*.25 && (zz == 1 || (zz==2&&bufshape[1]==0)) ? s = 1 :
                xpos[z] > gfx_wlim/2 && zz == multis ? s = 4 :
//                xpos[z] < gfx_wlim/2 ? s = 3 :
                bufg[z] >= 0 ? s = 3 :
//                xpos[z] > gfx_wlim/2 ? s = 2;
                s = 2;
                  
                zz += 1;
                

                bufshape[z] = s;
                s == 1 || s == 3 || s == 4 ? (
                  bufg[z] = min(30,max(-30,bufg[z]));
                );          
                
                eqini_one(z);
                

              );
              z += 1;
            );
            multisames = 0;
            
          ):(
//            choselistitem > 3 ? choselistitem -= 1;
            choselistitem -= 1;
            z = 1;
            loop(points,
              multiselect[z] == 1 ? bufshape[z] = 6-choselistitem;
              bufshape[z] == 1 || bufshape[z] == 3 || bufshape[z] == 4 ? (
                bufg[z] = min(30,max(-30,bufg[z]));
              );          
              
              eqini_one(z);
              
              z += 1;
            );
            multisames = 1;
          );
        ):(
//          zs = (listfloat > 0 ? listfloat : dragprev);
          bufshape[dragprev] = 6-choselistitem;
          choselistitem == 3 && bufw[dragprev] < wminbell ? bufw[dragprev] = wminbell;
          bufshape[dragprev] == 1 || bufshape[dragprev] == 3 || bufshape[dragprev] == 4 ? (
            bufg[dragprev] = min(30,max(-30,bufg[dragprev]));
          );          
          eqini_one(dragprev);
          
          
        );
        
      );
//      eqini_one(listfloat);
//      upgraph < 10 ? upgraph += 1;
//      update = 1;
      mutespls = 200;

      upgraph = 2;
      
    );
//    upsliders(); // ååååå TMP!!!
    upauto();
//    dragg(dragprev,0);
//    drawpoint(buff[listfloat],gtmp,listfloat);
    drawbox();
    
    dragmrq > 0 ? choselistitem = 0;
    choselistitem > 0 && listchooseold != 16 ? (
      listcnt = listfloat = 0;
      nolist = 1;
      multiedit == 0 ? (
        listchoose  = listchooseold =  0;
        p=0;
      );
    );




  );

//  mouse_cap > 1 || listchoose == 17 ? listnostay = 0 : listnostay = 1;
):(
  mouselist = 0;
);

choselistitem > 0 ? dragtaken = listchooseold;

/*

mouse_cap > 0 && cap_mode == 0 ? (
  x = (log(1.0+(f/old_srate*2.0)*400)*wsc)  - wsc*0.2;

  buff[1] = tmpf = ((exp((mouse_x-3+gfx_wlim/27.5)/wscmou))-1)/800*old_srate+1;
  bufg[1] = tmpg = (zerog-mouse_y)/scaleg;
);
*/










noob < 3 ? upgraph += 1;




/*
//multis == 1 && multiedit == 0 && multieditold > 0 ? (
multiedit != multieditold ? (
  z = 1;
  while(z <= points)(
    multiselect[z] == 1 ? (
      forcedragprev2 = z;
      z = points;
    );
    z += 1;
  );
  dralone4 = forcedragprev2;
);
*/

forcedragprev == -1 ? forcedragprev = forcedragprev = dragprev = 0;
forcedragprev > 0 ? (
  dragprev = drag = forcedragprev;
//  multiselect[dragprev] = 1;
  note(buff[dragprev]);
  upgraph += 1;
  forcedragprev = 0;
  drawbox();
  
);
forcedragprev2 > 0 ? (
  forcedragprev2 != dragprev && dragprev > 0 && multiedit == 0 ? multiselect[dragprev] = 0;
  dragprev = drag = forcedragprev2;
  dragtaken = 0;
//  multiselect[dragprev] = 1;
  note(buff[dragprev]);
  upgraph += 1;
  
  
  mouse_cap == 0 ? forcedragprev2 = 0;
  drawbox();
  dralone5 = dragprev;
);




// HELP

noob < 5 ? (
  blinkhelp = 1;
);


helpa > 0 ? (
  gfx_set(0,0,0,helpa-.1);
//  gfx_rect(but_h,but_h,gfx_wlim-but_h*2,gfx_h-but_h);
  gfx_rect(but_h,but_h,gfx_w-2*but_h,ceil((boxytop-1)-but_h));
  gfx_rect(but_h,floor(boxytop-1),ceil(boxx1-1-but_h),gfx_h-(boxytop-1));
//  gfx_rect(boxx1+boxw+1,floor(boxytop-1),ceil( (gfx_w-but_h)-(boxx1+boxw) ),gfx_h-(boxytop-1));
  gfx_rect(boxx1+boxw+1,floor(boxytop-1),(gfx_w-but_h)-(boxx1+boxw),gfx_h-(boxytop-1));
  gfx_rect(boxx1-1,boxybot+1,boxw+2,gfx_h-boxybot);
):(
  helpa = 0;
  helpage = 0;
);




// HELP
help != 0 ? (
  helpa > .5 ? blinkhelp = 2;
  dragprev == 0 ? (
    dragprev = multis = multiselect[1] = showbox = 1;
    drawpoints();
    drawbox();
  ) :
  mouse_cap > mouse_capold && mouse_capold == 0 ? (
    mouse_x > gainx && mouse_y > helpy && helpa > .9 ? help = -1;
  );
//  showbox = 1;
  dragprev == 0 ? (
    dragprev = min(points,2);
    multiselect[dragprev] = multis = 1;
  );
//  gfx_dest = 9;
//  gfx_setimgdim(9,-1,-1); gfx_setimgdim(9,gfx_wlim,gfx_h);
  dragtaken = 99;
  cap_drag = 1;
  
  help > 0 ? (
//    helpa < 0.95 ? helpa += 0.03;
    helpa < 1 ? helpa += 0.03;
    helpa = min(helpa,1);
  ):(
    helpa > 0 ? (
      helpa -= 0.05;
    ):(
      helpa = help = dragtaken = 0;
    );
  );

  gfx_setfont(9);

  helpage != 1 ? (
    gfx_set(.05,.05,.3,helpa);
    gfx_rect(0,0,but_h,gfx_h);
    gfx_rect(0,0,topbar.x34,but_h*1.1);
    
    xy(but_h*2,6);
    gfx_set(.6,.6,1,helpa);
    gfx_drawstr("Analyzer ...");
    
  );
  helpage != 2 && helpage != 3 ? (
    gfx_set(.0,.2,.0,helpa);
    gfx_rect(topbar.x34,0,gfx_w-topbar.x34,but_h*1.1);
    gfx_rect(gfx_w-but_h,0,but_h,gfx_h);
    
    
    xy(gfx_w*.6,6);
    gfx_set(.5,8,.6,helpa);
    gfx_drawstr("Volume & Link ...");
    
  );

  
  helpage != 4 ? (
    gfx_set(.5,.25,.0,.9*helpa);
    gfx_rect(boxx1,boxytop,boxw,boxh);
    
    xy(gfx_w*.4,boxy1+boxh*.25);
    gfx_set(1,.8,.0,helpa);
    gfx_drawstr("EQ Node controls ...");
    
  );
  
  mouhlp(0,0,gfx_w*.4,but_h * 1.2 ,1);
  mouhlp(gfx_w*.45,0,gfx_w*.55,but_h*1.2 ,2);
//  mouhlp(gfx_w*.7,0,gfx_w*.3,but_h*1.2 ,3);
  mouhlp(boxx1,boxytop,boxw,boxh ,4);
  
  hlptity = but_h * 1.5;
  helpage == 0 ? gfx_setfont(14);
  gfx_measurestr(#hlpagestr,hlptitw,0);
  hlptitw += 30;
  hlptitx = gfx_wlim/2 - hlptitw/2;
  hlptith = gfx_texth * 1.1;
  gfx_setfont(9);
  
  
  helpage == 0 ? #hlpagestr = "EQall Guide";
  
  
  
  
  
  helpage == 1 ? (
    #hlpagestr = "Analyzer";
    
    gfx_set(gr=.8,gr,gr,helpa);
    
    xy(gfx_w-but_h*1.5,but_h*1.1);
    gfx_drawstr("Click / Click+hold
top bar for settings", 258,gfx_x,gfx_w);


    gfx_set(.6,.8,1,helpa);

    xy(160*ret,but_h);
    gfx_rectto(gfx_x+2*ret,but_h*2.8);
//    gfx_y += gfx_texth*2;
    gfx_x -= gfx_texth;
    gfx_drawstr("Source mode (Stereo, Mid, Side, L, R).",256,gfx_x,gfx_y);

    xy(110*ret,but_h);
    gfx_rectto(gfx_x+2*ret,but_h*3.8);
    gfx_x -= gfx_texth;
    gfx_drawstr("Analyzer averaging window (ms).",256,gfx_x,gfx_y);

    xy(55*ret,but_h);
    gfx_rectto(gfx_x+2*ret,but_h*4.8);
    gfx_x -= gfx_texth/2;
    gfx_drawstr("Analyzer resolution. Alt-click to ");
    mx1 = gfx_x;
    gfx_set(1,1,1,helpa);
    gfx_roundrect(gfx_x,gfx_y+ret,66*ret,gfx_texth , 6*ret , 1);
    gfx_x += 7*ret;
    slider50 == 0 ? gfx_drawstr("Enable") : gfx_drawstr("Disable");
    gfx_set(.6,.8,1,helpa);
    gfx_x = mx1 + 70*ret;
    mx2 = gfx_x;
    gfx_drawstr(" analyzer.");
    my1 = gfx_y;
    my2 = gfx_y + gfx_texth;

    mouse_cap > mouse_capold && mouse_capold == 0 && mouse_x > mx1 && mouse_x < mx2
     && mouse_y > my1 && mouse_y < my2 ? (
      (slider50 += 1) > 1 ? slider50 = 0;
      noanal = 1-slider50;
      slider_automate(slider50);
      dragtaken = 98;
    );

    xy(but_h*2,gfx_y += gfx_texth*1.5);
    gfx_drawstr("Drag vertically to scale, horizontally to zoom analyzer.");
    xy(but_h,gfx_y += gfx_texth/2);
    gfx_rectto(but_h*1.8,gfx_y+2*ret);
    xy(but_h*2,gfx_y += gfx_texth/2);
    gfx_drawstr("(With 'Shift' to link EQ range zoom  ");
    gfx_set(.0,.7,.0,helpa);
    gfx_drawstr(" >>> ");
    gfx_set(.6,.8,1,helpa);
    gfx_drawstr(").");

//    xy(dbw,max(gfx_y+gfx_texth,gfx_h*.75));
    xy(dbw*2,gfx_h-dbw*.9);
    gfx_drawstr("Link Channel");

//    xy(dbw,gfx_h-dbw*.5);
//    gfx_rectto(gfx_x+dbw,gfx_y-2*ret);
    gfx_triangle(x=dbw,y=gfx_h-dbw*.3 , xx=dbw*1.8,yy=gfx_h-dbw*.4
     , xx-ret,yy-2*ret , x,y-2*ret);
    
  );







  helpage == 2 || helpage == 3 ? (
    #hlpagestr = "Volume & Link";
    
    gfx_set(gr=.8,gr,gr,helpa);
    
    xy(but_h*1.5,but_h*1.5);
    gfx_drawstr("Click / Click+hold
top bar for settings");
    
    
    gfx_set(.2,.7,.2,helpa);
    xy(but_h*1.5,but_h*4.5);
//    gfx_rectto(gfx_x+2*ret,but_h*4.8);
//    gfx_x -= gfx_texth/2;
    gfx_drawstr("Output volume. ");
    gfx_line(gfx_x,gfx_y+gfx_texth/2 , (topbar.x34+topbar.x45)/2 , but_h);
    xy(but_h*1.5,gfx_y+gfx_texth*1.1);
    gfx_drawstr("Alt-click to ");
    mx1 = gfx_x;
    gfx_set(1,1,1,helpa);
    gfx_roundrect(gfx_x,gfx_y+ret,66*ret,gfx_texth , 6*ret , 1);
    gfx_x += 7*ret;
    slider41 <= 0 ? gfx_drawstr("Enable") : gfx_drawstr("Disable");
    gfx_set(.2,.7,.2,helpa);
    gfx_x = mx1 + 70*ret;
    mx2 = gfx_x;
    my1 = gfx_y;
    my2 = gfx_y + gfx_texth;
    xy(but_h*1.5,gfx_y+gfx_texth*1.1);
    gfx_drawstr("auto-compensation.");
    
    mouse_cap > mouse_capold && mouse_capold == 0 && mouse_x > mx1 && mouse_x < mx2
     && mouse_y > my1 && mouse_y < my2 ? (
//      (slider41 += 1) > 1 ? slider41 = 0;
      (slider41 *= -1) == 0 ? slider41 = 1;
      noauto = (slider41 <= 0);
      slider_automate(slider41);
      upauto();
      dragtaken = 98;
//      mouse_capold = nocap = 1;
    );
    
    
    
    xy(gfx_wlim - but_h*2, gfx_y += gfx_texth*.0);
    gfx_line(gfx_x,gfx_y+gfx_texth/2 , gfx_wlim-but_h,gfx_y+gfx_texth/2);
    gfx_drawstr("EQ scale vertical zoom.", 258,gfx_x,gfx_y);
    
    xy(gfx_wlim/2 - but_h*8, gfx_y + gfx_texth*1.5);
    gfx_drawstr("Link master volume scale (-100%...100%).");
    gfx_line(gfx_wlim/2,gfx_y , gfx_wlim/2 +but_h*3 , but_h);
    
    xy(gfx_wlim -but_h*1.5, but_h *2);
    gfx_drawstr("Bypass", 258,gfx_x,gfx_y);
    gfx_line(gfx_x - but_h*3,gfx_y , gfx_wlim-but_h*2 , but_h);

    xy(x = gfx_wlim - but_h*2, but_h*3.5);
    gfx_line(gfx_wlim - but_h*4.5,gfx_y , gfx_wlim - but_h*4.2 , but_h);
    gfx_drawstr("Link mode:", 258,gfx_x,gfx_y);
    xy(x, gfx_y += gfx_texth);
    gfx_drawstr("Master, slave, single,", 258,gfx_x,gfx_y);
    xy(x, gfx_y += gfx_texth);
    gfx_drawstr("Reset EQ.", 258,gfx_x,gfx_y);
 
  );
  

  helpage == 4 ? (
    #hlpagestr = "EQ node controls";
/*    
    points == 10 ? (
//      drawbox();
//      gfx_setfont(9);
      showbox = 1;
      
    );
  */  
    gfx_a = helpa;
    hlpdim = .6;
    gr = .7;
    gfx_set(gr,gr,gr,helpa);

//    xy(x=gfx_wlim/2+hlptitw/2, hlptity);
    xy(hlptitx, hlptity +gfx_texth*1.1);
    gfx_drawstr("  (selected nodes)");
//    xy(x+but_h, gfx_y+gfx_texth);
//    gfx_drawstr("nodes");


    gfx_set(1,.8,.2,helpa);

    xy(boxx1+but_h/2, boxybot - gfx_texth*0);
    gfx_drawstr("Shape");

    xy(but_h*.2, boxymid - gfx_texth*0);
    gfx_drawstr("Enable");
    gfx_line(gfx_x+but_h/4,y=gfx_y+gfx_texth/2 , boxx1+but_h/3,y);

    xy(boxx1+but_h/4, boxytop - gfx_texth*1.5);
    gfx_line(gfx_x-but_h,gfx_y+gfx_texth , boxx1+but_h/3,boxytop+boxh/4);
    gfx_drawstr("Previous",258,gfx_x,gfx_y);
    gfx_x = boxx1 + but_h*1.8;
    gfx_line(gfx_x+but_h,gfx_y+gfx_texth , boxx1+but_h*2,boxytop+boxh/4);
    gfx_drawstr("Next");
    
    xy(boxx1-but_h*2.5, gfx_y -= gfx_texth*1.5);
    gfx_drawstr("Select/Add/Remove");
    gfx_line(x=boxx1+but_h,gfx_y+gfx_texth , x,boxytop+boxh/8);

    xy(boxx1+boxw/2+but_h, boxytop - gfx_h*.2);
    xy(boxx1+boxw/2+but_h, boxytop - gfx_texth*3 - max(0,gfx_h-200*ret)*.4);
    gfx_line(gfx_x-but_h*2,gfx_y+gfx_texth , boxx2a+boxw*.1,boxytop+boxh*6/8);
    gfx_a *= hlpdim;
    gfx_drawstr("(Drag/click to snap)", 257,gfx_x,gfx_y);
    xy(boxx1+boxw/2+but_h, gfx_y -= gfx_texth*1);
    gfx_a = helpa;
    gfx_drawstr("Note at frequency", 257,gfx_x,gfx_y);

    

    
//    xy(boxx1-boxw*.1, gfx_y -= gfx_texth*1.5);
    xy(boxx1-boxw*.1, gfx_y - max(0,gfx_h-200)*.2);
    gfx_a *= hlpdim;
    gfx_drawstr("(Shift-drag for width)");
    gfx_a = helpa;
    
    gfx_line(x=boxx2a+but_h,gfx_y+gfx_texth , x,boxytop+boxh/8);
    xy(boxx1+boxw*0, gfx_y -= gfx_texth*1);
    gfx_drawstr("Frequency");
    

    xy(x=boxx1+boxw*.45, boxytop-gfx_texth*1);
    gfx_drawstr("Gain");
    gfx_x = x-but_h/2;
    gfx_a *= hlpdim;
    gfx_drawstr("(Shift-drag for other)",264,gfx_x,gfx_y);
    gfx_a = helpa;
    
    xy(boxx1+boxw*.57, boxytop-gfx_texth*1);
    gfx_drawstr("Width");


    
    xy(gfx_w-but_h*1.5,but_h*3);
    gfx_line(gfx_x-but_h*3,gfx_y+gfx_texth*2.5 , boxx1+boxw*.8,boxytop+boxh*1/8);
    gfx_drawstr("Show/enable
dynamics",258,gfx_x,gfx_y);

    
    xy(boxx1+boxw, boxytop - gfx_texth*3.5);
    gfx_line(gfx_x+but_h/2,gfx_y+gfx_texth , boxx1+boxw-but_h/2,boxytop+boxh*1/8);
    gfx_drawstr("Stereo mode",257,gfx_x,gfx_y);

    xy(boxx1+boxw+but_h, boxybot);
    gfx_drawstr("(Link strength/enable)", 258,gfx_x,gfx_y);



/*
  //  xy(gfx_wlim/2,zerog);
  //  gfx_drawstr("Double-click horizon to add point",261,gfx_x,gfx_y);

  
*/ 
  );


  gfx_set(.4,.8,.7,helpa);



  helpage == 0 ? (
  
    gfx_set(.8,.6,.5,helpa);
    
    xy(x=but_h*.5 + max(0,gfx_wlim-300*ret) * .1 , but_h*.9 + max(0,gfx_h-200*ret) * .2);
    gfx_setfont(14);
    gfx_drawstr("Nodes:");
    gfx_setfont(9);
    xy(x,gfx_y += gfx_texth);
    gfx_drawstr("- Width:  Shift-drag
- Precise:  Cmd (= Ctrl) drag
- Shape:  Right-click, Cmd+Shift click (or + marquee)
- Select (multiple):  Cmd click, Shft click, marquee
- Remove:  Alt click, Alt + marquee
- Bypass:  Double-click node
- Add node:  Double-click empty area");

    gr = .6;
    gfx_set(gr,gr,gr,helpa);
    xy(gfx_wlim/2,gfx_y += gfx_texth + max(0,gfx_h-250*ret) * .1);
    gfx_drawstr("Mouse frequency:  Right-click empty area",257,gfx_x,gfx_y);

    xy(x=gfx_wlim-but_h*1.5 , but_h*1.3);
    gfx_drawstr("Click coloured",258,gfx_x,gfx_y);
    xy(x, gfx_y += gfx_texth);
    gfx_drawstr("sections for info",258,gfx_x,gfx_y);
  
/*  
    xy(impx = gfx_wlim/5 , impy = gfx_h-gfx_texth*1.2);
    gr = .3 + .3* importing;
    gfx_set(1,gr,gr,1);
    gfx_drawstr("Import LinkEQ instance");
    impx2 = gfx_x;
    impy2 = gfx_h;
/*    
    gr = .3 + .3* undoing;
    gfx_set(gr,gr,1,1);
    gfx_drawstr(" Undo ");
    impx3 = gfx_x;
* /    
    
    mouse_cap > 0 && mouse_x > impx && mouse_x < impx2 && mouse_y > impy ? (
      mouse_x < impx2 ? (
        importing = 1;
        mouse_capold == 0 ? (
  
          p = 1;
          loop(maxpoints,
            bufshape[p] == 1 ? bufshape[p] = 2 :
            bufshape[p] == 2 ? bufshape[p] = 0 :
            bufshape[p] == 3 ? bufshape[p] = 1 :
            bufshape[p] == 4 ? bufshape[p] = 3;
            p += 1;
          );
        );
/*
      ):(
        undoing = 1;
        mouse_capold == 0 ? (
          p = 1;
          loop(maxpoints,
            bufshape[p] = shapeold[p] ;
            p += 1;
          );
        );
      );
      verold = ver;
* /
      upsliders();
      
    ):(
      importing = undoing = 0;
    );
*/
  
    gfx_set(gr = .4,gr,gr,helpa);
    xy(gfx_w *.5 , gfx_h -ret);
    
    #details = "EQall  ";
    #details += sprintf(#ver, "%g" ,ver);
    #details += "   mrelwood plugins";
    gfx_setfont(8);
    gfx_drawstr(#details,265,gfx_x,gfx_y);
  
  );


  gr = .05;
  gfx_set(gr,gr,gr,helpa);
  gfx_rect(hlptitx,hlptity,hlptitw,hlptith ,1);
  gr = .8;
  gfx_set(gr,gr,gr,helpa);
  gfx_rect(hlptitx,hlptity,hlptitw,hlptith ,0);
  hlptitx += 15;
  xy(hlptitx,hlptity);
  helpage == 0 ? gfx_setfont(14);
  gfx_drawstr(#hlpagestr);
  gfx_setfont(9);
  
  

);
/*
blinkhelp == 1 ? (

  blinkcnt == 0 ? blinkstop = 0;
  helpa > 0 ? (
    helpa -= 0.05;
  ):(
    helpa = help = 0;
    dragtaken == 99 ? dragtaken = 0;
//  p=0;
  );
  
);
*/
/*
dragtaken == 99 ? (
  mouse_cap > mouse_capold && mouse_capold == 0 ? (
    help == 0 ? help = 1;
//    help == 2 ? help = -1;
  ):(
    help == 1 ? help = 2;
//    help == -1 ? (help = dragtaken = 0);
  );
);
*/
dragtaken == 99 ? (
  mouse_cap > mouse_capold && mouse_capold == 0 ? (
    help == 0 ? help = 1;
    helpage = 0;
  );
);




gfx_setfont(3);
gfx_set(0,0,0,1,0);
gfx_x = gfx_wlim;
gfx_y = gfx_h;
gfx_rectto(gainx,helpy=(gfx_h-gfx_texth));
gr = .7;
gfx_set(gr,gr,gr,1,0);
gfx_rect(gfx_x+ret,gfx_y+ret, gfx_wlim-gainx-ret*2,gfx_h-gfx_y-ret*2   , 0);
gfx_x += (gfx_wlim-gfx_x)/2 -ret;
gfx_y -= ret;
//gr = 0.4 + help *0.3;
//gfx_set(gr,gr,gr,1,0);
gfx_set(blink2,blink2,blink2,blinka);
gfx_drawstr("?",257,gfx_x,gfx_y);


help == 1 ? (
  blinkhelp = 2;
  blinkstop = 0;
  blinkcnt = 0;
);
blinkhelp >= 0 ? (
  blinkamax = (.9 - (helpa * .2));
  blinkamin = .1;
  blinkstop == 0 ? (blink2 = 1);
  blinkspd = 0.06 / (help/2+1);
  blinkdir == 0 ? (
    blink < 1 ? (
      blink += blinkspd;
    ):(
      blinkdir = 1;
    );
  ):(
    blink > 0 ? (

      blinkstop == 1 ? (
        blink -= blinkspd/4;
        blink2 = blink;
        blink < 0.6 ? (
          blinkhelp = blinkcnt = 0;
          blink = blink2 = 0.6;
        );
      ):(
        blink -= blinkspd;
      );
      
    ):(
      blinkdir = 0;
      blinkcnt += 1;
    );
  );
  blinkcnt >= 3 ? blinkstop = 1;
  blinka = blinkamin + (.5-cos(blink*3.14)/2) * (blinkamax-blinkamin);
//  gfx_set(1,1,1,blink,1);
//  gfx_rect(gainx+ret,helpy,gfx_wlim-gainx-ret*3,gfx_h-helpy-ret*2);
);




// GMEM
gmaster == 1 ? (   // Gmem Master
  q = color*100;
  mygmem != gmem[q+0] && mouse_cap == 0 ? (
    slider49 = gmaster = 2;
    slider_automate(slider49);
//    mygmem = 
    last_mouse_cap2 = 0;
    willdrawbox += 1;
  );
  
  (last_mouse_cap2 > 0 && cap_mode != 49) || upmaster > 0 ? (
    upmaster > 0 ? upmaster -= 1;
  
    bypass != 1 || gmasterbypthis == 1 ? (
//      gmasterbypthis = 0;
      (gmemcnt += 1) > 2 ? gmemcnt = 0; // Gmem send interval during drag
      gmemcnt == 1 ? (
        (gmem[q+0] += 1) > 10000 ? gmem[q+0] = 1;
        mygmem = gmem[q+0];
        color == 0 ? colmaster = 10 : colmaster = 1;

        loop(colmaster,
          gmem[q+1] = min(1,floor(bypass/2));   // Bypass
          gmem[q+2] = slider48*100;   // Volume link
          gmem[q+3] = points;
          gmem[q+4] = 1- max(0,slider41);
//          gmem[q+5] = color;
          gmem[q+6] = ver*100 +100;
          gmem[q+9] = (slider42+20)*10; // Volout
          q1 = 1;
          loop(points,
//            q0 = q - floor(q*.01)*100;
            buflm[q1] == 0 ? (
              gmem[q+(q1)*10+1] = (buff[q1])*10;
              gmem[q+(q1)*10+2] = (bufg[q1]+100)*10;
              gmem[q+(q1)*10+3] = bufw[q1]*100;
              gmem[q+(q1)*10+4] = bufm[q1];
  //            gmem[q*10+5] = bufl[q]*100;
              gmem[q+(q1)*10+6] = bufshape[q1];
              gmem[q+(q1)*10+7] = bufbyp[q1];
            );
            q1 += 1;
          );
          points < maxpoints ? (
            q2 = points + 1;
            while(q2 <= maxpoints)(
              gmem[q+ q2*10+1] = 0;
              q2 += 1;
            );
          );
          q += 100;
          gmem[q] = mygmem;
        );  
          
      );
    );
  );
);

















dblcnt > 0 && dragtaken > 0 ? dbltgt = dragtaken;

willgofloor > 0 ? (
  gofloor(willgofloor);
  willgofloor = 0;
);


willshift > 0 || dblclkshft > 0 ? (

//  dragtaken == 10 || dragtaken == 12 || dragtaken > 13 ? willshift = shiftcnt = 0;
  
  
  (dblclk > 0 && dblclk < 14 ) ? (
    multiedit > 0 ? (
      zw = 1;
      loop(points,
        multiselect[zw] > 0 ? (
          slider(3+(zw-1)*4) = bufw[zw] = 1;
          slider_automate(slider(3+(zw-1)*4));
          eqini_one(zw);
        );
        zw += 1;
      );
      multisamew = 1;
    ):(
      slider(willautomate = 3+(dragprev-1)*4) = bufw[dragprev] = 1;
      eqini_one(dragprev);
    );
    willshift = 0;
    upgraph += 1;
    
    willdrawpoints += 2;
    drawbox();
  );
/*
  (shiftcnt > 10) && mouse_cap == 0 ? (
    willshiftsel = willshift;
    willshift = shiftcnt = 0;
  );
*/
);     




gmemgo == 1 ? (
  gmemgo = 0;
  gmemc = 10;
);
gmemc > 0 ? (
  gmemc -= 1;
  mygmem = (gmem[color*100 +0] += 1);
);



// MOUSE RELEASED
  adragdbl2 += dblclk;

resize = 0;
nolist == 1 ? (
  nolist = 0;
  listchoose = 0;
);

mous == 0 ? (

  nolist == -1 ? nolist = listchoose = 0;

  willstartnote > 0 ? (
    multiedit > 0 ? (
      zw = 0;
      loop(points,
        note(buff[zw]);
        startnoteoct[zw] = stnoteoctmp = noteoct;
        startnote[zw] = stnotemp = noten;
        zw += 1;
      );
    ):(
      startnoteoct[willstartnote] = stnoteoctmp = noteoct;
      startnote[willstartnote] = stnotemp = noten;
    );
    willstartnote = 0;
  );
  willdrawbox > 0 ? (
    willdrawbox = 0;
    drawbox();
  );
  willdrawdyn > 0 ? (
    willdrawdyn = 0;
    drawdyn();
  );
  
  mouse_capold > 0 ? willencode += 1;
  
  
  clickingc > 10 ? willshiftsel = 0;
  willshiftsel > 0 ? ( // Shift-click
    adragshift += 1;
    z = 1;
    willshiftsel == dragprev ? (
      multiselect[willshiftsel] = 0;
      multis -= 1;
      multis < 2 ? multiedit = 0;
      nearest();
    ):(
      multis = 0;
      loop(points,
        (willshiftsel > z && dragprevold > z) || (willshiftsel < z && dragprevold < z) ? (
          multiselect[z] = 0;
        ):(
          multiselect[z] = 1;
          multis += 1;
        );
        z += 1;
      );
      dragprev = willshiftsel;
    );
    multis > 1 ? (
      multiedit = 1;
      multisame();
    );      
    willshiftsel = 0;
    drawpoints();
    drawbox();
  );
//åå

  listchoose == 0 ? (
    listnostay = listcnt = choselistitem = 0;
  ):(
    listcnt = -1;
  );
  
  showbox == 0 ? dragprev = 0;
  
  forcedrag == 0 && dragtaken != 99 && dragtaken != 97 && help != 1 ? dragtaken = 0;
  dragtaken == 0 && (cap_mode != 49 || dragtaken != 49) && cap_timer >= 20 ? cap_mode = 0;
  showf == 2 ? showf = 0;
  dblclk == 0 ? dblclkshft = 0;
//  dblclk == -1 ? cap_mode = 0;
  oldrag = drag = nuclk =
  draggedw = draggedf = cap_drag =
  mouoffx = mouoffxw = mouoffy = boxdrag = clickold = oldrag = oldbox = added =
  gmemcnt = 0;

  showf == -1 ? showf = 0;
  nolist == 1 ? nolist = listchoose = 0;
  nolist == -1 ? nolist = 1;
  multiedit == -1 ? multiedit = 0;
//  dragstop > 0 ? dragstop -= 1;
  removing > 0 ? (
    rmo = ownpoints = 0;
    loop(points,
      bufl[rmo] == 0 ? ownpoints += 1;
      rmo += 1;
    );
    removing -= 1;
    upgraph += 1;
    
  );
  gmaster == 1 && gmem[color*100] == 0 ? gmem[color*100] = 1;
  dblstage <= 0 ? (
    dblstage = dblclk = dblcnt = dbltgt = 0;
//  dbltgt > 0 ? dblstage = -1;
  );
  moucmd = moushft = moualt = mourght = 0;
  
  
    mrqsel = 0;
  

):(   // Mouse Being Clicked

//  code_ver = 1;

  showf == 1 && mouse_cap == 1 ? showf = 2;

  dragtaken > 13 && dragtaken < 18 ? (
    listchooseold != istchoose ? listcnt = 0;
    listcnt == -1 ? nolist = 1;
  );
);


upslave > 0 && gmaster == 2 ? (
  upslave -= 1;
  upsliders();
  slider_automate(slider43);
  slider_automate(slider48);
  drawpoints();
  drawbox();
  upgrid += 1;
  upgraph < 10 ? upgraph += 1;
  
  
):(
  upslave = 0;
);


noob == 0 ? (
  multis = 0;
  z = 1;
  loop(points,
    multiselect[z] > 0 ? multis += 1;
    z += 1;
  );
  multis > 1 ? multiedit = 1;
  multis > 0 ? dragprev = forcedragprev3;
);



points == 0 ? (
  gfx_setfont(1);
  gfx_measurestr(-22.2,rmsw,0);

  gr = .7;
  pka = .8 *(1-helpa);
  rmsa = .6 * (1-helpa);
  pkthr = .00001;
  pkdecay = .01;
  pkacc = .05 *0;
//  pkhold = srate/1000 *    10  ; // ms
  pkhold = 20  ; // fps

  
  pkL_ > pkL ? (
    pkL = pkL_;
    pkLh = 0;
  ):(
    (pkLh += 1) > pkhold ? pkL -= pkdecay;
  );
  pkLdb = 19.93 * log10(pkL);
  pkL_ = outl;

  pkR_ > pkR ? (
    pkR = pkR_;
    pkRh = 0;
  ):(
    (pkRh += 1) > pkhold ? pkR -= pkdecay;
  );
  pkRdb = 19.93 * log10(pkR);
  pkR_ = outr;

  yy = topbar.h;
  
  xy(gfx_w - rmsw , yy);
  gfx_set(gr=.4,gr,gr,.6 * (1-helpa) );
  gfx_drawstr("Peak:",258,gfx_x,gfx_y);

  pkR > pkthr ? (
    gfx_set(1,gr,gr, pka);
    xy(xx = gfx_w - 3 , yy);
    gfx_drawstr( sprintf(#pkR,"%.1f",pkRdb) , 258,gfx_x,gfx_y);
  );
  pkL > pkthr ? (
    xy(xx - rmsw*.6 , yy);
    gfx_set(gr-.3,.9,1, pka);
    gfx_drawstr( sprintf(#pkL,"%.1f",pkLdb) , 258,gfx_x,gfx_y);
  );
  
  yy = topbar.h + gfx_texth;

  xy(gfx_w - rmsw , yy);
  gfx_set(gr=.4,gr,gr,.6 * (1-helpa));
  gfx_drawstr("RMS:",258,gfx_x,gfx_y);
  
  abs(rmsL-rmsR) > 3 ? (
    rmsR > -100 ? (
      gfx_set(1,gr,gr, rmsa);
      xy(xx = gfx_w - 3 , yy);
      gfx_drawstr( sprintf(#rmsR,"%.1f",rmsR) , 258,gfx_x,gfx_y);
      xy(xx - rmsw*.6 , yy);
      gfx_set(gr-.3,.9,1, rmsa);
    ):(
      xy(xx = gfx_w - 3 - rmsw*.2 , yy);
      gfx_set(gr,.9,1, rmsa);
    );
      
    rmsL > -100 ? (
      gfx_drawstr( sprintf(#rmsL,"%.1f",rmsL) , 258,gfx_x,gfx_y);
    );
  ):(
    rmsR > -100 || rmsL > -100 ? (
      xy(xx = gfx_w - 3 - rmsw*.2 , yy);
      gfx_set(gr+=.1,gr,gr, rmsa);
      gfx_drawstr( sprintf(#rmsLR,"%.1f", max(rmsL,rmsR) ) , 258,gfx_x,gfx_y);
    );
  );
);
    


// OLDS


old_w=gfx_wlim; old_h=gfx_h;
last_mouse_cap2 = last_mouse_cap;
last_mouse_cap = mouse_cap;
mouse_cap == 0 ? (
  dragstop = 0;
  clickingc = 0;
  pointing = 0;
  cap_modeold = cap_mode;
  slaved = 0;
  gmemc == 0 && help == 0 ? nocap = 0;
  
  listchooseold == 0 && listchoose == 0 && mouse_capold > 0 ? nolist = 1 : nolist = 0;
  willdrawpoints > 0 ? (
    willdrawpoints = 0;
    drawpoints();
  );
  
  willautomate > 0 ? (
    _willauto = willautomate;
    floor(willautomate) != willautomate ? (
      slider_automate(slider((willautomate-floor(willautomate))*100));
      willautomate = floor(willautomate);
    );
    slider_automate(slider(willautomate));
    willautomate = 0;
  );
  
  forceauto > 0 ? (
    willautomate = forceauto;
    forceauto = 0;
  );
  


):(
  mouse_cap == 1 && listchoose == 0 && listchooseold == 0 ? listfloat = 0;
);
mouxold = mouse_x;
mouyold = mouse_y;
autopoolold = autopool;
dragprevold = dragprev;
dragtakenold = dragtaken;
listchooseold = listchoose;
multieditold = multiedit;
preciseold = precise;
moualtold = moualt;
moucmdold = moucmd;
//gmemold >= 0 ? gmemold = gmem[0];
gmasterold = gmaster;
//mouse_capold = mouse_capold_tmp;
mouse_capold = mouse_cap;
noob < 10 ? noob += 1;

resetall > 0 ? (

  gmastertmp = gmaster;
//  memset(buff,0,tmpf-buff);
//  memset(buff,0,x1buf-buff);
  memset(buf_slo,-100,fftsize/2);
  
  rstn = 1;
  loop(maxpoints,
    bufw[rstn] = slider(3+(rstn-1)*4) = 1;
    bufl[rstn] = slider(4+(rstn-1)*4) = 1;
    multiselect[rstn] = 0;
    rstn += 1;
  );
  nozerof();
  volout = 0;
//  upsliders();
//  upauto();
//  eqini_all();
//  points = 0;

  resetall == 1 ? (
    rstz = color*100;
    rstlen = 90;
  ) :
  resetall == 2 ? (
    rstz = 0;
    rstlen = 1000;
  );
  
  loop(rstlen,
    gmem[rstz] = 0;
    rstz += 1;
  );
//  gmem[color*100] = -1;
  pointed = ownpoints = slider42 = slider49 = 0;
  gmaster == 1 ? (
    gmemold = mygmem = gmem[color*100] = 1;
  );

  noob = -1;
  slider48 = 1; // Volume Link
  slider_automate(slider42);
  slider_automate(slider48);
  slider_automate(slider49);
  slider_automate(slider63);
  
//  slider52 = 102.85;
//  slider60 = 0;
/*
  slider52 = floorstart = 108;
  lfloor = -slider52;
  slider60 = roofstart = -10.5;
  floordbup = floordbup2 = 0;
*/
  dblclk = 19; // Reset Analyzer zoom/scale

//  newpoints();
  slider63 = points = -1;


  resetall = -1;
):(
  resetall == -1 ? (
    resetall = 0;
//    newpoints();
    gmaster = gmastertmp;
    gmaster == 1 ? mygmem = gmem[color*100] = 1;
  );
);




/*
points == 0 && mrqw > 50 ? (
  addpoint(100);
//  addpoint(700);
//  addpoint(3500);
//  addpoint(8000);
//  upsliders();
//  drawpoints();
//  upmaster = 1;
);
*/


















/*
multi1 = multiselect[1];
multi2 = multiselect[2];
multi3 = multiselect[3];
multi4 = multiselect[4];


xpos1 = xpos[1];
xpos2 = xpos[2];
xpos3 = xpos[3];

xpos1strt = bufstartx[1];
xpos2strt = bufstartx[2];
xpos3strt = bufstartx[3];


byptmp1 = bufbyp[1];
byptmp2 = bufbyp[2];
byptmp3 = bufbyp[3];

buflm1 = buflm[1];
buflm2 = buflm[2];
buflm3 = buflm[3];

bufl1 = bufl[1];
bufl2 = bufl[2];
bufl3 = bufl[3];
*/



/*
GFX MAP:

ini
functions
draglim (f)

cappoint
dragpoint
reorder

db scale zoom
nozerof();

upgraph

cap_mode buttons

forcedragprev

upgrid
analyzer
eq db ruler
draw buttons (orig)

EQ info box
add point
doubleclick box

blit 2
Mouse frequency
listchoose
mouse_cap == 0
dblpointstage

Help
blink

olds



 */

/*
der1g = bufstartg[1];
der2g = bufstartg[2];
der3g = bufstartg[3];
der4g = bufstartg[4];


bufshape1 = bufshape[1];
bufshape2 = bufshape[2];
bufshape3 = bufshape[3];
bufshape4 = bufshape[4];
bufshape5 = bufshape[5];
bufshape6 = bufshape[6];
bufshape7 = bufshape[7];
bufshape8 = bufshape[8];

ypos1 = ypos[1];
*/



devmode == 1 ? (
 
  devx = devy = 51;
  devh = 28;
  devy0 = devy + devh;
  devw = gfx_w-102;
 
  dn = 0;
  loop(4,
    gfx_set(0,0,0,.9);
    gfx_rect(devx-1,devy-1+dn*(devh+4),devw+2,devh+2);
    gfx_set(1,.7,0,.6);
    gfx_rect(devx-1,devy-1+dn*(devh+4),devw+2,devh+2 ,0);
    dn += 1;
  );
    
 
  gfx_set(.1,.1,1,1);  
  devran = 10;
  dd = 0;
  dys = otherbufs;
  loop(devw *4,
    ds = floor(dd/devw);
    gfx_line(devx + dd - ds*devw,(devy0 +(ds*devh+4))-devh* (ceil(abs(dd[dys]))/devran)
     , devx+dd,devy0 + ds*(devh+4));
    
    dd += 1;
  );
    
  
  
  
  
);


devmode == 1 ? (
  gfx_setfont(1);
  devx = dbw*1.5;
  devy = gfx_h-gfx_texth*.9;
  devw = gfx_wlim - dbw*3;
  devh = gfx_h-devy;
  gfx_set(1,1,1,1);
  gfx_rect(devx,devy+gfx_texth*.1,devw,devh);
  gfx_set(.3,0,0,1);
  xy(devx+20,devy);
  gfx_drawnumber(mouse_x,0);
  gfx_x += gfx_wlim*.05;
  gfx_drawnumber(mouse_y,0);
  gfx_x += gfx_wlim*.05;
  gfx_drawnumber(drag,0);
  gfx_x += gfx_wlim*.05;
  gfx_drawnumber(dragtaken,0);
  
  sprintf( #istr, "%.2f", indb= log10(mtrin) *19.933);
  sprintf( #ostr, "%.2f", outdb= log10(mtrout) *19.933);
  sprintf( #iostr, "%.2f", diffdb = indb-outdb );
  gfx_measurestr( #istr , istrw,0);
  gfx_measurestr( #ostr , ostrw,0);
  gfx_measurestr( #iostr , iostrw,0);
  gfx_measurestr(#dbstr="dB",dbstrw,0);
  
  gfx_x = devx+devw-istrw-ostrw-iostrw-dbstrw*3-20;
  gfx_drawstr(#istr);
  gfx_drawstr(#dbstr);
  gfx_x += 10;
  gfx_drawstr(#ostr);
  gfx_drawstr(#dbstr);
  gfx_x += 10;
  gfx_drawstr(#iostr);
  gfx_drawstr(#dbstr);
  
);


code_ver < 2 && noob >= 10 && drag > 0 && last_mouse_cap > 0 ? (
  (codec += 1) > 10 ? code_ver = 2;
);

devmode > 0 ? (
  _dynthr1 = bufdynthr[1];
  _dynthr2 = bufdynthr[2];
  _dynena1 = bufdynena[1];
  _dynena2 = bufdynena[2];
  _dynknee1 = bufdynknee[1];
  _dynknee2 = bufdynknee[2];
  _dynattms1 = attms[1];
  _dynattms2 = attms[2];
  _dynrelms1 = relms[1];
  _dynrelms2 = relms[2];
  _dynatt1 = bufdynatt[1];
  _dynatt2 = bufdynatt[2];
  _dynrel1 = bufdynrel[1];
  _dynrel2 = bufdynrel[2];
  _dyncompg1 = compg[1];
  _dyncompg2 = compg[2];
  _bufm1 = bufm[1];
  
  _codebyp1 = bufbyp[1];
  _codebyp2 = bufbyp[2];
  _codebyp3 = bufbyp[3];
  _codesel1 = multiselect[1];
  _codesel2 = multiselect[2];
  _codesel3 = multiselect[3];
  _codebufshape1 = bufshape[1];
  _codebufshape2 = bufshape[2];
  _codebufshape3 = bufshape[3];
  _codebufshape4 = bufshape[4];
  _codebufshape5 = bufshape[5];
  _codebufshape6 = bufshape[6];
  _codebufm1 = bufm[1];
  _codebufm2 = bufm[2];
  _codebufm3 = bufm[3];
  _codebufm4 = bufm[4];
  _codebufm5 = bufm[5];
  _codebufm6 = bufm[6];
  _codesol1 = bufdynsol[1];
  _codesol2 = bufdynsol[2];
  _codesol3 = bufdynsol[3];
  _codesol4 = bufdynsol[4];
  _codesol5 = bufdynsol[5];
  _codesol6 = bufdynsol[6];
  _codesol7 = bufdynsol[7];
  _codesol8 = bufdynsol[8];
  _codesol9 = bufdynsol[9];
  _codesol10 = bufdynsol[10];
);



/*
BLITS / DESTINATIONS / CHEAT SHEET

1 
2 EQ Graph
3 Hor Grid
4 Shape images
5 box
6 points
7 Vert Grid
8 Top Bar
9 Analyzer (tmp?)
10 Dynamics


