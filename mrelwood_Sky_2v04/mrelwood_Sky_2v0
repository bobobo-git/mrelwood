desc: Sky 2.04  [mrelwood]

// FIX: Flashlight shade








// (Copyright) 2018 - mrelwood plugins
//
//  This program is a free software plugin: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This plugin is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//  <https://www.gnu.org/licenses/>.



// Includes code from Tilt EQ by Liteon:

// (C) 2009, Lubomir I. Ivanov

// NO WARRANTY IS GRANTED. THIS PLUG-IN IS PROVIDED ON AN "AS IS" BASIS, WITHOUT
// WARRANTY OF ANY KIND. NO LIABILITY IS GRANTED, INCLUDING, BUT NOT LIMITED TO,
// ANY DIRECT OR INDIRECT,  SPECIAL,  INCIDENTAL 
OR CONSEQUENTIAL DAMAGE ARISING
// OUT OF  THE  USE  OR INABILITY  TO  USE  THIS PLUG-IN,  COMPUTER FAILTURE  OF
// MALFUNCTION INCLUDED.  THE USE OF THE SOURCE CODE,  EITHER  PARTIALLY  OR  IN
// TOTAL, IS ONLY GRANTED,  IF USED IN THE SENSE OF THE AUTHOR'S INTENTION,  AND
// USED WITH ACKNOWLEDGEMENT OF THE AUTHOR. FURTHERMORE IS THIS PLUG-IN A  THIRD
// PARTY CONTRIBUTION,  EVEN IF INCLUDED IN REAPER(TM),  COCKOS INCORPORATED  OR
// ITS AFFILIATES HAVE NOTHING TO DO WITH IT.  LAST BUT NOT LEAST, BY USING THIS
// PLUG-IN YOU RELINQUISH YOUR CLAIM TO SUE IT'S AUTHOR, AS WELL AS THE CLAIM TO
// ENTRUST SOMEBODY ELSE WITH DOING SO.
// 
// Released under GPL:
// <http://www.gnu.org/licenses/>.




slider1:0<-30,0,0.01>-Sky is The Limit
slider2:0<0,100,0.1>-Character
//slider3:9<7,11,1>-Buffer 7=128, 8=256, 9=512 ...
slider4:1<1,3,0.1>-In Comp THR
slider5:1<1,3,0.1>-BufTHR
//slider7:0<0,1,0.01>-Meter
slider12:0<-6,6,0.1>-Brightness
slider20:-0.1<-9,0,.1>-Ceiling (-dB)
//slider30:25<250,1000,1>-Buffer Size (ms)
slider31:0<0,1,1>-Look Ahead
slider32:0<0,1,1>-Link Threshold & Volume

slider3 = 9;
slider4 = 1;
slider5 = 1;
slider7 = 0;
slider30 = 25;

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output
out_pin:3. output
out_pin:4. output

options:no_meter


@init
ver = "2.04";

nooba = 1;
 
bufSize = 512;
brakelim = ing = ingS = inhold = gbuflim = g2buflim = g3 = tranflt = 1;
gainL = gainR = 1;
inflt = 0;

gfx_ext_retina = 1;
ext_noinit = 1;

upall = drawall = uptilt = upslider = 1;

log2db = 8.656170246;
db2log = 0.11512925464970228420089957273422; 
mix=1;
gr_meter=1;
gr_meter2=1;

gr_meter_decay = exp(1/(1*srate));

rmstime = floor(    1000    * srate/1000);
rmsfreq = 12;
rmslen = floor((rmstime)/rmsfreq + 0.5);


pdc_delay = bufSize;

rmspos = rmspos_ = 0;
rmsgo = 0;
rmsisum = 0;
rmsosum = 0;

state = 0;


amp = 6/log(2);
sr3 = 3*srate;
bias = 80;

pbot = 1;
st = 1;

// Buffers:
mtry = 2000;
rmsibnk = 2200;
rmsobnk = rmsibnk + rmstime;




@serialize

store_01 = file_var(0, noob);
store_02 = file_var(0, sawtype);



@slider
@block



slider31 == 0 ? (
  pdc_delay = bufSize = 512;
  bufOffs = bufSize + 1;
  pdc_bot_ch=2; pdc_top_ch=0;
  ):(
  pdc_delay = bufSize = 0;
  bufOffs = bufSize + 1;
  pdc_bot_ch=0; pdc_top_ch=0;
  );

//pdc_delay = 0;


rmsibnk = 48000;
rmsobnk = rmsibnk + rmstime;



upslider == 1 ? (
  upslider -= 1;

  inboost = 2^((-slider1)/6);
  
  
  
  
  
  cutoff = 20;
  
  cx = 2*cutoff/srate;
  cpi = $pi*cx;
  fk = 0.67*sin(cpi);
  c1 = 0.5*(1 - fk)/(1 + fk);
  c2 = (0.5 + c1)*cos(cpi);
  c3 = (0.5 + c1 + c2)*0.25;
  hpa0 = 2*c3;
  hpa1 = -4*c3;
  hpa2 = 2*c3;
  hpb1 = -2*c2;
  hpb2 = 2*c1;
  
  
  st = slider1;

  );



distx = slider2/100;
distxtlt = distx *1;
distxin = distx *1;
distxco = distx^0.7 *1;
distxms = distx^0.5 *2;
distxg2 = distx^0.5 *1; // Post comp (not in use)
distxg3 = distx *1 *0; // Post buffer (not in use)
distxout = distx^1.5 *1 *0;

ms=2;
  
//inboost = 2^((-slider1)/6);

m_clip = 0.999;

uptilt = 1;
startup <= 1 ? uptilt = 1;
uptilt == 1 ? (
  uptilt = 0;
  tlt_pls = min(1, abs(slider1)/20)^1.5 * 0.0 + distxtlt * 0.2 * min(1, -slider1/2) ;
  tlt_gain = slider12 + tlt_pls;
  tltmulti = max(0, tlt_gain-1);
  tlt_gain >= 0 ? (
    gfactor = 1.4 - tlt_gain/10;
    g1 = -gfactor*tlt_gain ;
    g2 = tlt_gain;
    ) : (
    gfactor = 10;
    g1 = -tlt_gain*1.2 ;
    g2 = gfactor*tlt_gain;
    );
    lgain = exp(g1/amp)-1;
  hgain = exp(g2/amp)-1;
        tlt_gain > 0 ? (tiltf = 0.5 + tlt_gain/3):(tiltf = 0.09);
  
  tf = floor(tiltf*1000);
    tomega = 2*$pi*tf;
  tn = 1/(sr3 + tomega);
  tgt_ta0 = 2*tomega*tn;
  tgt_tb1 = (sr3 - tomega)*tn;
  
  
//  tiltboost = max(1,tlt_gain/10 +1) * 1/(min(0,tlt_gain)/(-40)+1);
  tiltboost = 1;


  
  // NEW TILT ////////
  freqLPinc = 100;
  xLPinc = exp(-2.0*$pi*freqLPinc/srate);
  a0LPinc = 1.0-xLPinc;
  b1LPinc = -xLPinc;
  
  freqHPinc = 12000;
  xHPinc = exp(-2.0*$pi*freqHPinc/srate);
  a0HPinc = 1.0-xHPinc;
  b1HPinc = -xHPinc;
  ////////////////////

  );
  



  d_ta0 = (tgt_ta0-src_ta0)/samplesblock;
  ta0 = src_ta0;
  src_ta0 = tgt_ta0;
  d_tb1 = (tgt_tb1-src_tb1)/samplesblock;
  tb1 = src_tb1;
  src_tb1 = tgt_tb1;






outvol = 2^(slider20/6);


starsblocnt += 1;
starsblocnt > (srate/samplesblock/2) ? (
  movestars = 1;
  starsblocnt = 0;
);




@sample

inL = spl0;
inR = spl1;

rmsiinavg = (abs(spl0)+abs(spl1))/2;
rmsiinmax = max(abs(spl0), abs(spl1));
rmsiin = (rmsiinavg *3 + rmsiinmax)/4;




ta0 += d_ta0;
tb1 += d_tb1;


tlt_gain != 0 ? (

  tltmode = 2;

  tltmode == 2 ? (
    s0inc = spl0;
    s0incR = spl1;
    
    LPinc =  (tmplLPinc = a0LPinc*s0inc - b1LPinc*tmplLPinc );
    LPincR = (tmplLPincR = a0LPinc*s0incR - b1LPinc*tmplLPincR );
    HPinc = s0inc - (tmplHPinc = a0HPinc*s0inc - b1HPinc*tmplHPinc );
    HPincR = s0incR - (tmplHPincR = a0HPinc*s0incR - b1HPinc*tmplHPincR );

    spl0 = s0inc + LPinc* (max(0,-tlt_gain/6)^1.5 + max(0,tlt_gain/6)^2 /9)
     + HPinc * (tlt_gain/6 + max(0,tlt_gain*0.6) );
    spl1 = s0incR + LPincR* (max(0,-tlt_gain/6)^1.5 + max(0,tlt_gain/6)^2 /9)
     + HPincR * (tlt_gain/6 + max(0,tlt_gain*0.6) );
    spl0 *=  min(0, tlt_gain)/30 +1;
    spl1 *=  min(0, tlt_gain)/30 +1;
    );
  );


meterposttilt = 0;
meterposttilt == 0 ? (
  mtrisrcL = inL;
  mtrisrcR = inR;
  ):(
  mtrisrcL = toutl;
  mtrisrcR = toutr;
  );
meter_l_run = abs(mtrisrcL);
meter_r_run = abs(mtrisrcR);
meter_mid_run = (abs(mtrisrcL+mtrisrcR))/2;

meter_l_pk = max(meter_l_pk , meter_l_run);
meter_r_pk = max(meter_r_pk , meter_r_run);
meter_mid_pk = max(meter_mid_pk , meter_mid_run);





det_inl = toutl;
det_inr = toutr;


cutoff > 0 ? (
  hpl = hpa0*det_inl + hpa1*meml1 + hpa2*meml2 - hpb1*meml3 - hpb2*meml4;
  meml2 = meml1;
  meml1 = det_inl;
  meml4 = meml3;
  meml3 = hpl;
  hpr = hpa0*det_inr + hpa1*memr1 + hpa2*memr2 - hpb1*memr3 - hpb2*memr4;
  memr2 = memr1;
  memr1 = det_inr;
  memr4 = memr3;
  memr3 = hpr;
  ):(
  hpl = toutl;
  hpr = toutr;
  );










ms = 2
//ms = 0
;
inmax = max(abs(spl0),abs(spl1)) ;
ms > 0 ? inmaxS = ( abs(spl0 - spl1) /2)^0.55 * 1.05;



//ms == 0 ? inmax = max(abs(spl0),abs(spl1)) ;


indir = (inmax-inmaxold);
inmaxold2 = inmaxold;
inmaxold = inmax;
//inthr = 1.2 + distxin*0.15 *1; 
inthr = 1.0 + ing *0.3   + distxin^0.5 *0.3 *1; 
//inthr = 1.0 + distxin^0.35 *0.2 *1; 

inflt < inmax ? inflt = inmax;
inflt < 0.0000000001 ? inflt = 0.0000000001;


(inmax/inflt) < 0.9 ? (
  fltrelcnt < 100 ? fltrelcnt *= 1.01;
//  fltrelcnt < 100 ? fltrelcnt *= 1.05;
  ):(
  fltrelcnt = 1;
  );

//inflt /= max(0, 1- inmax/inflt) * 0.07 * fltrelcnt * inflt +1;
inflt /= max(0, 1- inmax/inflt) * 0.1 * fltrelcnt * inflt +1;

inboost_ = inboost / 2 + 0.5;
zerolatency == 2 ? (
  spl0 *= inboost_;
  spl1 *= inboost_;
  ):(
  spl0 *= inboost ;
  spl1 *= inboost ;
  );





//inflt = 1;

infltbst = inflt * inboost;
inmaxbst = inmax * inboost;
fltdir = inflt-infltold;
infltold = inflt;
ingold = ing;

// Mid and side:
inatt = 0.1 / (distxco+1);
//inrel = 0.00005 + distxco * 0.0001;
inrel = 0.00002 + distxco * 0.0001;
//inrel = 0.00002 + distxco * 0.00001;
inattS = inatt / (distxms+1);
inrelS = inrel + distxms * 0.0001;

inovr = max( 0, (infltbst*ing) - inthr);

//(infltbst*ing) > inthr ? (

ingmode = 4;

ingmode == 4 ? (

// NEW TRANSIENT KILLER

  tranin = inmax * inboost;


  // Float Attack
  tranflt *=  max(0, (tranin/tranflt)^1 -1)  *0.1 +1;
  tranin > tranflt ? (
    trancnt = 0;
    ):(
    trancnt += 1;
    );
  
  // Float Release
  tranflt /= 0.0000001 * trancnt^1.5 * max(0, (tranflt-tranin)^2 )   +1;
  tranflt < 0.01 ? tranflt = 0.01;
  tranflt > 20 ? tranflt = 20;



// SIMPLER TRANSIENT KILLER

  indirtran = (max(0, indir - 0.15 ) *8 )^1;
  inmaxtran = ( (indirtran +1) * max(0, inmax-inmaxold2 - 0.2) *6 )^1;
  tran_ = (indirtran + inmaxtran) / ( max(0, indirtran + inmaxtran -1) *0.5 +1);
  trang /=  tran_ * trang^1 *  inmaxbst * 0.1 +1;
  trang *= (0.003/trang) * (1-trang^2) +1;
  indirold = indir;

  trang < 0.01 ? trang = 0.01;
  trang > 1 ? trang = 1;
trang = 1; // tmp

  infltbst *= trang;
  inmaxbst *= trang;

// Compressor

//  ingthr = 1 + distxco * 0.1 *1;
//  ingran = 1.6  -ingthr + distxco * 0.2 ;

  ingthr = 1;
  ingran = ingthr *0.2;

  ingovr = max( 0, (inmaxbst ) - ingthr);
  ingref = ( ingthr + (inmaxbst * ingran) / ( inmaxbst + ingran)) / inmaxbst; // ing_dir = max(-0.125, dir)
  ingref > 2 ? ingref = 2;

  ingrdir = ingref - ingrold;
  ingrold = ingref;

  ing /= max(0, -ingrdir) * (ing/ingref)^8  +1;

  ingrel = ( (0.000007 + distxco^2 * 0.0001) /ing^ (4 - (-slider1/30)^1 * 2.8) ) * max(0, ingref/ing -1) +1;
  ing *= ingrel;
  ing2 = ing;


  );

ing = 1;

ing > 1 ? ing = 1;  ing < 0.01 ? ing = 0.01;





ms == 0 ? (
  spl0 *= ing * trang;
  spl1 *= ing * trang;
  );



ingout = max(abs(spl0),abs(spl1));



ms == 1 ? (
  inthrS = inthr * (0.9 + distxms * 0.4) ;

  infltS < inmaxS ? infltS = inmaxS;
  
  (inmaxS/infltS) < 0.9 ? (
    fltSrelcnt < 100 ? fltSrelcnt *= 1.01;

    ):(
    fltSrelcnt = 1;
    );
  infltS /= max(0, 1- inmaxS/infltS) * 0.07 * fltSrelcnt * infltS +1;
  
  infltSbst = infltS * inboost;
  inmaxbstS = inmaxS * inboost;
  fltSdir = infltS-infltSold;
  infltSold = infltS;
  ingSold = ingS;

  
  (infltSbst*ingS) > inthrS ? (
    ingS /= ( 0.1 * max(0, (infltSbst * ingS)-inthrS ) + 0.05 * max(0, (infltSbst * ingS)/inthrS -1) ) * (0.2/(distxms+1)) +1;
    ):(
    //ingS *= (0.003  + distxin * 0.001) * max(0, 1-ingS^2) * max(0, 1-(inout)^3) * max(0, 1-infltS) +1;
    ingS *= (0.00005 + distxms * 0.0001) / ingS * max(0, 1-inout^3) * max(0, 1-(inout)^2)  +1;    
    );


  ingS > 1 ? ingS = 1;  ingS < 0.01 ? ingS = 0.01;
  ingS < ing ? ing = ingS;
  inlink = 0.6 * 0 ;
//  inlink = 1;
  ingMIN = min(ing, ingS);
  ing_MS = 1-( inlink * (1-ingMIN) + (1-inlink) * (1-ing) );
  ingS_MS = 1-( inlink * (1-ingMIN) + (1-inlink) * (1-ingS) );

  inM = (spl0 + spl1) /2;
  inS = (spl0 - spl1) /2;

  inM *= ing_MS;
  inS *= ingS_MS;
  
  spl0 = inM + inS;
  spl1 = inM - inS;

  );
  





ms == 2 ? (
  ingmode != 4 ? (

    infltS < 0.0000000001 ? infltS = 0.0000000001;
  //  noob < 2 ? infltS = 0.00000001;
  
    inthrS = inthr + distxms * 0.2 ;
  
    infltS < inmaxS ? infltS = inmaxS;
    
    (inmaxS/infltS) < 0.9 ? (
  //    fltSrelcnt < 100 ? fltSrelcnt *= 1.01;
      fltSrelcnt < 100 ? fltSrelcnt *= 1.05;
  
      ):(
      fltSrelcnt = 1;
      );
    infltS /= max(0, 1- inmaxS/infltS) * 0.07 * fltSrelcnt * infltS +1;
    
    
    
    infltSbst = infltS * inboost;
    inmaxbstS = inmaxS * inboost;    
    fltSdir = infltS-infltSold;
    infltSold = infltS;
    ingSold = ingS;
    
    
    (infltSbst*ingS) > inthrS ? (
  //    ingS /= ( 0.1 * max(0, (infltSbst * ingS)-inthrS ) + 0.05 * max(0, (infltSbst * ingS)/inthrS -1) ) * (0.2/(distxin+1)) +1;
      ingS /= ( 0.6 * max(0, (infltSbst * ingS)-inthrS ) + 0.3 * max(0, (infltSbst * ingS)/inthrS -1) ) * (inattS) +1;
      ):(
      ingS *= (inrelS ) * max(0, 1-ingS^2) * max(0, 1-(inout/(1/inthrS))^3) * max(0, 1-infltS) +1;
      );
    );
  









  
  ingmode == 4 ? (

  
    ingSthr = 1 + distxco * 0.1 + distxms * 0.1;
    ingSran = 1.6  -ingSthr;
    inmaxbstS = inmaxS * inboost;
    
  
    ingSovr = max( 0, (inmaxbstS ) - ingSthr);
  
  
    ingSref = ( ingSthr + (inmaxbstS * ingSran) / ( inmaxbstS + ingSran)) / inmaxbstS; // ingS_dir = max(-0.125, dir)
    ingSref > 2 ? ingSref = 2;
  
    ingSrdir = ingSref - ingSrold;
    ingSrold = ingSref;
  
    ingS /= max(0, -ingSrdir) * (ingS/ingSref)^8  +1;
  
    ingS *= ( (0.00001 + distxco^2 * 0.0001) /ingS^ (4 - (-slider1/30)^1 * 2.8) ) * max(0, ingSref/ingS -1) +1;
  
    inmaxS == 0 ? ingS = 1;

    );
  

  ingS > 1 ? ingS = 1;  ingS < 0.01 ? ingS = 0.01;
  ingS < ing ? ing = ingS;
  inlink = 0.7 - distxms^0.5 * 0.5 ;
//    inlink = 0.0;
//    inlink = 1;
    ingMIN = min(ing, ingS);
  ing_MS = 1-( inlink * (1-ingMIN) + (1-inlink) * (1-ing) );
  ingS_MS = 1-( inlink * (1-ingMIN) + (1-inlink) * (1-ingS) );

  inM = (spl0 + spl1) /2;
  inS = (spl0 - spl1) /2;

  inM *= ing_MS;
  inS *= ingS_MS;
  
  spl0 = inM + inS;
  spl1 = inM - inS;

  );


testdimmer = 1;
testdimmer != 1 ? (
  spl0 *=  testdimmer;
  spl1 *=  testdimmer;
  );



zerolatency == 1 ? (
  spl0 *= brakelim;
  spl1 *= brakelim;
  
  gzero = 1 + min(1, -slider1/30) * 0.1  + 1;
gzero = 1; // tmp
  spl0 *= gzero;
  spl1 *= gzero;

  );

inout = max(abs(spl0),abs(spl1));
inout_ = inout;



// v 1.11 midlimiter
midlimiter = 1;

midlimiter == 1 ? (
  zerolatency == 0 ? (
  
    g2mode = 2;
    
    g2mode == 1 ? (
  
      thrbuflim = 1
       + distxg2^0.4  ;
      ranbuflim = 0.6;
      (inout ) > (thrbuflim) ? (
        ovrbuflim = max(0, inout - thrbuflim);
        gbuflim = (thrbuflim + ovrbuflim * (ranbuflim/ (ovrbuflim + ranbuflim) )) / inout;

        attbuflim += 0.005;
  
        attbuflim > 0.99 ? attbuflim = 0.99;
        attbufcnt = 1;
        ):(
        attbufcnt *= 0.0001 +1;
        attbufcnt > 10 ? attbufcnt = 10;
        attbuflim /= (attbufcnt-1) * 0.001 +1;
        attbuflim > 1 ? attbuflim = 1;
        );
  
      gbufdir = gbuflim-gbuflimold;
      gbuflimold = gbuflim;
  
      g2buflim_ = max(0, -gbufdir  ) * min(1,(g2buflim/gbuflim)^3) * (g2buflim * inflt)   ;
      g2buflim /= max(0, g2buflim/gbuflim -1) * attbuflim +1;
      g2buflim *= ( (0.00001*(distxg2+1))/g2buflim) * (1-g2buflim^10) * min(1, gbuflim) +1;
      );








    g2mode == 2 ? (
  
      thrbuflim = 1.3
       + distxg2^0.4 * 0.1  ;
      ranbuflim = 0.15 + distxg2^0.4 * 0.1 ;
      (inout ) > (thrbuflim) ? (
        ovrbuflim = max(0, (inout ) - thrbuflim);
        gbufref_ = (thrbuflim + ovrbuflim * (ranbuflim/ (ovrbuflim + ranbuflim) )) ;
        gbufref = gbufref_ / inout;
        ):(
        gbufref_ = inout;
        gbufref = ovrbuflim = 1;
        );

      gbufdir = gbufref-gbufrefold;
      gbufrefold = gbufref;

      
      g2buflim_ /=  1 * max(0, -gbufdir  )  * min(1,(g2buflim_/gbufref)^20 )  +1;
  // Release
      g2buflim_rel = ( (0.00002*(distxg2*0.5+1)) /g2buflim_^2 ) * (1-g2buflim_^10)  +1;
      g2buflim_ *= g2buflim_rel;

      g2buflim_ < 0.01 ? g2buflim_ = 0.01;
      g2buflim_ > 1 ? g2buflim_ = 1;

      g2buflim_dir = g2buflim_ - g2buflim_old;
      g2buflim_old = g2buflim_;

      g2buflimdir < 0 ? (  
        attbufdir = max(attbufdir , -g2buflim_dir *0.05) ;
        ):(
        attbufdir -= 0.0000003;
        attbufdir < -0.01 ? attbufdir = -0.01;
        );
      attbuflim *= attbufdir +1;
      attbuflim < 0.01 ? attbuflim = 0.01;
      attbuflim > 1 ? attbuflim = 1;
      g2buflim_ < g2buflim ? (
        g2att *= 1.0003;
        g2att > 2 ? g2att = 2;
        g2buflimdec = min(1,(g2buflim/g2buflim_)^3) * (g2att -1) +1  ;
        g2buflim /= 0.003 * (g2att -1)^2 * (g2buflim/g2buflim_ -1) +1;








        );
      g2buflim < g2buflim_ ? (
        g2att -= abs(g2buflim_ - g2buflim) * 10 + 0.000001;
        g2att < 1 ? g2att = 1;
        g2att = 1;
//        g2buflimrel = ( (0.00003*(distxg2+1))/g2buflim) * (1-g2buflim^10) * min(1, gbufref)  +1;
        g2buflim *= g2buflim_rel;
        );

      g2buflimdir = g2buflim - g2buflimold;
      g2buflimold = g2buflim;
      

      );





    ):(

    zeromode = 4;
    zeromode == 1 ? (
//      brakelim = 1;
      thrbuflim = 0.9;
      ranbuflim = 0.1;
      
      attspd = max(0, inout/inoutold -1) * max(0, inout-0.1);
      inoutold = inout;
      ovrbuflim = max(0, inout/thrbuflim -1);
      
      gbufdir < 1 ? (
        g2buflim /= max(0, -gbufdir+1) * ( g2buflim/gbuflim)^6 * gbuflim +1;
        );

      inout > thrbuflim ? (
        gbuflim = (thrbuflim + ovrbuflim * ( ranbuflim / ( ovrbuflim + ranbuflim)) ) / inout;
        ):(
        gbuflim = 1;
        );

      gbuflim < g2buflim ? ( 
        g2buflim *= (gbuflim/g2buflim -1) *0.2 +1;
        ):(
        g2buflim *= max(0, 1-attspd)^2 * (0.0002 / g2buflim) * (gbuflim/g2buflim-1) +1;
        );

      brakelim = g2buflim;

      
      
      
      gbufdir = gbuflim-gbuflimold;
      gbuflimold = gbuflim;
        
      gbuflim > 1 ? gbuflim = 1;



      );




    zeromode == 2 ? (
      thrbuflim = 0.9;
      ranbuflim = 0.99 - thrbuflim;

//      brakelim = 1;
      
      ovrbuflim = max(0, (inout*g2buflim)/thrbuflim -1);
      
      gbuflim = (thrbuflim + ovrbuflim * (ranbuflim/ (ovrbuflim + ranbuflim) )) / inout;

      gbufdir = gbuflim-gbuflimold;
      gbuflimold = gbuflim;
      
      gbuflim < 1 ? (
        g2buflim *= min(1, gbuflim/g2buflim);
        g2buflim /= max(0, g2buflim/gbuflim )^10 * g2buflim * max(0, -gbufdir) *1 +1;
//        g2reldel = 1.00001;
        g2reldel = 1;
        ):(
//        g2reldel *= (g2reldel-1) *0.4 +1;
        g2reldel += 1;
        );
      g2reldel < 0 ? g2reldel = 0;
      g2reldel > 1000 ? g2reldel = 1000;
//      g2rel = 0.000005;
//      g2rel *= g2reldel * 0.1 +1;
      g2buflim *= ( (g2reldel^3*0.000001)/g2buflim) * (1-g2buflim^6) * max(0, 1- g2buflim/gbuflim)^1 * max(0,1-zerout^10) +1;

      brakelim = g2buflim;
      );




    zeromode == 3 ? (
      brakelim = 1;
      thrbuflim = 0.8 ;
      ranbuflim = 0.1;
      ovrbuflim = max(0, inout-thrbuflim)/ranbuflim;
      inout > thrbuflim ? (
        gbuflim = thrbuflim + ovrbuflim * ( ranbuflim / ( ovrbuflim + ranbuflim));
        g2buflim = gbuflim/inout;

        g2reldel -= 10;
        g2rel = 1.00001;
        ):(
        g2rel *= 1.000001;
        gbuflim = g2buflim = 1;
        );

      g2reldel < 0 ? g2reldel = 0;
      g2reldel > 1000 ? g2reldel = 1000;
//      g2rel *= g2reldel * 0.01 +1;
//      g2rel *= g2reldel * 0.01;
      g2buflim < 1 ? (
        brakelim *= ( g2buflim -1) *1 +1;
        ):(
        brakelim *= (g2rel-1) * (1-brakelim^4) * max(0,1-zerout^100)  +1;

        );
      brakelim < 0.01 ? brakelim = 0.01;
      brakelim > 1 ? brakelim = 1;
      );










    zeromode == 4 ? (

      // Comp
//      zin = zflt * zgt;
      zin = inout ;
      zthr = 0.9;
      zran = 0.09;
      zovr = max(0, zin -zthr );
      
      zovr > 0 ? (
        zg_ = (zthr + zovr * ( zran / ( zovr + zran ))) / zin;
        
//        zg = ( zthr + ran * sin( min(1.57 , (zin-zthr)/zran ))) / zin;
        ):(
        zg_ = 1;
        );
      
      zg_ < zg ? (
        zg *= (zg_/zg -1) * zg_ +1;
        zgcnt = 0;
        ):(
        zgcnt += 1;
      
        zg *= 0.000000001 * zgcnt^1.5 * (1-zg^2) * max(0, 1-zerout^3)  +1;
        );
      zg_ = 1;
      zg < 0.01 ? zg = 0.01;
      zg > 1 ? zg = 1;

      // Float top
      zflttin = inout * zgt * zg;
      zflttin > zfltt ? (
        zfltt *= (zflttin/zfltt-1) * zflttin +1;
        zflttcnt = 0;
        ):(
        zflttcnt += 1;
        zfltt /= 0.0000001 * zflttcnt^1.5 * max(0, (zfltt-zflttin)^2 ) * max(0, 1-zerout)  +1;
        );
        
      
      zfltt < 0.01 ? zfltt = 0.01;
      zfltt > 10 ? zfltt = 10;
      
      

      // Lim
      zlin = zfltt;
      zlthr = 0.4;
      zlran = 0.2;
      zlovr = max(0, zlin/zlthr -1);
      
      zlovr >= 0 ? (
        zlsin = sin( min(1.57 , zlovr/(zlran))) ;
        zlg_ = (zlthr + zlsin * zlran) / zlin;
        
        zlg_ > 1 ? zlg_ = 1;
              
        );

      zlg_dir = zlg_ - zlg_old;
      zlg_old = zlg_;
      
      zlg_ < zlg ? (
        zlg *= (zlg_/zlg -1) * zlg_ +1;
        zlgcnt = 0;
        ):(
        zlgcnt += 1;

        zlg *= 0.000000001 * zlgcnt^1.5 * (1-zlg^2) * max(0, 1-zerout^3)  +1;

        );

      zerout >= (zlthr + zlran) ? zlg /= zerout/(zlthr + zlran);
                  
      zlg < 0.01 ? zlg = 0.01;
      zlg > 1 ? zlg = 1;
      
      
      
      
      g2buflim = zg * zgt * zlg;
      g2buflim = 1 ; // tmp

      );

    );

  g2buflim > 1 ? g2buflim = 1;
  g2buflim < 0.01 ? g2buflim = 0.01;
//g2buflim = 0.5;
  spl0 *= g2buflim ;
  spl1 *= g2buflim ;


  );



tmpvol1 = 1
; tmpvol1 == 1 ? (
  tmpg = 1.0 + g3 *0 +  min(0.0, (-slider1/6)^0.5) + distxg2^0.25 *0.05 *1  ;
  spl0 *= tmpg;
  spl1 *= tmpg;
  );


bufin = max(abs(spl0),abs(spl1));


zerolatency == 1 ? (
  
  spl0 *= brickfb;
  spl1 *= brickfb;
  
  zerout = max(abs(spl0),abs(spl1));
  
  
  
  genemode == 0 ? (
    gene -= 0.01;
  //  brick = 1;
  //  brickfb = 1;
    gene <= 0 ? genemode = 1;
    );
  
  genemode == 1 ? (
    gene += 0.01;
    gene >= genmax ? (
      genemode = 0;
      genmax += 1;
      genmax > 3 ? genmax = 1;
  
      );
    );
  

  
  zerolatency == 1 ? (
    inbrick = (zerout);

    ranbrick = 0.09;
    thrbrick = 0.9;
    ovrbrick = max(0, inbrick-thrbrick);


    envbrick += max(0, inbrick - envbrick);
    
    envdir = envbrick-envold; 

    envdir > 0 ? (
      envcnt = 0.999;
      ):(
      envcnt *= 0.0001 / max(0.001, 1-envbrick)   +1;
      envbrick /=  max(1, envcnt)  ;
      );

    envbrick += max(0, indir) * max(0, 1- max(0, envbrick-inbrick))^10  *0.1;
    envbrick += max(0, inbrick - envbrick);

    envold = envbrick;




    
    envmode = 3;
    envmode == 1 ? (
      inbrick >= 0.8 ? (
        multibrick = max(multibrick , max(1, inbrick/2 +0.6) -0.1);
    //    multibrick = 0.5;
        ):(
        multibrick > 0 ? (multibrick -= 0.01);
        );
      brick = ( sin(inbrick/multibrick)  ) / inbrick;
      );
    
    envmode == 3 ? (
      inbrick = envbrick;
      envmode = 2;
      );
    
    
    
    
    
    envmode == 2 ? (
      sinbrick = sin(inbrick / (thrbrick + ranbrick))  * (thrbrick + ranbrick);
      multibrick = min(1, inbrick/(1.57 * (thrbrick + ranbrick)))^1;
      multi1brick = max(0, (inbrick-thrbrick)/(1.57-thrbrick))^1;
      multi1brick > 1 ? multi1brick = 1;
      multi1brick = sin(multi1brick^0.5 *3.14 - 1.57) / 2 +0.5;
      brick = ( (multibrick)^0.5 * 1  + max(0, 1-multibrick^0.5 ) * (inbrick) ) / (inbrick);
      
      brickfbatt = min(1, multi1brick ) * (multibrick ) * 0.1 ;
      inbrick > thrbrick ? (
        brickfb /=  (multi1brick * 0.57)^2 * 1 +1; 
        ):(
        brickfb *= (0.000 + 0.0001/brickfb^3) *(1-brickfb^6) * max(0, 1- zfltt)^2 +1;
        pooo += 1;
        );
      );  


 
 
  
    );
  inbrick1 > 1 ? inbrick1 = 1;
  inbrick1 < 0.01 ? inbrick1 = 0.01;
  
  brickfb > 1 ? brickfb = 1;
  brickfb < 0.1 ? brickfb = 0.1;
  brick > 1 ? brick = 1;
  brick < 0.1 ? brick = 0.1;
  
  spl0 *= brick;
  spl1 *= brick;
  








  
  
  
  

  in3 = max(abs(spl0),abs(spl1));
    

  thr3 = 0.95;
  ran3 = 0.99-thr3;
  ovr3 = max(0, (in3*g3)/thr3 -1);
  
  g3_ = (thr3 + ovr3 * ( ran3 / ( ovr3 + ran3)) ) / in3;
  g3_ > 2 ? g3_ = 2;
//g3_ > 1 ? g3_ = 1;
  
  g3mode = 4;
  g3mode == 1 ? (
    dirg3_ < 1 ? (
    //    g3 /=  max(0, 1- (g3_/g3 -1) )^6 * max(0, 1- dirg3_) *0.1 * (in3*g3)^10 +1;
      g3 /=  max(0, 1- (g3_/g3 -1) )^1  *0.1 * (in3*g3)^10 +1;
      g3_ < g3 ? g3 = g3_;
      rel3 = 1.00003;
      ):(
      rel3 *= 1.000001;
      g3 *= ((rel3-1) / g3) * (1-g3^2) * max(0, 1-in3*g3)^0.1 +1;
      );
    );

  g3mode == 2 ? (
    dirg3_ < 1 ? (
      g3 *= max(0, g3/g3_-1) * min(1, max(0, 1- dirg3_)) +1;
      g3 /= max(0, min(1, 1-(g3_/g3-1)))^6 * 0.02 * max(0, min(1, 1-dir3g_))^3 +1;
//      g3 *= 1- (max(0, 1-g3_) * 0.02 * g3^3);
      rel3 = 1.00003;
      ):(
      rel3 *= 1.000001;
//      g3 *= (0.0006 / g3) * (max(0,dirg3_-1)*20 +1) * (1-g3^3) +1;
//      g3 *= (0.0003 / g3) * (max(0,g3_/g3-1)*1 +1) * (1-g3^3) +1;
      g3 *= ((rel3-1) / g3) * (max(0,g3_/g3-1)*4 +1) * (1-g3^3) +1;
//      g3 *= (0.0006 / g3) * (1-g3^3) +1;
      );
    g3_ < g3 ? g3 = g3_;
    );


  g3mode == 3 ? (
    dirg3_ < 10 ? (
      rel3 = 1.00003;
      ):(
      rel3 *= 1.000001;
      );
    g3_ < g3 ? g3 = g3_;
    );
  
  g3mode == 4 ? (
    thrsin = 0.8 ;
    //ransin = 0.3 - thrsin;
    ransin = thrsin*0.1;
    insinovr = MAX(0, min(1.57 , (in3-thrsin)/ransin));
    gsin_ = (thrsin + SIN( insinovr ) * ransin ) / in3;
    gsin_ *= 1- (1-gsin_) * ing;
    gsin_dir = gsin_/gsin_old;
    gsin_old = gsin_;
    gsin_ < 1 ? (
      gsin *= min(1, gsin_/gsin);
      gsin /= max(0, gsin/gsin_ )^10 * gsin * max(0, -gsin_dir+1)^1 *1 +1;
      
      rel3 = 1;
      ):(
      rel3 += 1;
//      gsin *= (0.0002 / gsin) * (1-gsin) +1 ;
p=0;
      );
    rel3 > 1000 ? rel3 = 1000;
    gsin *= ( (rel3^1*0.00001)/gsin) * (1-gsin^4) * max(0, 1- gsin/gsin_)^1 * max(0,1-zerout^10) +1;
    g3 = gsin;
    
    
    gsin < 0.01 ? gsin = 0.01;
    gsin > 1 ? gsin = 1;
    
    );
  
  
  
  

  g3 > 1 ? g3 = 1;
  
  g3 < 0.01 ? g3 = 0.01;
  dirg3_ = (g3_/g3_old -1) * max(0, g3_-0.1) +1;
  g3_old = g3_;

g3=1; // tmp




  spl0 *= g3 ;
  spl1 *= g3 ;




  );



zerolatency == 0 ? (


  loopmode = 4; 
  
  
  
  bufthr = 2; // After this only linear gain reduction, no shaping.
  bufmode = 1;
  
  
  maxspl0 = abs(spl0);
  maxtopL = max(maxtopL, maxspl0);
  bufferL[bufcnt] = spl0;
  spl0 < 0 ? (polL = -1) : (polL = 1);
  
  (polL != polLold) || (bufmaxcntL >= bufSize-1) ? (
    bufstopL = bufcnt ;
    
    maxtopL > 1 ? (
      processL = bufcnt;
      bufstopL-bufstopLold < 0 ? (
        looplenL = bufstopL + bufSize - bufstopLold;
        ):(
        looplenL = bufstopL - bufstopLold;
        );
      loop( looplenL,
        bufL = abs(bufferL[processL]);
        gainL1 = min(1, bufthr/maxtopL);
        bufLg1 = bufL * gainL1;
        bufmode == 1 ? (
          bufmultiL = (bufL*gainL1)/maxtopL;
          gainL2 = ( bufmultiL^0.5 * bufmultiL + (1-bufmultiL^0.5) * (bufLg1) ) / (bufLg1);
          );
        bufmode == 2 ? (
          bufranL = 1/(maxtopL*gainL1 -1) +1;
          gainL2 = (bufLg1 *  (bufranL / (bufLg1+bufranL)))  /  bufLg1;
          );
        
        bufferL[processL] *= gainL1 * gainL2;
        processL == 0 ? (
          processL = bufSize - 1;
          ):(
          processL -= 1;
          );      
        );
      polL != polLold ? maxtopL = 0;
      );
    bufmaxcntL = 0;
    
    bufstopLold = bufstopL;
    bufstopL = bufSize -1;
    
    ):(
    bufstopL = bufSize-1 ;
    );
  
  bufmaxcntL += 1;
  polLold = polL;
  
  


  
  
  
  
  maxspl1 = abs(spl1);
  maxtopR = max(maxtopR, maxspl1);
  bufcntR = bufcnt + bufSize;
  bufferR[bufcntR] = spl1;
  spl1 < 0 ? (polR = -1) : (polR = 1);
  
  (polR != polRold) || (bufmaxcntR >= bufSize-1) ? (
    bufstopR = bufcntR ;
    
    maxtopR > 1 ? (
      processR = bufcntR;
      bufstopR-bufstopRold < 0 ? (
        looplenR = bufstopR + bufSize - bufstopRold;
        ):(
        looplenR = bufstopR - bufstopRold;
        );
      loop( looplenR,
        bufR = abs(bufferR[processR]);
        gainR1 = min(1, bufthr/maxtopL);
        bufRg1 = bufR * gainR1;

        bufmode == 1 ? (
          bufmultiR = (bufR*gainR1)/maxtopR;
          gainR2 = ( bufmultiR^0.5 * bufmultiR + (1-bufmultiR^0.5) * (bufRg1) ) / (bufRg1);
          );
        bufmode == 2 ? (
          bufranR = 1/(maxtopR*gainR1 -1) +1;
          gainR2 = (bufRg1 *  (bufranR / (bufRg1+bufranR)))  /  bufRg1;
          );        
        bufferR[processR] *= gainR1 * gainR2;
        processR == bufSize ? (
          processR = bufSize *2 - 1;
          ):(
          processR -= 1;
          );      
        );
      polR != polRold ? maxtopR = 0;
      );
    bufmaxcntR = 0;
    
    bufstopRold = bufstopR;
    bufstopR = bufSize -1;
    ):(
    bufstopR = bufSize-1 ;
    );
  
  bufmaxcntR += 1;
  polRold = polR;
  
  
  
  
  
  
  
  
  
  bufcnt >= (bufSize-1) ? (bufcnt = 0) : (bufcnt += 1);
  bufcntR = bufcnt + bufSize;
  
  spl0 = bufferL[bufcnt] ;
  spl1 = bufferR[bufcntR] ;


);



bufout = max(abs(spl0),abs(spl1));

bufout > 1 ? ( gclip = 1/bufout) : gclip = 1;
spl0 *= gclip;
spl1 *= gclip;



tmpvol = 1
; tmpvol != 1 ? (
  spl0 *= tmpvol;
  spl1 *= tmpvol;
  );













loopmode == 10 ? (
  spl0 *= gainL;
  spl1 *= gainR;
  );


outmax = max(abs(spl0),abs(spl1));
softmode = 4;

softmode == 1 ? (
      
    gainexpL = max(0, bufL-thr )^1 * 1 +1;
  gainL = min(bufL, (bufL)^(1/(gainexpL)) ) / bufL;
  spl0 *= gainL;
  );


softmode == 2 ? (

  maxclipL = (bufL - MIN(1 , (bufL/2)) * MAX(bufL-1 , bufL/2));

  xmultiL = max(0, min(1, maxSpl0old-1));
  xL = xmultiL^max(0.1, 1-xmultiL)^0.4 ; 
  gainL = (bufL - xL * (bufL-maxclipL)) / bufL;
  gainL > 1 ? gainL = 1;  gainL < 0.1 ? gainL = 0.1;
  spl0 *= gainL;



  maxclipR = (bufR - MIN(1 , (bufR/2)) * MAX(bufR-1 , bufR/2));

  xmultiR = max(0, min(1, maxSpl1old-1));
  xR = xmultiR^max(0.1, 1-xmultiR)^0.4 ; 
  gainR = (bufR - xR * (bufR-maxclipR)) / bufR;
  gainR > 1 ? gainR = 1;  gainR < 0.1 ? gainR = 0.1;
  spl1 *= gainR;


  );



softmode == 3 ? (
  outmix = distxout * 0.5 * min(1, slider1/(-2));
  outsin = sin(outmax * 1.57) / outmax;
  outg = outmix * outsin + (1-outmix) ;
  spl0 *= outg;
  spl1 *= outg;
  );

softmode == 4 ? (
  outmix = distxout * 0.5 * min(1, slider1/(-2));
//  outmix = 0.5;
  outsinL = sin(abs(spl0) * (1.57)) / abs(spl0);
  outsinR = sin(abs(spl1) * (1.57)) / abs(spl1);
  outgL = outmix * outsinL + (1-outmix) ;
  outgR = outmix * outsinR + (1-outmix) ;
  spl0 *= outgL;
  spl1 *= outgR;
  );




spl0 *= outvol;
spl1 *= outvol;


state == 0 ? (
  statecnt += 1;
  statecnt > srate ? (
    state = 1;
    statecnt = 0;
    );
  );
play_state != play_stateold ? state = 0;
play_stateold = play_state;


rmsoinavg = (abs(spl0)+abs(spl1))/2;
rmsoinmax = max(abs(spl0), abs(spl1));
rmsoin = (rmsoinavg *3 +rmsoinmax)/4;

rmsibnk[rmspos] = rmsiin^2 ;
rmsisum += rmsiin^2;

rmsiin_ = rmsiin;

rmsobnk[rmspos] = rmsoin^2 ;
rmsosum += rmsoin^2;

rmspos += 1;    rmspos_ += 1;

(rmspos >= rmstime -1) && (state > 0) ? (
  rmsgo = 1;

  rmspos = 0;   rmspos_ = 0;
  
  rmsisum -= rmsibnk[rmspos];
  rmsimtr_ = 20 * log10( sqrt(rmsisum/rmstime) ) +3;
  rmsosum -= rmsobnk[rmspos];
  rmsomtr_ = 20 * log10( sqrt(rmsosum/rmstime) ) +3;

  rmsrst += 1;

  ):(
  rmsgo == 1 ? (
    rmsisum -= rmsibnk[rmspos];
    rmsosum -= rmsobnk[rmspos];
    rmspos_ >= (rmslen +1) ? (
      rmsimtr_ = 20 * log10( sqrt(rmsisum/rmstime) ) +3;
      rmsomtr_ = 20 * log10( sqrt(rmsosum/rmstime) ) +3;
      rmspos_ = 0;
      );
    );

  );
rmsrst >= 10 ? (
  rmspos = rmspos_ = rmsisum = rmsosum = rmsrst = rmsgo = 0;
  );




meter_outl_run = abs(spl0);
meter_outr_run = abs(spl1);
meter_outmid_run = (abs(spl0+spl1))/2;

meter_outl_pk = max(meter_outl_pk , meter_outl_run);
meter_outr_pk = max(meter_outr_pk , meter_outr_run);
meter_outmid_pk = max(meter_outmid_pk , meter_outmid_run);




gr_meter_lim_accel = 1.00002;
gr_meter_lim_decay = 1.000007;

mtr1_ =  ing;
mtr1_ < mtr1 ? mtr1 /= gr_meter_lim_accel : mtr1 *= gr_meter_lim_decay;
mtr1 > 1 ? mtr1 = 1;  mtr1 < 0.1 ? mtr1 = 0.1;

mtr2_ =  gainL1^2 * gainL2^2 ;
mtr2_ < mtr2 ? mtr2 = mtr2_ : mtr2 *= gr_meter_lim_decay;
mtr2 > 1 ? mtr2 = 1;  mtr2 < 0.1 ? mtr2 = 0.1;

mtr3_ =  gainR1^2 * gainR2^2;
mtr3_ < mtr3 ? mtr3 = mtr3_ : mtr3 *= gr_meter_lim_decay;
mtr3 > 1 ? mtr3 = 1;  mtr3 < 0.1 ? mtr3 = 0.1;

mtr4_ =  meter_outmid - meter_mid;
mtr4_ < mtr4 ? mtr4 = mtr4_ : mtr4 *= gr_meter_lim_decay;
mtr4 > 1 ? mtr4 = 1;  mtr4 < 0.1 ? mtr4 = 0.1;






//@gfx 375*gfx_ext_retina 230*gfx_ext_retina
@gfx (373*gfx_ext_retina) (228*gfx_ext_retina)
ret1 = gfx_ext_retina/2;


/* FONTS:
1 = RMS number1
2 = RMS Number2
3 = Title
4 = Title 2
5 = Version
6 = Meter -dB
7 = Help
8 = Slider values
9 = RMS txt
*/
font == "Tahoma";
gfx_setfont(1,font, 18);
gfx_setfont(2,font, 14);
gfx_setfont(3,font, 36);
gfx_setfont(4,font, 17, 'b');
gfx_setfont(5,font, 12, 'b');
gfx_setfont(6,font, 14 );
gfx_setfont(7,font, 15);
gfx_setfont(8,font, 18);
gfx_setfont(9,font, 14);


function digi(x1 y1 dir t l)(
  dir == "h" ? (
    x2 = x1+l;
    l_ = (x1+l)-(l*2);
    gfx_triangle(x1,y1 , x1+t,y1-t , x1+t,y1+t);
    gfx_rect(x1+t,y1-t , x1+l_,t*2 );
    gfx_triangle(x2-t,y1-t , x2,y1 , x2-t,y1+t);
    );
  dir == "v" ? (
    y2 = y1-l;
    gfx_triangle(x1,y1 , x1-t,y1-t , x1,y2+t , x1+t,y2 , x1+t*2,y2+t , x1+t,y1-t);
    );
  );

scalecnt += 1;
scalecnt > 30 ? (
  scalecnt = 0;
  r = gfx_ext_retina;
  r == 0 ? r = 1;

  

  );




//noob < 200 ? (upall = drawall = 1);


fxw = 375;
fxh = 230;


gfx_dest = 30;
gfx_setimgdim(30, -1, -1);   gfx_setimgdim(30, fxw, fxh); 


function roundshape(x1 y1 x2 y2 x3 y3 x4 y4 r) (
  gfx_circle(x1+r , y1+r , r ,1,1);
  gfx_circle(x2-r , y2+r , r ,1,1);
  gfx_circle(x3-r , y3-r , r ,1,1);
  gfx_circle(x4+r , y4-r , r ,1,1);
  gfx_triangle(x1,y1+r , x2,y2+r , x3,y3-r , x4,y4-r);
  gfx_triangle(x1+r,y1 , x2-r,y2 , x3-r,y3 , x4+r,y4);
  );


// GFX init
spad = 5;
skyh = min(fxh*0.8 , fxh - 20 );

tlt1 = -tlt_gain/6;
tlt1a = abs(tlt1);










// Double-click actions
dblclk >= 4 ? (
  lastcap == 1 ? (
    slider1 = 0;
    slider_automate(slider1);
    upsky = 2;
    
    dblclk = 0;
    );
  lastcap == 2 ? (
    slider2 = 5;
    upsaw = 1;
    
    dblclk = 0;
    );
  lastcap == 3 ? (
    slider12 = 0;
    
    slider_automate(slider12);
    dblclk = 0;
    );
  lastcap == 4 ? (
    slider20 = -0.1;
    slider_automate(slider20);
    dblclk = 0;
    drawceil = 1;
    );
  
  lastcap == 31 ? (
    slider31 == 0 ? (slider31 = 1) : (slider31 = 0);
    sliderchange(slider31);
    slider_automate(slider31);
    zerolatency = slider31;
    upslider = 1;
    dblclk = 0;
    );  
  
  lastcap == 32 ? (
    slider32 == 0 ? (slider32 = 1) : (slider32 = 0);
    sliderchange(slider32);
    slider_automate(slider32);
    linkvol = slider32;
//    uplock = 1;
    blitgo = 1;
    dblclk = 0;
    );  
  
  
  lastcap == 40 ? (
    slider20 = 0;
    txt = 4;
    slider_automate(slider20);
    dblclk = 0;
    );
  lastcap == 43 ? (
    slider20 = -3;
    txt = 4;
    slider_automate(slider20);
    dblclk = 0;
    );
  
  lastcap == 46 ? (
    slider20 = -6;
    txt = 4;
    slider_automate(slider20);
    dblclk = 0;
    );
  
  lastcap == 49 ? (
    slider20 = -9;
    txt = 4;
    slider_automate(slider20);
    dblclk = 0;
    );
  
  lastcap == 412 ? (
    slider20 = -12;
    txt = 4;
    slider_automate(slider20);
    dblclk = 0;
    );
  upslider = 1;
  );
    


stmin = -20;





drawall == 1 ? (
  drawcloud = drawflash = 1;
  drawmount = 1;
  drawceil = 1;
  drawall = 0;
  upall = 1;
  drawzero = 1;
  drawlock = 1;
  
  );
upall == 1 ? (
  upgrass = upmount = upmeter = upsaw = upsawtooth = upsky = upstars
   = drawceil = drawflash = uptilt = uptitle = drawlock = 1;
  
  upall = 0;
  );
  
  











upstars > 0 ? (
  gfx_dest = 3;
  gfx_setimgdim(3, -1, -1);   gfx_setimgdim(3, fxw*4, fxh*1); 
  loop( 20,
    gfx_x = rand(fxw*4);
    gfx_y = ( rand(1)^1.5 * fxh*1 );
    randradi = rand(2) +0.5;
    gfx_set(1,1,1, 1- rand(1)*0.3 -randradi*0.15 ,0);
    gfx_circle(gfx_x,gfx_y,randradi,1,1 );
    );
  upstars = 0;
  );


//movestars = 1;
movestars == 1 ? (
  movestars = 0;
//  starspeed = 0.09 ;
  starspeed = 1 ;
  starspeed -= (starx/fxw)^20 * 0.9 * starspeed + (1-starx/fxw)^20 * 0.9 * starspeed;
    stardir == 0 ? (
    starx >= fxw*2-4 ? stardir = -1;
    starx += starspeed;
    ):(
    starx <= 4 ? stardir = 0;
    starx -= starspeed;
    );
  );


uptitle > 0 ? (
  uptitle -= 1;
  gfx_dest = 9;   gfx_mode = 1;
  titw = tith = 150;
  gfx_setimgdim(9, -1, -1);   gfx_setimgdim(9, titw, tith); 
  gfx_set(1,1,1,1,1);
  tity = 60;
  
  gfx_x = 2;
  gfx_y = tity;
  gfx_setfont(3);
  gfx_drawstr("Sky");
  gfx_y += gfx_texth * 1;
  gfx_x = 0;
  gfx_setfont(4);
  gfx_drawstr("       is
  The Limit");
  gfx_x -= gfx_texth * 1.5;
  gfx_y = tity ;
  gfx_setfont(5);
  gfx_set(1,1,1,2,1);
  
  gfx_drawstr(ver);

  );




drawcloud == 1 ? (
  gfx_dest = 11;   gfx_mode = 0;
  gfx_setimgdim(11, -1, -1);   gfx_setimgdim(11, 150, 100); 
  cw = 100;
  cxl = 0;
  cxr = cxl + cw;
  cx3 = cxl + cw/6;
  cx4 = cxr - cw/5;
  ch = 50;
  ctop = 0;  cbot = skyh - ch * 1.7;
  cyr = cbot - ctop ;
  cy1 = ctop;
  cy2 = cy1 + ch;
  cy3 = cy1+ch*0.55;
      
  
  gfx_set(0.9,0.9,0.9,1);
  gfx_rect(cx3+1,cy3+5,cw/3*2-2,cy2-cy3-4);
  gfx_circle(cx3,(cy2+cy3)/2-1, (cy2-cy3)/2, 1 , 1 );
  gfx_circle(cx4,cy3+(cy2-cy3)/3-1, (cy2-cy3)/3*2 , 1 , 1 );
  gfx_circle( cx4-cw*0.25,cy3, (cy2-cy3)*0.8, 1 , 1 );
  gfx_circle( cx3+cw*0.15,cy3+(cy2-cy3)*0.13, (cy2-cy3)*0.4, 1 , 1 );
  gfx_set(0.8,0.85,0.95,1);
    
  xa = cx3 + (cx4-cx3)*0.1;
  xb = cx4;
  gfx_y = cy2-2*r;
  cnt = 0;
  gfx_set(0.7,0.75,0.85,1);
  while(xb > xa)(
    gfx_x = xa;
    gfx_lineto( xb , gfx_y );
    gfx_y -= 1;
    xa += 2 + (xa-cx3)/12;
//    xb += 4 / (cnt/2+0.7);
    xb += 2 * (1-cnt/12);
    gfx_a *= 0.9;
    cnt +=1;
    );
  
  loop(5,
    gfx_x = cxl;  gfx_y = cy1;
    gfx_blurto(cxr,cy2+10);
    );
  drawcloud = 0;
  );


// Draw Zippo
upsaw > 0 ? (
  acap += 1;
  distx == 0 ? (
    helpcnt > 5 ? zippopen = 1 : zippopen = 0;
    ):(
    zippopen = 1;
    );
  

  gfx_dest = 5;   gfx_mode = 0;
  gfx_setimgdim(5, -1, -1);   gfx_setimgdim(5, 100, 100);
  za = 0.95;
  gfx_set(0.9,0.9,0.9,za,0);
  
  // Closed zippo
  zippopen == 0 ? (
    zbx1 = 30;
    zbx2 = 50;
    zby1 = 50;
    zbytop = 40;
    zby2 = 70;
    gfx_set(0.9,0.9,0.9,za,0);

    roundshape(zbx1,zbytop , zbx2,zbytop , zbx2,zby2 , zbx1,zby2 , 2);
    gfx_circle(zbx1,zby1 , 2 , 1,1);
    gfx_set(0.5,0.5,0.5,za,0);
    gfx_line(zbx1-r,zby1 , zbx2,zby1);
    ):(
  

    // Open zippo
    zcx1 = 10;
    zcx2 = 15;
    zcx3 = 25;
    zcy1 = 40;
    zcy2 = 60;
    zbx1 = 30;
    zbx2 = 50;
    zby1 = 50;
    zby2 = 70;
    
    //Cap
    gfx_a = za;
//    roundshape(zcx1+5,zcy1 , zbx1,zby1 , zbx1-5,zcy2 , zcx1,zcy2-5  , 2);
    gfx_triangle(zcx2,zcy1 , zbx1,zby1 , zcx3,zcy2 , zcx1,zcy2-(zby1-zcy1));
    //Body
    roundshape(zbx1,zby1 , zbx2,zby1 , zbx2,zby2 , zbx1,zby2 , 3);
    gfx_rect(zbx1,zby1 , zbx2-zbx1,zby2-zby1 ,1,1);
    //Nib
    gfx_set(0.5,0.5,0.5);
    gfx_rect(zfx-4 , zby1-3 , 8,3 , 1,1);
    
    //Flame
    distx > 0 ? (
      zfx = (zbx1+zbx2)/2;
      zfxrand1 = rand(1);
      zfyrand1 = rand(1);
      zfr = 3 + distx*10 * (0.9+zfr1/5);
      zfy2 = zby1-6-zfr*0.5;

// NEW Y:
      zfymin = zfy2-zfr*(1.5 + distx/2);            // Highest top edge y
      zfy1 = zfy2-zfr*1.5 - zfyrand1 * (zfr*1.5 * distx);

      zftxmin = zfx- zfr * (distx+1);            // Flame top min x
      zftx = zftxmin + zfxrand1 * (zfx-zftxmin)*2;
      zfxsin = sin(zfxrand1 * 3.14 - 1.57);
      zfysin = sin(zfyrand1 * 3.14 - 1.57);
      fa = 1;

      gfx_set(1,0.85+rand(1)/10,0,fa);
      gfx_circle(zfx,zfy2  ,  zfr  ,  1,1  );

      zfxL = zfx-zfr + zfr * max(0, min(1, zfxsin) * (1-zfysin*0.5 ) ) * 0.6;
      zfxR = zfx+zfr - zfr * max(0, min(1, -zfxsin) * (1-zfysin*0.5 ) ) * 0.6;
      zfxsin >= 0 ? (
        zfyL = zfy2 - zfr * min(1, (max(0, zfxsin)*0.75 + (1-zfysin)*0.25  ))^1;
        zfyR = zfy2 - zfr * min(1, (max(0, -zfxsin) ));
        ):(
        zfyL = zfy2 - zfr * min(1, (max(0, zfxsin) ));
        zfyR = zfy2 - zfr * min(1, (max(0, -zfxsin)*0.75 + (1-zfysin)*0.25 ))^1;
        );

      gfx_triangle(zftx,zfy1 , zfxR,zfyR , zfxL,zfyL);
      gfx_set(1,0.6,0, 0.4 ,0);
      gfx_arc(zfx+zfr*(0.9-abs(zfrand)^2*0.1),zfy2 +zfrand*zfr*0.5 , zfr*(1.3 - zftyrand*0.2) , 4.5+zfrand*0.4 , 5.3+(zfrand)*0.6 );
      gfx_arc(zfx-zfr*(0.9-abs(zfrand)^2*0.1),zfy2 -zfrand*zfr*0.5 , zfr*(1.3 - zftyrand*0.2) , 1.7+zfrand*0.4 , 1.0+(zfrand)*0.6 );
      gfx_a = 0.2;
      gfx_circle(zfx,zfy2 , zfr*0.4 , 1,1);
      );
    );
  
  // Shadow
  xl = zbx1 + 2;
  x = zbx2 - 2;
  y = zby2 - 2;
  gfx_set(0.6,0.6,0.6,0.5,0);
  while(y > zby1+2 )(
    gfx_line(xl,y,x,y);
    x -= (x-xl) * 0.2;
    y -= 1;
    gfx_a -= 0.03;
    );


  loop(2,
    gfx_x = gfx_y = 0;
    gfx_blurto(100,100);
    );
  upsaw -= 1;
  upsawtooth = 0;
  );





drawflash == 1 ? (
  gfx_dest = 4;   gfx_mode = 0;
  gfx_setimgdim(4, -1, -1);   gfx_setimgdim(4, 80, 50); 


  tlt1of = tlt1+0.4;
  tlt1aof = abs(tlt1of);
  
  fly1=10;
  fly2=fly1+14;
  flx1=5 ;//+ max(0,tlt1of)*9 + min(0,tlt1of)*(3);
  flx2=flx1+15;
  flx3=flx2+15;
  flx4=flx3+5;
  gfx_set(0.8- tlt1*0.2 , 0.65- tlt1*0.4 , 0.2- tlt1*0.8 ,1,0);
  gfx_circle(flx4 - 3, (fly1+fly2)/2-1 , 6, antialias);
  gfx_circle(flx4 - 3, (fly1+fly2)/2-1 , 6, 1,1);
  gfx_line(flx4+10 , fly1 , flx4+16 , (fly1-2) );
  gfx_line(flx4+10 , fly1-1 , flx4+16 , (fly1-2) -1);
  gfx_line(flx4+11 , (fly1+fly2)/2 , flx4+18 , (fly1+fly2)/2 );
  gfx_line(flx4+11 , (fly1+fly2)/2-1 , flx4+18 , (fly1+fly2)/2 -1);
  gfx_line(flx4+10 , fly2 , flx4+16 , (fly2+2) );
  gfx_line(flx4+10 , fly2-1 , flx4+16 , (fly2+2)-1 );
  gfx_set(0.8,0.85,0.9,1);
  gfx_rect(flx1,fly1,flx3-flx1,fly2-fly1 , 2);
  gfx_triangle(flx2-4,(fly1+fly2)/2 -0, flx4,fly1-5 , flx4,fly2+3);
  gfx_set(0.4,0.45,0.55,1);
    y = fly2 - 1;
  z = 0.5;
  gfx_a += 0.1;
  loop(6,
    gfx_line(flx1 + 2 , y , flx3 - 5 , y);
    gfx_line(flx3-3,y , flx3+5, y+3-(fly2-r-y)*0.7 );
    y -= z;
    z += 0.5;
    gfx_a -= 0.15;
    );
  gfx_a = 1;
  gfx_line(flx4,fly1-4 , flx4,fly2+3);
  
  loop(4,
    gfx_x = gfx_y = 0;
    gfx_blurto(flx4 +5 , fly2 + 10);
    );

  drawflash = 0;
  upflash = 0;
  );
  
  
  
//upsky = 1;
upsky > 0 ? (
  upsky -= 1; //?
  aupp += 1;
  blitgo = 1;
  gfx_dest = 1;   gfx_mode = 1;
  gfx_setimgdim(1, -1, -1);   gfx_setimgdim(1, fxw/2, fxh/2); 
  sbri = ((-st)/(-stmin))^0.6 *0.6 ;
  dred = (sd/100 )^0.8 *0.6 * (min(0.3,sbri*3) + 0.7);
  gfx_x = gfx_y = 0;     


  w = fxw/4;
  h = fxh/2;

  rmin = 0.0 + sbri*0 + dred*0.6 - dred*sbri*0.0;
  rmax = 0.0 + sbri*0.1 + dred*0.6 + dred*sbri*0.5;
  gmin = 0.1 + sbri*0.3 - dred*0.0 - dred*sbri*1;
  gmax = 0.1 + sbri*0.6 - dred*0.0 - dred*sbri*1.2;
  bmin = 0.5 + sbri*0.0 - dred*1 + dred*sbri*0;
  bmax = 0.7 + sbri*0.1 - dred*1.5 + dred*sbri*0;

  amin = 0.8 + sbri*0.6 - dred*0.1 + dred*sbri*0;
  amax = 0.8 + sbri*0.7 + dred*0.1 + dred*sbri*0;
  ry = 0.0 + sbri*0.3 + dred*0.7 + dred*sbri*0.0;
  gy = 0.05 + sbri*0.1 - dred*0.5 + dred*sbri*0.4;
  by = 0.05 - sbri*0.0 - dred*0.5 - dred*sbri*0.5;
  ay = 0.1 + sbri*0.5 + dred*0.1 + dred*sbri*1;

  gfx_gradrect(0,0,w,h,
  rmin,gmin,bmin,amin,  (rmax-rmin)/w,(gmax-gmin)/w,(bmax-bmin)/w,(amax-amin)/w,   ry/h,gy/h,by/h,ay/h);


  gfx_gradrect(w,0,w,h,
  rmax,gmax,bmax,amax,  (rmin-rmax)/w,(gmin-gmax)/w,(bmin-bmax)/w,(amin-amax)/w,   ry/h,gy/h,by/h,ay/h);






  upgrass = 1;

  );


upgrass == 1 ? (
  gfx_dest = 2;
  grasw = fxw * 0.6;
  grash = fxh * 0.25;
  gfx_setimgdim(2, -1, -1);   gfx_setimgdim(2, grasw, grash*2);
  grasy = skyh;

  gfx_set(1,1,1,1,0);
  gfx_gradrect(0,0 , fxw,fxh/2
  ,  dred*0.2+sbri*dred*0.3 , 0.13 +sbri*0.4 -dred*0.0 -sbri*dred*0.3 ,0,1 ,  0,0,0,0,  
  (-dred*0.3*3)/grash , (-0.2-dred*sbri*0.0-sbri*0.6)/grash ,0, (sbri*dred*0.4 *0)/grash );

   
  upgrass = 0;
  );



upmount > 0 ? drawmount = 1;
drawmount > 0 ? (

  mountw = grasw*2;
  mounth = fxh * 0.3;
  
  gfx_dest = 20;
  gfx_setimgdim(20, -1, -1);   gfx_setimgdim(20, mountw, mounth); 
  gfx_set(0.2,0.5,0,1,0);
  gfx_x = 0;  gfx_y = mounth;
  x = 0;
  while( x < (mountw))(
    mtsize = rand(1) * (10 + fxh/10)*r;
    gfx_triangle(x,mounth , x+mtsize,mounth - mtsize , x+mtsize*2,mounth);
    x += mtsize*1.5;
    );
  gfx_dest = 21;
  gfx_setimgdim(21, -1, -1);   gfx_setimgdim(21, mountw, mounth); 
  gfx_set(0.2,0.5,0,1,0);
  gfx_x = 0;  gfx_y = mounth;
  x = 0;
  while( x < (mountw))(
    mtsize = rand(1) * (20 + fxh/20);
    gfx_triangle(x,mounth , x+mtsize,mounth - mtsize , x+mtsize*2,mounth);
    x += mtsize*1.5;
    );
//  gfx_x = 0;  gfx_y = fxh/2;

  
  drawmount -= 1;
  upmount = 1;
  );

//upmount = 1; // tmp
upmount > 0 ? (
  sd1 = (sd/100)^0.8;
//  sd1 = 1; // tmp
  gfx_dest = 23;   gfx_setimgdim(23, -1, -1);   gfx_setimgdim(23, mountw, mounth); 


  
  gfx_set(1,1,1,0.5,0);
//  gfx_blit(20,1,0, 0,0,grasw,mounth , -fxw*0.1,(1-sd1) * (skyh),fxw*1.2,(sd1)*skyh);
//  gfx_blit(20,1,0, 0,0,mountw,mounth , -fxw*0.1,(1-sd1)*mounth,mountw,(sd1)*mounth);
  gfx_x = 0; gfx_y = 0;
  gfx_blit(20,1,0);
  gfx_x = 0; gfx_y = 0;
  gfx_blurto(mountw,mounth);
  gfx_x = 0; gfx_y = 0;
  gfx_set(1,1,1,1,0);
//  gfx_blit(21,1,0, 0,0,mountw,mounth , -fxw*0.1,(1-sd1)*mounth,mountw,(sd1)*mounth);
  gfx_blit(21,1,0);
  upmount -= 1;


  );


// Draw Ceiling
drawceil == 1 ? (
  gfx_dest = 13;  gfx_mode = 0;      gfx_setimgdim(13, -1, -1);   gfx_setimgdim(13, 70, 50); 
  gfx_x = gfx_y = 0;
  gfx_set(1,1,1,1);
  roundshape(1,1 , 33,1 , 33,14 , 1,14 , 5);
  gfx_triangle(30,1 , 38,1 , 30,7);
  gfx_line(35,1 , 70,1);
  gfx_line(35,2 , 70,2);
  gfx_set(0.3,0.3,0.3,0.5);

  gfx_rect(7,7 , 21,2);


  gfx_x = gfx_y = 0;  gfx_a = 1;
  gfx_blurto(70,50);
  drawceil = 0;
  drawlock = 1;
  );


drawlock > 0 ? (
  drawlock = 0;
  gfx_dest = 16;
  gfx_setimgdim(16,-1,-1); gfx_setimgdim(16,80,80);
  gfx_set(1,1,1,1,0);
  gfx_circle(9,10,7, 1,1);
  gfx_set(1,1,1,-1,1);
  gfx_circle(9,10,4, 1,1);
  
  blitgo = 1;
  );
  


drawzero == 1 ? (
  drawzero = 0;

  // Binoculars 2
  gfx_dest = 14;
  gfx_setimgdim(14,-1,-1); gfx_setimgdim(14,80,80);
  gfx_set(1,1,1,1,0);
  xstart = 20;
  xstart2 = xstart + sz*1.25;
  ystart = 10;
  sz = 20;
  
  // Connectors
  gfx_set(1,1,1,1);
  gfx_rect(xstart+sz,ystart+sz*0.3,sz/2,4);
  gfx_rect(xstart+sz,ystart+sz*0.9,sz/2,6);
  // LEFT SIDE
  // Back wall
  gfx_circle(xstart+sz/3-1,ystart , sz/3-1, 1,0);
  gfx_circle(xstart+sz/5*4+1,ystart , sz/5-1, 1,0);
  gfx_triangle(xstart+sz/3,ystart-sz/3+0 , xstart+sz/5*4+1,ystart-sz/5+1 , xstart+sz/2,ystart+sz);
  // Body
  gfx_triangle(xstart-sz*0.25,ystart+sz*1.2 , xstart-1,ystart , xstart+sz,ystart , xstart+sz,ystart+sz*1.2);
  // Front wall
  gfx_set(0.7,0.7,0.7,1);
  gfx_circle(xstart+sz/4,ystart+sz*1.3, sz*0.5 ,1,0);
  gfx_circle(xstart+sz/4*3,ystart+sz*1.2, sz*0.25 ,1,0);
  gfx_triangle(xstart+sz/4+1,ystart+sz*1.8 , xstart+sz/4*3+1,ystart+sz*1.5
     , xstart+sz/4*3+1,ystart+sz*0.9 , xstart+sz/4+1,ystart+sz*0.75);
  //Eye piece
  gfx_set(1,1,1,1,0);
  y = last = 0;
  fill = 1;
  loop(10,
    y >= 8 ? (
      gfx_set(0.3,0.3,0.3,1);
      fill = 0;
      last = 2;
      );
    gfx_circle(xstart+sz/3*2-(y-last)/4-2,ystart+sz*1.3+y-last, sz*0.3+(y)/10-last ,1,0);
    y += 1;
    );
  
  // RIGHT SIDE
  xstart2 = xstart + sz*2 + 4;
  // Back wall
  gfx_set(1,1,1,1,0);
  gfx_circle(xstart2-(sz/3-1),ystart , sz/3-1, 1,0);
  gfx_circle(xstart2-(sz/5*4+1),ystart , sz/5-1, 1,0);
  gfx_triangle(xstart2-(sz/3),ystart-sz/3+0 , xstart2-(sz/5*4+1),ystart-sz/5+1 , xstart2-(sz/2),ystart+sz);
  // Body
  gfx_triangle(xstart2+sz*0.25,ystart+sz*1.2 , xstart2+1,ystart , xstart2-(sz),ystart , xstart2-(sz),ystart+sz*1.2);
  
  // Front wall
  gfx_set(0.7,0.7,0.7,1);
  gfx_circle(xstart2-(sz/4),ystart+sz*1.3, sz*0.5 ,1,0);
  gfx_circle(xstart2-(sz/4*3),ystart+sz*1.2, sz*0.25 ,1,0);
  gfx_triangle(xstart2-(sz/4+1),ystart+sz*1.8 , xstart2-(sz/4*3+1),ystart+sz*1.5
     , xstart2-(sz/4*3+1),ystart+sz*0.9 , xstart2-(sz/4+1),ystart+sz*0.75);
  //Eye piece
  gfx_set(1,1,1,1,0);
  y = last = 0;
  fill = 1;
  loop(10,
    y >= 8 ? (
      gfx_set(0.3,0.3,0.3,1);
      fill = 0;
      last = 2;
      );
    gfx_circle(xstart2-(sz/3*2-(y-last)/4-2),ystart+sz*1.3+y-last, sz*0.3+(y)/10-last ,1,0);
    y += 1;
    );
  
  loop(3,
    gfx_x = gfx_y = 0;
    gfx_blurto(80,80);
    );
  

  );




// BLITS

/*
blitimer += 1;
blitimer > 30 ? (
  blitgo = 1;
  blitimer = 0;
  );
*/

blitgo > 0 ? (
//  blitgo = 0;


  
  gfx_dest = 30;  gfx_mode = 1;
  gfx_x = gfx_y = 0;
  gfx_a = 1;
  // Blit sky
  gfx_blit(1,2,0);
  // Stars?
  gfx_a = (1-sbri)^3 ;
  
  
  

  gfx_dest = 30;
  distmount = distx^0.5;
  gfx_x = 0; gfx_y = grasy+5-(mounth)*distmount;
  //gfx_set(1,1,1,0.3+distx*0.2+sbri^0.5*0.7,0);
  //gfx_set(1,1,1,0.3+distx*0.2+sbri^0.5*0.7,0);
  gfx_set(1,1,1,0.4+sbri^0.5*0.5+distx*0.4,0);
  gfx_blit(23,1, tlt1*0.2
   , 0,-mounth,mountw,mounth*3 , -50,grasy+6-(mounth*2)*distmount + tlt1*8,(mountw+100),(mounth*3)*distmount);
  gfx_set(1,1,1,-0.1-distx*0.2-sbri*0.4,1);
  gfx_blit(21,1, tlt1*0.2
   , 0,-mounth,mountw,mounth*3 , -50,grasy+6-(mounth*2)*distmount + tlt1*8,(mountw+100),(mounth*3)*distmount);
  
    // Tint mount (+sky)
    gfx_set(1,1,1,1,1);
    gfx_a=1;
  
  
  
  
  // Blit grass
  gfx_dest = 30;
  gfx_set(1,1,1,1,0);
  gfx_blit(2,2, tlt1 * 0.2,// (abs(tlt_angle/6)^0.8/abs(tlt_angle/6))*tlt_angle* (-0.026) ,
  0,-100 , grasw, grash+200  ,  -fxw*0.1, grasy-97 , fxw*1.2,grash+200  );// ,   0,-grasy/2);
  
  
  // TILT TINT SHADE
    gfx_set(1,1,1,1,1);
    tlt_gain > 0 ? (
      // Left
      gr = 0.3;
      gfx_gradrect(0,0,fxw/3*2,fxh , gr*(1+distx*1),gr,gr,tlt1 , 0,0,0,(-tlt1)/(fxw/3*2));
      // Right
      wh = 0.5;
      gfx_gradrect(fxw/3,0,fxw/3*2,fxh , 0,0,0,0 , 
      (wh +dred*wh*0)/(fxw/3*2),(wh+dred*0.3)/(fxw/3*2),(wh)/(fxw/3*2),(-tlt1*0.9)/(fxw/3*2)
      , 0,0,0,(tlt1*0.5)/fxh) ;
      );
    tlt_gain < 0 ? (
      // Left
      gr = 0.2;
      gfx_gradrect(0,0,fxw/3*2,fxh , gr*(1+distx*2),gr,gr,tlt1/2 , -dred/(fxw/3),0,0,(-tlt1/2)/(fxw/3*2));
      // Right
      wh = 0.8;
      gfx_gradrect(fxw/3,0,fxw/3*2,fxh , 0,0,0,0 , 
      (wh*1.5)/(fxw/3*2),(wh*0.6)/(fxw/3*2),(wh*0.8)/(fxw/3*2),(-tlt1*0.8)/(fxw/3*2)
      , 0,0,0,(0)/fxh) ;
      );
  
  
  
  
  
  // Blit cloud
  
  gfx_dest = 30;  gfx_mode = 0;
  gfx_x = 0;
  cyr = fxh*0.5;
  cloudx = fxw*0.35;
  cloudy = min(1, (-st)/(-stmin)) * cyr ;
  
  gfx_a = 0.9;
  gfx_blit(11,1,0 , 0,0,150,100 , cloudx,cloudy,150,100);
  
  
  gfx_dest = 30;





  // METER SCALE MOVED HERE:
  meter_bot = 21;
  meter_inw = 32;
  meter_lowy = grasy+1;
  yscale = meter_lowy /meter_bot;
    ceily = ((-slider20/meter_bot)^0.75   ) * meter_lowy +spad -1;


  // Blit Ceiling
  gfx_set(1,1,1,0.8,0);
  gfx_blit(13,1,0, 0,0,70,50 , fxw-75, ceily +0);
  

  // Blit lock/chain
  locx = fxw/3*2 -5;
  locy = 10;
  gfx_set(1,1,1,0.3 + slider32*0.5,0);
  gfx_blit(16,1,0, 6,0,20,20 , locx+1,locy+17,20,10);
  gfx_blit(16,1,-0.4, 0,0,20,20 , locx+3,locy+14,20,10);
  gfx_blit(16,1,-0.8, 0,0,20,20 , locx+9,locy+8,20,10);
  gfx_blit(16,1,-0.4, 0,0,20,20 , locx+17,locy+3,20,10);
  gfx_blit(16,1,-0.1, 0,0,13,20 , locx+26,locy+1,12,10);

  
  
  // Blit Flashlight
  gfx_dest = 30;  gfx_mode = 0;
  gfx_x = gfx_y = 0;
  gfx_a = 1;
  
  gfx_blit(4,1,tlt1 * 0.2 , -10,-10,100,50 , 235,158+tlt1*20,100,50 , 0,0);
  
  
  
  // Blit Binoculars
  gfx_dest = 30;
  zerolatency == 1 ? gfx_a = 0.5 : gfx_a = 0.9;
  gfx_blit(14,1,0, 0,0,80,80 , 40,10, 80,40);
  
  
  
  
  
  ); // /blitgo



meter_decay = 1.1;
hold = 1;
accel = 0.07;

meter_l_ = meter_l_pk;
meter_l_pk = 0.01;

meter_r_ = meter_r_pk;
meter_r_pk = 0.01;

meter_mid_ = meter_mid_pk;
meter_mid_pk = 0.01;

meter_l_ < meter_l*0.99 ? (
  hold_l += 1;
  hold_l > hold ? (meter_l /= meter_decay + accel_l) & accel_l += accel;
  ):(
  meter_l = meter_l_;
  hold_l = 0;
  accel_l = 0;
  );

meter_r_ < meter_r *0.99? (
  hold_r += 1;
  hold_r > hold ? (meter_r /= meter_decay + accel_r) & accel_r += accel;
  ):(
  meter_r = meter_r_;
  hold_r = 0;
  accel_r = 0;
  );

meter_mid_ < meter_mid *0.99? (
  hold_mid += 1;
  hold_mid > hold ? (meter_mid /= (meter_decay + accel_mid)) & (accel_mid += accel);
  ):(
  meter_mid = meter_mid_;
  hold_mid = 0;
  accel_mid = 0;
  );



meter_outl_ = meter_outl_pk;
meter_outl_pk = 0.01;

meter_outr_ = meter_outr_pk;
meter_outr_pk = 0.01;

meter_outmid_ = meter_outmid_pk;
meter_outmid_pk = 0.01;



meter_outl_ < meter_outl *0.99? (
  hold_outl += 1;
  hold_outl > hold ? (meter_outl /= meter_decay + accel_outl) & accel_outl += accel;
  ):(
  meter_outl = meter_outl_;
  hold_outl = 0;
  accel_outl = 0;
  );

meter_outr_ < meter_outr *0.99? (
  hold_outr += 1;
  hold_outr > hold ? (meter_outr /= meter_decay + accel_outr) & accel_outr += accel;
  ):(
  meter_outr = meter_outr_;
  hold_outr = 0;
  accel_outr = 0;
  );

meter_outmid_ < meter_outmid *0.99 ? (
  hold_outmid += 1;
  hold_outmid > hold ? (meter_outmid /= (meter_decay + accel_outmid)) & (accel_outmid += accel);
  ):(
  meter_outmid = meter_outmid_;
  hold_outmid = 0;
  accel_outmid = 0;
  );
  
  
  
  
  


  

upmeter = 1;    upmeter == 1 ? (
  gfx_dest = 10;  gfx_mode = 0;
  gfx_setimgdim(10, -1, -1);   gfx_setimgdim(10, fxw, meter_lowy); 


  midside == 0 ? gr_meter2 = gr_meter;



// INPUT METER LINES

  gfx_set(1,1,1,1);

  gfx_line(spad , spad, spad + meter_inw - 2, spad);
  mstart = 0;
  mspac = -3;
  gfx_setfont(6);
  gfx_set(1,1,1,1);
  
  loop( floor(meter_bot/(-mspac))+1,
    gfx_x = spad;

    gfx_y = ((-mstart/meter_bot)^0.75   ) * meter_lowy +spad+1;

    mstart == 0 || mstart == -6 ||  mstart == -12 || mstart == -18 || mstart == -30 ? (
      mtry[-mstart] = gfx_y;
      gfx_a = 1;
      gfx_x = spad + meter_inw/3 -1;
      mstart == 0 ? (gfx_x += gfx_texth*0.2): mstart <= -10 ? (gfx_x -= gfx_texth*0.3);
      gfx_drawnumber(mstart,0);
      gfx_x = spad;
      ):(
      gfx_a = 0.6;
      );
    mstart == -3 || mstart == -9 || mstart == -15 ? mtry[-mstart] = gfx_y;


    gfx_lineto(spad+meter_inw-2 , gfx_y);
    mstart += mspac;
    );
  
  ypo0 = mtry[3];


// OUTPUT METER LINES
//  gfx_line(spad , spad, spad + meter_inw - 2, spad);

    gfx_set(1,1,1,1);
  gfx_line(fxw - spad - meter_inw +1, spad, fxw - spad - 1, spad);
  mstart = 0;
  mspac = -3;
  gfx_setfont(6);
  gfx_set(1,1,1,1);
  
  loop( floor(meter_bot/(-mspac))+1,
    gfx_x = fxw - spad - meter_inw;

    gfx_y = ((-mstart/meter_bot)^0.75   ) * meter_lowy +spad+1;


    mstart == 0 || mstart == -6 ||  mstart == -12 || mstart == -18 || mstart == -30 ? (
      gfx_a = 1;
      gfx_x = fxw - spad - meter_inw * 2/3;
      mstart == 0 ? (gfx_x += gfx_texth*0.2): mstart <= -10 ? (gfx_x -= gfx_texth*0.3);
      
      gfx_drawnumber(mstart,0);
      gfx_x = fxw - spad - meter_inw +1;
      ):(
      gfx_a = 0.6;
      );
    gfx_lineto(fxw - spad - 1 , gfx_y);
    mstart += mspac;
    );

  
  upmeter = 0;
  );



// INPUT LEVEL METERS

  gfx_dest = 31;  gfx_mode = 0;
mtrscale = 1;
mfxw = (fxw-spad*2)/2 +1;
//  mfxh = (meter_lowy-spad )/2;
mfxh = mfxw * (meter_lowy/fxw)+1;
//  mtrtransx = (mfxw)/(fxw-spad);    mtrtransy = (mfxh)/(fxh-spad);
mtrtransx = mtrtransy = 0.5 ;
  gfx_setimgdim(31, -1, -1);   gfx_setimgdim(31, mfxw, mfxh); 
  
  gfx_set(0.4,0.7,0.9,0.15+sbri^2*0.4+dred*0.15);
gfx_a = 0.5;
gfx_x=0;

meter_l > 1 ? (meter_l = 1; ledl = 1.5;);
meter_r > 1 ?  (meter_r = 1; ledr = 1.5;);
meter_mid > 1 ?  (meter_mid = 1; ledm = 1.5;);

ydbl = ( - log10(  meter_l  )) * 20   ;
gfx_y = (( ydbl /meter_bot)^0.75   ) * (mfxh )+1;
gfx_rectto(( meter_inw/6 ),mfxh+2);

gfx_x = (meter_inw+spad)/2-1;
ydbr = ( - log10(  meter_r  )) * 20   ;
gfx_y = (( ydbr /meter_bot)^0.75   ) * (mfxh )+1;
gfx_rectto( meter_inw/6*2 +1,mfxh+2);

    gfx_set(0.2,0.5,0.7,0.15+sbri^2*0.4+dred*0.15);
gfx_a = 0.5;

ydbm = ( - log10(  meter_mid  )) * 20   ;
gfx_y = (( ydbm /meter_bot)^0.75   ) * (mfxh )+1;
gfx_rectto( meter_inw/6 , mfxh+2);



// PEAK LEDS
ledw = meter_inw/6;
ledh = 20;
ledy = 0;

ledlx = 0;
ledmx = ledw;
ledrx = ledmx+ledw+1;
gfx_set(1,0,0,1,0);
ledl > 0 ? (
  a = min(1,ledl);
  gfx_gradrect(ledlx,ledy,ledw,ledh , 0.9,0.0,0,a , 0,0,0,0 , 0,0,0,-a/ledh);
  ledl -= 0.02;
  );
ledm > 0 ? (
  a = min(1,ledm);
  gfx_gradrect(ledmx,ledy,ledw+1,ledh , 0.9,0.0,0,a , 0,0,0,0 , 0,0,0,-a/ledh);
  ledm -= 0.02;
  );
ledr > 0 ? (
  a = min(1,ledr);
  gfx_gradrect(ledrx,ledy,ledw,ledh , 0.9,0.0,0,a , 0,0,0,0 , 0,0,0,-a/ledh);
  ledr -= 0.02;
  );
ledmx = meter_inw/6;


// OUTPUT LEVEL METERS

meter_outl > 1 ? (meter_outl = 1; ledlo = 1.5;);
meter_outr > 1 ?  (meter_outr = 1; ledro = 1.5;);
meter_outmid > 1 ?  (meter_outmid = 1; ledmo = 1.5;);

  gfx_set(0.4,0.7,0.9,0.15+sbri^2*0.4+dred*0.15);
gfx_a = 0.5;
gfx_x = mfxw;
ydb = ( - log10(  meter_outr  )) * 20   ;
gfx_y = (( ydb /meter_bot)^0.75   ) * (mfxh )+1;
gfx_rectto(mfxw-meter_inw/6,mfxh+2);

  gfx_x = mfxw-meter_inw/2;
ydb = ( - log10(  meter_outl  )) * 20   ;
gfx_y = (( ydb /meter_bot)^0.75   ) * (mfxh )+1;
gfx_rectto(mfxw-meter_inw/6 *2,mfxh+2);

  gfx_set(0.2,0.5,0.7,0.15+sbri^2*0.4+dred*0.15);
gfx_a = 0.5;
ydb = ( - log10(  meter_outmid  )) * 20   ;
gfx_y = (( ydb /meter_bot)^0.75   ) * (mfxh )+1;
gfx_rectto(mfxw-meter_inw/6 +1  , mfxh+2);



// PEAK LEDS (OUT)
ledolx = mfxw-meter_inw/2;
gfx_set(1,0,0,1,0);
ledol > 0 ? (
  a = min(1,ledol);
  gfx_gradrect(ledolx,ledy,ledw,ledh , 0.9,0.0,0,a , 0,0,0,0 , 0,0,0,-a/ledh);
  ledol -= 0.02;
  );
ledomx = ledolx + ledw;
ledom > 0 ? (
  a = min(1,ledom);
  gfx_gradrect(ledomx,ledy,ledw+1,ledh , 0.9,0.0,0,a , 0,0,0,0 , 0,0,0,-a/ledh);
  ledom -= 0.02;
  );

ledorx = ledomx + ledw;
ledor > 0 ? (
  a = min(1,ledor);
  gfx_gradrect(ledorx,ledy,ledw,ledh , 0.9,0.0,0,a , 0,0,0,0 , 0,0,0,-a/ledh);
  ledor -= 0.02;
  );





gfx_dest = 30;  gfx_mode = 0;
gfx_x = gfx_y = spad;
gfx_a = 1;
//  gfx_blit(31,1,0,  0,0,mfxw,mfxh, spad,spad,fxw-spad*2,meter_lowy-spad);
gfx_blit(31,2,0);


// Blit Meterlines
gfx_dest = 30;  gfx_mode = 1;
gfx_x = gfx_y = 0;
gfx_a = 0.25;
gfx_blit(10,1,0);







gfx_dest = 30;
gfx_set(0.75,0.8,0.9,1);


// Character slider

gfx_x = fxw * 0.7 + 2;
dy = grasy + grash*0.45;
dx_ = grash*0.05 + fxw * 0.008 ;
dy_ = 2/3 * dx_;
dyx = 1;
gfx_y = dy+dyx*dy_;
dcnt = 0;


dmin = fxw*0.17;
dmax = dmin + fxw*0.3;
dxr = dmax-dmin;
dx1 = dmin + sd/100 * dxr;
dx2 = dx1+12;
dy1 = dy-10;
dy2 = dy+10;
dpad = 2;
gfx_a *= 0.1;
gfx_rect(dmin, (dy1+dy2)/2-dpad , dmax-dmin+(dy2-dy1)/2 , dpad*2);
gfx_a /= 0.1;

// Blit saw
sawtype == 1 ? (
  sawrange = fxw*0.3 - meter_inw;
  sawsX = zx = meter_inw+fxw*0.02+(sd/100)*sawrange;
  sawsY = skyh-10+fxh*0.05;
  sawsW = max(50,min(180,fxw*0.2));
  sawsH = max(30,min(90,fxh*0.15));
  gfx_dest = 30;   gfx_x = slider2/100 * sawrange;   gfx_y = 0;
  gfx_a = 0.85;
  gfx_blit(15,1,0 , 0,0,100,60 , sawsX,sawsY,sawsW,sawsH );
  sawloc = sawhandleL + slider2/100 * sawrange;
  );


// Blit Zippo
//sawrange = fxw*0.4 - meter_inw;
sawrange = 100;
sawsX = meter_inw+fxw*0.02+(sd/100)*sawrange;
sawsY = skyh-20;
sawsW = max(50,min(180,fxw*0.2));
sawsH = max(30,min(90,fxh*0.15));

zipposize = 0.7;
gfx_dest = 30;   gfx_x = gfx_y = 0;
//gfx_a = 0.85;
gfx_a = 1;
zys = (0.2 + (0.8) * (fxratx/2) / fxraty );
zxs = (0.5 + (0.5) * (fxraty*0.4) / (fxratx) );

zx = 33  + distx * sawrange;
zy = 142;

zw = 100 ;//* zxs *2;
zh = 100 ;//* zys *2;


gfx_blit(5,1,0 , 0,0,100,100
, zx , zy , zw , zh);

sawloc = sawhandleL + slider2/100 * sawrange;



fxratx = 1;
fxraty = 1;


// Cloud
(mouse_x > (cloudx*2)*ret1) && (mouse_x < ((cloudx + cw)*2)*ret1) && (mouse_y > ((cloudy)*2)*ret1) && (mouse_y < ((cloudy+ch)*2)*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 1 ;
    );
  );


// Zippo
zmx1 = (zbx1 + zx) *2 -50;
zmx2 = (zbx2 + zx) *2 +5;
zmy1 = (zby1 + zy-10) *2 -5;
zmy2 = (zby2 + zy ) *2 +15;
zmw = zmx2-zmx1;
zmh = zmy2-zmy1;
(mouse_x > (zmx1)*ret1) && (mouse_x < (zmx2)*ret1) && (mouse_y > (zmy1)*ret1) && (mouse_y < (zmy2)*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 2 ;
    );
  );


// Flashlight
flmx = 240 ;
flmy = 165 + tlt1 * 15 ;
flmw = 65 ;
flmh = 38 ;

(mouse_x > (flmx*2)*ret1) && (mouse_x < ((flmx+flmw)*2)*ret1) && (mouse_y > (flmy*2)*ret1) && (mouse_y < ((flmy+flmh)*2)*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 3 ;
    );
  );

// Ceiling
cmx1 = 295;
cmx2 = 335 ;
cmy1 = ceily ;
cmy2 = cmy1 + 19 ;



(mouse_x > (cmx1*2)*ret1) && (mouse_x < (cmx2*2)*ret1) && (mouse_y > (cmy1*2)*ret1) && (mouse_y < (cmy2*2)*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 4;
    );
  );

// Lock/chain
div = 0.5;
(mouse_x > (locx/div)*ret1) && (mouse_x < ((locx+40)/div)*ret1) && (mouse_y > (locy/div)*ret1) && (mouse_y < ((locy+30)/div)*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 32;
    );
  );

amodd = lastcap;

// Binoculars

zeromx1 = 100;
zeromx2 = 220;
zeromy1 = 20;
zeromy2 = 80;
(mouse_x > (zeromx1)*ret1) && (mouse_x < (zeromx2)*ret1) && (mouse_y > (zeromy1)*ret1) && (mouse_y < (zeromy2)*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 31;
    );
  );


//å
(mouse_x > (680)*ret1) && (mouse_x < (740)*ret1) && (mouse_y > (0)*ret1) && (mouse_y < ((mtry[0]+mtry[3]))*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 40;
    mys = mouse_y;
    
    );
  );
(mouse_x > (680)*ret1) && (mouse_x < (740)*ret1) && (mouse_y > ((mtry[0]+mtry[3]))*ret1) && (mouse_y < ((mtry[3]+mtry[6]))*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 43;
    mys = mouse_y;
    
    );
  );
(mouse_x > (680)*ret1) && (mouse_x < (740)*ret1) && (mouse_y > ((mtry[3]+mtry[6]))*ret1) && (mouse_y < ((mtry[6]+mtry[9]))*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 46;
    mys = mouse_y;
    
    );
  );
(mouse_x > (680)*ret1) && (mouse_x < (740)*ret1) && (mouse_y > ((mtry[6]+mtry[9]))*ret1) && (mouse_y < ((mtry[9]+mtry[12]))*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 49;
    mys = mouse_y;
    
    );
  );
(mouse_x > (680)*ret1) && (mouse_x < (740)*ret1) && (mouse_y > ((mtry[9]+mtry[12]))*ret1) && (mouse_y < (mtry[15] *2 )*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 412;
    mys = mouse_y;
    
    );
  );




// Title
(mouse_x > (titx)*ret1) && (mouse_x < (titx+titw*1.2)*ret1) && (mouse_y > (tity*2)*ret1) && (mouse_y < (tity*2+tith*1.2)*ret1) ? (
  mouse_cap != 0 && cap_mode == 0 ? (
    cap_mode = lastcap = 99;
    );
  );






(cap_mode > 0) ? (
  dblclk == 0 ? dblclk = 1;
  );

dblclktime = 8;

dblclk == 1 ? (     mouse_cap != 0 ? (
    dblclkcnt += 1;
    (dblclkcnt > dblclktime) || (dragging == 1) ? (dblclk = -1; dblclkcnt = 0; dblr = 0;);
    mouse_cap > 10 ? dblr = 1;
    ):(
    dblclkcnt = 0;
    dblclk = 2;
    );
  );
  
dblclk == 2 ? (

// Re-Draw all at click on Title
  lastcap == 99 ? (
    drawall = 1;
    lastcap = dblclk = 0;
    );
  

  dblclkcnt += 1;
  dblclkcnt > dblclktime ? (dblclk = 0; dblclkcnt = 0; dblr = 0; );
  mouse_cap > 0 ? (
    dblclkcnt = 0;
    dblclk = 3;
    );
  mouse_cap > 10 ? dblr = 2;
  );

dblclk == 3 ? (     dblclkcnt += 1;
  dblclkcnt > dblclktime ? (dblclk = 0; dblclkcnt = 0; dblr = 0;);
  (mouse_cap == 0) && (dblr < 2) ? (
    dblclkcnt = 0;
    dblclk = 4;
    );
  mouse_cap > 10 ? dblr = 3;
  );




dblclk == 0 ? dblr = 0;

dblr == 3 ? (
  sawtype == 1 ? sawtype = 2 : sawtype = 1;
  dblr = dblclk = 0;
  upsaw = 2;
  
  );

mouse_cap > 0 ? (
  helpcnt += 1;
  helpcnt > 30 && help == 0 ? (
    cap_mode == 1 ? help = 1;
    cap_mode == 2 ? help = 2;
    cap_mode == 3 ? help = 3;
    cap_mode == 4 ? help = 4;
    cap_mode == 0 ? help = 30;
    cap_mode == 31 ? help = 31;
    cap_mode == 32 ? help = 32;
    
    cap_mode >= 40 ? help = 40;

    
    
    );
  ):(
  helpcnt = 0;
  );


// Dragging sliders

mouse_capold != mouse_cap ? (
  drag = 0;
  ):(
  mouse_cap > 1 ? (
    precise = 3;
    ):(
    precise = 1;
    );
  );
  
mouse_capold = mouse_cap;


cap_mode == 1 ? (
  drag == 0 ? ( 
    mys = mouse_y;
    sls = st;
    sl2s = slider20;
    drag = 1;
    );
  txt = 1;
  cy1 < ctop ? cy1 = ctop;  cy1 > cbot ? cy1 = cbot;
  slider1 = sls+ (mys - mouse_y)/cyr * min(1,fxh/gfx_h) * -stmin / precise^2;
  slider1 < -30 ? slider1 = -30;
  
  slider32 == 1 ? (
    slider20 = sl2s - sls+slider1;

    );
  
  slider_automate(slider1);
  );


slider1 != st ? (
  dragging = 1;
  st = slider1;
  upsky = upgrass = uptilt = 1;
  
  slider_automate(slider1);
  );
slider1 > 0 ? slider1 = 0;  st > 0 ? st = 0;



cap_mode == 2 ? (
  drag == 0 ? ( 
    mxs = mouse_x;
    sls = sd;
    drag = 2;
    );
  txt=2;
  slider2 = sd = sls+ (mouse_x-mxs)/dxr * dxr *0.5 / precise;
  slider_automate(slider2);
  upsaw=2;
  );

slider2 > 100 ? slider2 = 100;   slider2 < 0 ? slider2 = 0;

(slider2 != sd) || (slider2 != slider2old) ? (
  sd = slider2;
  distx = slider2/100;
  upsky = upgrass = uptilt = 1;
//  drawflash = 1;
  slider_automate(slider2);
//  upsawtooth = 1;
  upsaw=1;
  
  );
slider2old = slider2;




cap_mode == 3 ? (
  drag == 0 ? ( 
    mys = mouse_y;
    fyr = fxh;
    sls = slider12;
    drag = 3;
    );
  txt=3;
  slider12 = sls + ((mys-mouse_y)/fyr) * 10 / precise;
  slider12 > 6 ? slider12 = 6;
  slider12 < -6 ? slider12 = -6;
  uptilt = 1;

  );

lastcap == 3 ? (
  mouse_cap == 0 ? (
    slider12 = floor(slider12*10+0.5)/10;
//    lastcap = 0;
    );
  );
  
slider12 != slider12old ? (
  
  drawflash = 1;

  uptilt = 1;
  tlt_angle = slider12;

  );
slider12old = slider12;

tlt_sf = sf;
tlt_slider12 = slider12;






cap_mode == 4 ? (
  drag == 0 ? ( 
    mys = mouse_y;
    ceilys = (mys/2-ceily) + spad;
    sls = sc;
    sl2s = slider1;
    drag = 4;
    );
  txt = 4;
  mouse_cap > 0 ? slider20 = ((mouse_y/2-ceilys)/meter_lowy) * ((ceily/meter_lowy)^(1.33)/(ceily/meter_lowy)) * -meter_bot;
  slider20 < -12 ? slider20 = -12;
  slider_automate(slider20);

  slider32 == 1 ? (
    slider1 = sl2s - sls + slider20;
    slider1 > 0 ? slider1 = 0;
    slider1 < -30 ? slider1 = -30;
    txt = 14;
    upsky = 1;
    );
  );


slider20 != sc ? (
  dragging = 1;
  sc = slider20;
  drawceil = 1;
  );
slider20 > 0 ? slider20 = 0;  slider20 < -12 ? slider20 = -12;
sc > 0 ? sc = 0;

(lastcap == 4) && (dblclk == 0) && (mouse_cap == 0) ? (
  floor4cnt += 1;
  floor4cnt > 2 ? (
    slider20 = floor(sc*10+0.5)/10;

//    lastcap = 0;
    );
  );
mouse_cap != 0 ? floor4cnt = 0;


mouse_cap == 0 ? (
  cap_mode = drag = dragging = 0;
  dblclk == -1 ? dblclk = 0;
  );





gfx_set(0,0,0,1,0);
gfx_rect(0,0,spad,fxh);
gfx_rect(0,0,fxw,spad);
gfx_rect(fxw-spad,0,spad,fxh);
gfx_rect(0,fxh-spad,fxw,spad);




cap_mode == 2 ? (
  abs(mouse_x - mxs) > r ? (helpout = 1);
  ):(

// Enable help for buttons:
  (cap_mode != 31) && (cap_mode != 32) && (cap_mode > 0) ? (
    abs(mouse_y - mys) > r ? (helpout = 1);
    );
  );

cap_mode == 0 ? (
  helpout = 0;
  ):(
  upslider = 1;
  );
noob < 300 ? (
  noob += 1;
  help = 99;
  noob > 240 ? (
    nooba -= 1/60;
    ):(
    mouse_cap != 0 ? noob = 240;
    );
  helpboxa = nooba;
  );

grey = 0.01;
gfx_set(grey,grey,grey,helpboxa ,0);
gfx_setfont(7);
gfx_rect(fxw/2-helpboxw/2,gfx_texth * 0.2, helpboxw,gfx_texth*1.2);
help > 0 ? (
  gfx_set(0.85,0.85,0.75,helpboxa);
  gfx_x = fxw/2;
  gfx_y = gfx_texth * 0.3;

  help == 99 ? (

    intro = "Click-hold for help, double-click to reset.";
    gfx_measurestr(intro, introw, 0);
    helpboxw = introw + gfx_texth;
    gfx_x -= introw/2;
    gfx_a = nooba;
    gfx_drawstr(intro);
    );


  help == 1 ? (
    thrtxt = "Limiter threshold (dB)";
    gfx_measurestr(thrtxt, thrtxtw, 0);
    helpboxw = thrtxtw + gfx_texth;
    gfx_x -= thrtxtw/2;
    gfx_drawstr(thrtxt);
    );
  help == 2 ? (
    chartxt = "Character (%)";
    gfx_measurestr(chartxt, chartxtw, 0);
    helpboxw = chartxtw + gfx_texth;
    gfx_x -= chartxtw/2;
    gfx_drawstr(chartxt);
    );
  help == 3 ? (
    tlttxt = "EQ tilt (dB)";
    gfx_measurestr(tlttxt, tlttxtw, 0);
    helpboxw = tlttxtw + gfx_texth;
    gfx_x -= tlttxtw/2;
    gfx_drawstr(tlttxt);
    );
  help == 4 ? (
    outtxt = "Output (dB)";
    gfx_measurestr(outtxt, outtxtw, 0);
    helpboxw = outtxtw + gfx_texth;
    gfx_x -= outtxtw/2;
    gfx_drawstr(outtxt);
    );
  help == 31 ? (
  ahelpp = help;
  
    splms = 512/srate *1000;
    sprintf(splmstxt,"%f",spltxt);
    gfx_measurestr(splmstxt, splmstxtw, 0);
    zertxt = "Look-ahead (512spl = ";
    gfx_measurestr(zertxt, zertxtw, 0);
    helpboxw = zertxtw + splmstxtw + gfx_texth;
    gfx_x -= (zertxtw+splmstxtw)/2 ;
    gfx_drawstr(zertxt);
    gfx_drawnumber(splms,1);
    gfx_drawstr("ms)");
    );
  help == 32 ? (
    loctxt = "Link Threshold & Volume";
    gfx_measurestr(loctxt, loctxtw, 0);
    helpboxw = loctxtw + gfx_texth;
    gfx_x -= loctxtw/2;
    gfx_drawstr(loctxt);
    );
  
  help == 40 ? (
    outmtxt = "Dbl-click to set Output";
    gfx_measurestr(outmtxt, outmtxtw, 0);
    helpboxw = outmtxtw + gfx_texth;
    gfx_x -= outmtxtw/2;
    gfx_drawstr(outmtxt);
    );
  helpboxa <= 0 ? (
    help = 0;
    helpboxw = 0;
    );
  mouse_cap == 0 ? (
    helpboxa -= 0.1;
    ):(
    helpout == 0 ? (
      helpboxa += 0.1;
      ):(
      helpboxa -= 0.1;
      );
    );
  );

helpboxa < 0 ? helpboxa = 0;  helpboxa > 1 ? helpboxa = 1;





gfx_a = 0.8;
gfx_setfont(8);
txt > 0 && cap_mode == 0 ? (
  txta -= 0.02;    gfx_a = txta;
  txta <= 0.01 ? (
    txt = 0;
    gfx_a = 0.8;
    );
  ):(
  txta = 1;
  );


(txt == 1) || (txt == 14) ? (
  gfx_x = fxw/2 - gfx_texth*0.6;
  st < 0 ? (gfx_x -= gfx_texth*0.25);
  st < -10? (gfx_x -= gfx_texth*0.2);
  gfx_y = cloudy + gfx_texth*1.1;
  slider32 == 1 ? (
    txt = 14;
    );
  gfx_set(0.3,0.3,0.3,-0.5*txta,1);
  gfx_drawnumber(st,1);
  
  );


txt == 2 ? (
  txt2x = gfx_x = zx+zw/3.3;
  sd < 10 ? gfx_x += 4;
  sd == 100 ? gfx_x -= 4;
  sawtype == 1 ? gfx_x += 12;
  gfx_y = (fxh-gfx_texth *.8);
  gfx_set(0.8,0.8,0.8,0.7*txta,1);
  gfx_drawnumber(sd,0);
  );



txt == 3 ?(

  gfx_x = fxw * 0.8;
  slider12 < 0 ? gfx_x = fxw * (0.8 -slider12 * 0.005) - gfx_texth*0.3;
  gfx_y = fxh - gfx_texth * 1.8 - tlt_gain*fxh*0.007;
  slider12 > 0 ? gfx_y -= tlt_gain*2 ;
  gfx_set(0.5,0.5,0.5,1*txta,1);
  
  gfx_drawnumber(slider12+0.01*sign(slider12),1);
  );





(txt == 4) || (txt == 14) ? (
  gfx_x = fxw - meter_inw*2 -8 + max(0, -tlt1) * max(0, -slider20-9) *3;
//  slider20 < 0 ? (gfx_x -= gfx_texth*0.1);
  slider20 <= -10? (gfx_x -= gfx_texth*0.3);

  gfx_y = ceily + gfx_texth*1.4;
  
  slider32 == 1 ? (
    txt = 14;
    );
    
  sbri > 0.6 ? (
    gfx_set(1,1,1,-0.3*txta,1);
    ):(
    gfx_set(0.4,0.4,0.4,1*txta,1);
    );
  ceilval = slider20;
  gfx_drawnumber(ceilval-0.01,1);
  
  );



// RMS NUMBERS
gfx_set(0.65,0.7,0.78,0.8);

gfx_a = 0.8;

rmsicng = abs(rmsimtr_ - rmsimtr);
rmsicng > 0.1 ? (
  rmsimtr = rmsimtr_;
  );

rmsimtr < -128 ? rmsimtr = -128;

state > 0 ? RMSmeter = rmsimtr;
RMSmeter > -80 ? (
  gfx_setfont(1);
  RMSmeter > -10 ? (
    gfx_x = spad + meter_inw/3 - gfx_texth*0.2;
    ):(
    gfx_x = spad + meter_inw/3 - gfx_texth*0.5;
    );
  gfx_y = rmsy = fxh - gfx_texth*1.9;
  (RMSmeter > -1) && (RMSmeter < 0) ? (
    gfx_drawstr("-0");
    ):(
    gfx_drawnumber(RMSmeter,0);
    );
  gfx_setfont(2);
  gfx_y += gfx_texth * 0.2;
  gfx_x += r;
  gfx_drawstr(".");
  gfx_drawnumber( (abs(RMSmeter)-floor(abs(RMSmeter)) ) *10,0);
  );
gfx_setfont(9);
gfx_x = spad+meter_inw/3 - gfx_texth*0.5;
gfx_y = fxh - gfx_texth*1.35;
gfx_a = 0.6;
gfx_drawstr("RMS");
gfx_x = fxw - meter_inw/3*2 - gfx_texth*1.1;
gfx_drawstr("RMS");
gfx_x = fxw*0.52;
gfx_drawstr("RMS + ");
rmsgx = gfx_x;



rmsocng = abs(rmsomtr_ - rmsomtr);
rmsocng > 0.1 ? (
  rmsomtr = rmsomtr_;
  );


rmsomtr < -128 ? rmsomtr = -128;

rmsomtrold = rmsomtr;


state > 0 ? RMSout = rmsomtr;
RMSout > -80 ? (
  gfx_setfont(1);
  gfx_a = 0.8;
  RMSout > -10 ? (
    gfx_x = fxw - spad - meter_inw/3 - gfx_texth*1.0;
    ):(
    gfx_x = fxw - spad - meter_inw/3 - gfx_texth*1.4;
    );
  gfx_y = rmsy;

  (RMSout > -1) && (RMSout < 0) ? (
    gfx_drawstr("-0");
    ):(
    gfx_drawnumber(RMSout,0);
    );
  gfx_setfont(2);
  gfx_y += gfx_texth * 0.2;
  gfx_x += r;
  gfx_drawstr(".");
  gfx_drawnumber((abs(RMSout)-floor(abs(RMSout)) )*10,0);
  );




RMSmeter > -80 && RMSout > -80 ? (
  gfx_setfont(1);
  gfx_x = rmsgx;
  gfx_y = fxh - gfx_texth * 1.25;
  RMSg = ceil( (RMSout-RMSmeter) *10)/10;
  RMSg >= 0 ? gfx_x += (gfx_texth * 0.35);
  gfx_a = 0.8;
  gfx_drawnumber(RMSg,0);
  gfx_setfont(2);
  gfx_y += gfx_texth * 0.2;
  gfx_drawstr(".");
  gfx_drawnumber((abs(RMSg)-floor(abs(RMSg)) )*10,0);

  );

mtracc = 1.07;
mtrdec = 1.03;

mtr1 < mtr1old ? (
  mtr1d = 1;
  mtr1stop = mtr1;
  ):(
  mtr1d = 0;
  );



shootspd = 0.02;
mtr1d < mtr1dold ? (
  mtr1gowish = 1;
  );
mtr1gowish == 1 ? (      mtr1tmr += 1;
  mtr1tmr > 15 ? (
    mtr1gowish = 2;
    mtr1tmr = 0;
    );
  );

mtr1go == 0 ? (
  mtr1top = 1; mtr1bot = 1;
  mtr1gowish == 2 ? mtr1go = 1;
  );
mtr1go == 1 ? (
  mtr1shoot_a < 0.22 ? (mtr1shoot_a += 0.05) : (mtr1shoot_a = 0.22);
  mtr1bot = max (0, 1 - (1-mtr1top) * 0.3);
  mtr1top > mtr1stop ? (
    mtr1top -= shootspd * 4 * (1-mtr1stop);
    ):(
    mtr1go = 2;
    );
  mtr1gowish = 0;
  );
mtr1top < 0 ? mtr1top = 0;
mtr1go >= 2 ? (
  mtr1bot -= shootspd * (1-mtr1top*0.5);
  mtr1bot < mtr1top ? mtr1go = 3;
  );
mtr1bot < 0 ? mtr1bot = 0;
mtr1go == 3 ? (
  mtr1shoot_a -= 0.07 * max(0, mtr1top) + 0.01;
  mtr1bot <= 0 ? mtr1go = 0;
  );
mtr1dold = mtr1d;
mtr1shoot_a < 0 ? mtr1shoot_a = 0;



mtr2 < mtr2old ? (
  mtr2d = 1;
  mtr2stop = mtr2;
  ):(
  mtr2d = 0;
  );



shootspd = 0.05;
mtr2d < mtr2dold ? (
  mtr2gowish = 1;
  );
mtr2gowish == 1 ? (      mtr2tmr += 1;
  mtr2tmr > 100 ? (
    mtr2gowish = 2;
    mtr2tmr = 0;
    );
  );
mtr2go == 0 ? (
  mtr2top = 1; mtr2bot = 1;
  mtr2gowish == 2 ? mtr2go = 1;
  );

mtr2go == 1 ? (
  mtr2shoot_a < 0.22 ? (mtr2shoot_a += 0.05) : (mtr2shoot_a = 0.22);
  mtr2bot = max (0, 1 - (1-mtr2top) * 0.3);
  mtr2top > mtr2stop ? (
    mtr2top -= shootspd * 4 * (1-mtr2stop);
    ):(
    mtr2go = 2;
    );
  mtr2gowish = 0;
  );
mtr2top < 0 ? mtr2top = 0;
mtr2go >= 2 ? (
  mtr2bot -= shootspd * (1-mtr2top*0.5);
  mtr2bot < mtr2top ? mtr2go = 3;
  );
mtr2bot < 0 ? mtr2bot = 0;
mtr2go == 3 ? (
  mtr2shoot_a -= 0.07 * max(0, mtr2top) + 0.01;
  mtr2bot <= 0 ? mtr2go = 0;
  );
mtr2dold = mtr2d;
mtr2shoot_a < 0 ? mtr2shoot_a = 0;




mtr3 < mtr3old ? (
  mtr3d = 1;
  mtr3stop = mtr3;
  ):(
  mtr3d = 0;
  );

shootspd = 0.2;
mtr3d < mtr3dold ? (
  mtr3gowish = 1;
  mtr3tmr = 0;
  );
mtr3gowish == 1 ? (      mtr3tmr += 1;
  mtr3tmr > 15 ? (
    mtr3gowish = 2;
    mtr3tmr = 0;
    mtr3rand = rand(1);
    );
  );
mtr3go == 0 ? (
  mtr3top = 1; mtr3bot = 1;
  mtr3gowish == 2 ? mtr3go = 1;
  );
mtr3go == 1 ? (
  mtr3shoot_a < 0.22 ? (mtr3shoot_a += 0.05) : (mtr3shoot_a = 0.22);
  mtr3bot = max (0, 1 - (1-mtr3top) * 0.3);
  mtr3top > mtr3stop ? (
    mtr3top -= shootspd * 4 * (1-mtr3stop);
    ):(
    mtr3go = 2;
    );
  mtr3gowish = 0;
  );
mtr3top < 0 ? mtr3top = 0;
mtr3go >= 2 ? (
  mtr3bot -= shootspd * (1-mtr3top*0.5);
  mtr3bot < mtr3top ? mtr3go = 3;
  );
mtr3bot < 0 ? mtr3bot = 0;
mtr3go == 3 ? (
  mtr3shoot_a -= 0.07 * max(0, mtr3top) + 0.01;
  mtr3bot <= 0 ? mtr3go = 0;
  );
mtr3dold = mtr3d;
mtr3shoot_a < 0 ? mtr3shoot_a = 0;


mtr4 < mtr4old ? (
  mtr4stop = mtr4;
  ):(
  mtr4d = 0;
  );
mtr4d < mtr4dold ? (
  mtr4gowish = 1;
  );
mtr4go == 0 ? (
  mtr4top = 1; mtr4bot = 1;
  mtr4gowish == 1 ? mtr4go = 1;
  );
mtr4go == 1 ? (
  mtr4shoot_a = 0.22;
  mtr4bot = 1;
  mtr4top > mtr4stop ? (
    mtr4top -= shootspd * 4 * (1-mtr4stop);
    ):(
    mtr4go = 2;
    );
  mtr4gowish = 0;
  );
mtr4go >= 2 ? (
  mtr4bot -= shootspd * (1-mtr4top*0.5);
  mtr4bot < mtr4top ? mtr4go = 3;
  );
mtr4go == 3 ? (
  mtr4shoot_a -= 0.07 * (mtr4top);
  mtr4shoot_a <= 0 ? mtr4go = 0;
  );
mtr4dold = mtr4d;



mtr1old = mtr1;
mtr2old = mtr2;
mtr3old = mtr3;
mtr4old = mtr4;


gfx_set(1,1,1,shoot_a + sbri*0.3);


gfx_a = mtr1shoot_a;

gfx_arc(fxw*0.6 - mtr1* fxw*0.03 , skyh*1.3  , skyh*1.0 ,
5.9 - 0.8 * (1-mtr1bot)  , 5.9 - 0.8 * (1- mtr1top )  ,antialias = 1); 

gfx_a = mtr2shoot_a;
gfx_arc(fxw*0.4 , fxh*1.05 , fxh*0.95 , 0.5 + (1-mtr2bot)^1.5 *1.2, 0.5 + (1- mtr2top )^1.5 *1.2 ,antialias = 1); 
gfx_a = mtr3shoot_a;
gfx_arc(fxw*1.5 - mtr3rand*fxw , fxh*0.3 , fxw*0.55 , 4.98-(1-mtr3bot)*0.42 , 4.98- 0.42 * (1- mtr3top ) ,antialias = 1); 

gfx_a = mtr4shoot_a;
gfx_arc(fxw*0.52 , fxh*0.7 , fxw*0.3 , 0.9, 0.9+ (1- l5pmtr ) ,antialias = 1); 
gfx_arc(fxw,fxh , fxh*0.92 + l5mtrbot * 30 , 6.05-abs(l9mtrd-1)*(l9mtr-l9mtrmin), 6.05 - (1- l9mtrmin ) ,antialias = 1); 


mtr1d == 1 ? (
  mtr1go < 3 ? (
    gfx_set(1,1,1,1);
    gfx_arc(fxw*0.6 - mtr1* fxw*0.03 , skyh*1.3  , skyh*1.0 , 5.9- (1-mtr1top)*0.802, 5.9 - (1- mtr1top )*0.8 ,antialias = 1); 
    );
  );
mtr2d == 1 ? (
  (mtr2go > 0) && (mtr2go < 3) ? (
    gfx_set(1,0.8,0,0.7);
    gfx_set(1,1,1,1);
    gfx_arc(fxw*0.4 , fxh*1.05 , fxh*0.95 , 0.5 + (1-mtr2top)^1.5 *1.2, 0.5 + (1- mtr2top )^1.5 *1.21 ,antialias = 1); 
    );
  );
mtr3d == 1 ? (
  (mtr3go > 0) && (mtr3go < 3) ? (
    gfx_set(0.6,1,1,1);
    gfx_arc(fxw*1.5 - mtr3rand*fxw , fxh*0.3 , fxw*0.55 , 4.98-(1-mtr2top)*0.42 , 4.98- (1-mtr2top)*0.421 ,antialias = 1); 
    );
  );
























































// 
gfx_dest = 6;
gfx_x = fxw/3;  gfx_y = skyh+spad*3 ;  gfx_getpixel(grr,grg,grb);

startup < 100 ? startup += 1 ;


// Blit Master 30
gfx_dest = -1;
gfx_set(1,1,1,1,0);
gfx_x = gfx_y = 0;
//gfx_blit(30,1,0,  0,0,fxw,fxh , 0,0,gfx_w,gfx_h);
gfx_blit(30  ,gfx_ext_retina,0);




// Blit stars
gfx_a = 1 - sbri*1.25 - dred*0; gfx_mode = 0;
//gfx_blit(3,1, (starx)/gfx_w - 0.25 , starx,0,gfx_w,gfx_h , spad*fxratx,spad*fxraty,gfx_w-spad*2*fxratx,gfx_h );
gfx_blit(3,1, (starx)/gfx_w - 0.25
 , starx,0,fxw*2,fxh*1 , spad,spad,(fxw*2-spad*2)/2*gfx_ext_retina,fxh/2*gfx_ext_retina );

 
 
 

// Blit Title
gfx_dest = -1;
gfx_set(1,1,1,0.3 * (sbri+1),0);
gfx_x = titx = (meter_inw*2.5)/2*gfx_ext_retina;
gfx_y = 0;
gfx_blit(9,gfx_ext_retina,0);



/*
BLIT destinations:
-1 screen
1 Sky
2 Grass
3 Stars
4 Flashlight
5 Zippo                    
//6 Grass Mountain
//7 Mountain
8 Six tilted
9 Title
10 Meterlines
11 Draw Cloud
12 
13 Ceiling
14 Clock
15 Saw + teeth + blur

19 Title scaling
20 Draw mount 1
21 Draw mount 2
23 Mounts combined

30 Master
31 Meters

*/


