desc:CompLab  0.81  [mrelwood]

/* TO BE DONE:
- Autovolume for PreComp
- Waveform scaling with window resize

Version history:

0.81
- Separated Stereo L/R mode, previous renamed to Stereo L+R

0.8
- Much more precise metering
- Minor gfx improvements
- Mono source: Add Mid & Side
- Mono out ch selection
- New 50ms Pre-Comp feature!
- Fixed compressor hold, and increased to 100ms
...
- Fixed sidechain throughput

0.71
- Bug fixes and refinements

0.7
- New autovolume
- All parameters now support global Undo
- Added adjustable Attack Limiter
- Advanced M/S processing to retain stereo field
- Reworked attack and release shapes
- Mouse drag refinements




slider1:0<-60,0,0.1>-Threshold (dB)
slider2:.35<0,1,0.01>-Attack
//slider3:.0975<0,1,.01>-Hold
slider3:0<0,1,.01>-Hold
slider4:.407<0,1,0.01>-Release

slider5:2<.1,10,.01>-Detector Width
slider6:0<0,1,.01>-Detector HP (f scale)
slider7:1<0,1,.01>-Detector LP (f scale)
slider8:3<1,5,1>-Detector steepness

//slider8:.6<0,1,0.01>Stereo Link
slider9:1<0,1,0.01>-Mix
slider10:0<-60,30,0.1>-Volume

//slider11:2<0,2,1{Mono,Stereo L/R,Stereo M/S}>-Stereo mode
slider11:3<0,3,.1>-Stereo mode
slider12:.5<0,1,.01>-M/S side preboost
slider13:.4<0,1,.01>-Release shape
slider14:.75<0,1,.01>-Ratio
slider15:.5<0,1,.01>-Attack shape
slider16:0.027<0,1,.01>-Attack Limiter
slider17:0<-100,0,.01>-PreComp
//slider17:800<800,5000,1>Attack Limiter Speed
//slider17:0<0,1,1>Attack Limiter Speed

slider20:0<0,1,1{Enable,Disable}>-Disable Scope
slider21:0<0,1,1{Input,Input + GR}>-L/R Meter Source
slider22:1<0,1,1>-Allow unsafe release
slider23:1<0,1,1{No,Yes}>-Auto Volume
//slider24:0<0,3,1{Left,Right,Mid,Side}>Mono source
slider24:2<0,3,.1>-Mono source
slider25:1<0,1,1{Output,GR}>-Oscilloscope source #2
slider26:1<0,1,1{Hz,samples}>-Short hold display
slider27:0<0,3,1{Internal,Ch 3,Ch 4, Ch 3+4}>-Sidechain source
slider28:0<0,1,1{No,Yes}>-Attack limiter follows Ratio
slider29:0<0,1,1{Original,Dual mono 1-2}>-Mono out ch


slider63:4<0,4,1>-M/S mode
slider64:0<0,1,.01>-M/S Link

@init

ver = .81;

pi = 3.14159265358979323;
comp.compg == 0 ? comp.compg = 1;
compR.compg == 0 ? compR.compg = 1;

pdc_bot_ch=2; pdc_top_ch=0;
pdc_delay = 0;
sli17 = red17 = 0;

srscale = srate/48000;
osh1min = .15;

// BUFFERS

slize = 10000;
slimi = slize +65;
slima = slimi +65;
slixran = slima +65;
moucap = slixran + 65; // 2
slibuf = moucap + 65; // sliders
pdcbuf = slibuf + 65;
freebuf = pdcbuf + 2000;

memset(pdcbuf,0,2000);

function slizemima(mi ze ma id)(
	slize[id] = ze;
	slimi[id] = mi;
	slima[id] = ma;
);

slizemima(-60,0,0, 1);
slizemima(0,.43,1, 2);
slizemima(0,.0975,1, 3);
slizemima(0,.316,1, 4);
slizemima(0,0,1, 6);
slizemima(0,1,1, 7);
slizemima(1,3,5, 8);
slizemima(0,1,1, 9);
slizemima(-60,0,30, 10);
slizemima(0,3,3, 11);
slizemima(0,.5,1, 12);
slizemima(0,.4,1, 13);
slizemima(0,.75,1, 14);
slizemima(0,.5,1, 15);
slizemima(0,.027,1, 16);
slizemima(-100,0,0, 17);
slizemima(0,0,1, 20);
slizemima(0,.85,1, 22);
slizemima(0,0,3, 24);
slizemima(0,0,1, 29);



function upslibuf()
	instance(ss)(
	ss = 1;
	loop(27,
		slibuf[ss] = slider(ss);
		ss += 1;
		ss == 17 ? ss = 20 :
		ss == 29 ? ss = 63;
	);
);
	



function limiter_tmp(in thr)
	instance(ina thr2 relsp busg rel ovrscl ovrcur tgt outg limgo)(
	busg == 0 ? busg = 1;
	ina = abs(in);
	thr2 = thr * .8;
	relsp = .0003;
	
	busg < 1 ? (
		rel = busg * ( max(0, 1-ina/thr2) * (tgt/busg-1) * relsp ) +.0001;
	);
	
	ina > thr2 ? (
		ovrscl = max(0, ina/thr2 -1) / (thr2/thr) ;
		ovrcur = ovrscl/(ovrscl +1);
		
		tgt = thr2 + ovrcur * (thr-thr2);
		busg = tgt/ina;
		
	):(
//          limgo = 0;
		tgt = ina;
		busg = min(busg+rel , tgt/ina) ;
		p=0;
	);
	
	outg = busg;
	
);
function limiter(in)
	instance(ina relsp busg rel ran ovrscl ovrcur tgt outg limgo ovrc)(
	busg == 0 ? busg = 1;
	ina = abs(in);
//     thr2 = thr * .8;
	ran = limthr * 2;
	relsp = .0003;
	
	outg < 1 ? (
		rel = (1-busg) * ( max(0, 1-ina/limthr) * (tgt/busg-1) * relsp ) +.0001;
	);
	
	ina > limthr ? (
		ovrscl = max(0, ina/limthr -1) / (limthr/ran) ;
		ovrcur = ovrscl/(ovrscl +1);
		
		tgt = limthr + ovrcur * (ran-limthr);
	):(
//          limgo = 0;
		tgt = ina;
		p=0;
	);

	outg = (tgt+.0001)/(ina+.0001);
	
	
);




function comp36(in thr att rel) // 0v6
  instance(ina inadir inaold inadirc flt fltc fltc2 fltg
   ovr attc relc compg reladd compg2 mongr)(
  
  
  ina = abs(in);
  inadir = ina-inaold;
  inadir > 0 ? inadirc += 1 : inadirc = 0;
  inaold = ina;
    
  ina > flt ? (
	flt = ina;
	fltc = fltc2 = 0;
  ):(
	fltc += 1;
	ina > flt*.9 && inadir > 0 ? fltc *= 0;

	flt -= (tfl= max(0,(fltc*(fltc/hold))/hold) )*tfl * (tfi=flt-ina)*tfi *.1 / (1+max(0,inadir)*1000);
	flt -= max(0,-inadir) * ina * flt/ina * .07;
	 
	flt < ina ? flt = ina;
   );
   
   fltg = flt * compg;
   ovr = max(0, (fltg)/thr -1);
   ovr > 0 ? (
	attc += 1;
	relc = 0;
	compg /= 1+( (1-slider15)^1.5 * min(1, (attc)/(attack) )^.25  // Trumpet
	+slider15^1.5 * min(1, (attc/attack)^4 *.85 + (attc/attack)*.15) // Bell
	  ) *max(0,fltg/thr-1) /(1+ attack *(.5 -.4 *slider15) ); 

   ):(
	attc = 0;
	relc += 1;
	
	reladd = (1-slider13)^1.4 *
	min(1, (relc)/(release))^.5 * (1-compg*.8) / (release*.35) // Straight
	+ slider13 *
	min(1, (relc)/(release))^.5 * (1-compg*.7)^4 / (release*.06); // Opto
	
	compg += min(reladd, (thr/ina-compg)/1);
	
	compg > 1 ? compg = 1;
   );


	flt > 1 ? flt = 1;
	flt < 0 ? flt = 0;
  compg > 1 ? compg = 1;
  compg < 0.0001 ? compg = 0.0001;
  compg2 = compg * ratio + (1-ratio);
  
  mongr = min(compg2 *mix+(1-mix),mongr) ;
	compg2 ;
);


function comp3(in thr att rel) // 0v7
  instance(ina inadir inaold inadirc flt fltc fltc2 fltg tfh tfin
   ovr attc attm attrst relc compg reladd compg2 mongr monlimgr limg lim.limgo busg)(
  
  
  ina = abs(in);
  inadir = ina-inaold;
  inadir > 0 ? inadirc += 1 : inadirc = 0;
  inaold = ina;
    
  
  ina > flt ? (
	flt = ina;
	fltc = fltc2 = 0;
  ):(
	fltc += 1;
	ina > flt*.9 && inadir > 0 ? fltc *= 0;
//     flt -= (tfh= max(0,(fltc*(fltc/hold))/hold) )*tfh * (tfin=flt-ina)*tfin *.1 / (1+max(0,inadir)*1000);
	flt -= (tfh= max(0,(fltc-hold*.6)/hold) )*tfh * (tfin=flt-ina)*tfin *.1 / (1+max(0,inadir)*1000);
	flt -= max(0,-inadir) * ina * flt/ina * (fltc>(hold*.6)) * .07;
	 
	flt < ina ? flt = ina;
   );
   
   fltg = flt * compg;
   ovr = max(0, (fltg)/thr -1);
   ovr > 0 ? (
	attc += 1;
	relc = 0;
	attrst = 0;
	compg -= min(max(0,compg-thr/flt) ,(slider15^1.25 * min(2, (attc)/(attack) +.57 )^3
	  *(1) /attack) // Bell 200ms
	 + (1-slider15)^1.25 * ovr * min(1, (attc)/(attack) )^.25
	  *(.5 ) /attack // Trumpet;
	);
	
   ):(
	attrst += .1;
	attc > 0 ? attc -= attrst^3 : attc = 0;
	attc < 0 ? attc = 0;
	
	relc += 1;
	
	reladd = (1-slider13)^1.4 *
	min(1, (relc)/(release))^.5 * (1-compg*.8) / (release*.35) // Straight
	+ slider13 *
	min(1, (relc)/(release))^.5 * (1-compg*.7)^4 / (release*.06); // Opto
	
	compg += min(reladd, (thr/flt-compg)/1);
	
	compg > 1 ? compg = 1;
   );
   
   slider16 > 0 ? (
		busg = this.lim.limiter(ina*compg);
		limrat == 1 ? busg = 1- (1-busg) * ratio;
/*
		ina > limthr ? busg = this.lim.limiter(ina) :
			busg = 1;
*/
		busg <= limg ? (
			limg = busg;
			
			limdsp_ = min(limdsp_,limg);
		):(

			limdsp = min(limdsp,limdsp_);
			limdsp_ = 1;
			
			limg += ((1-limg) +.01) * limrel ;
//               limg += (1) * limrel * (1-limg^8);
//               limg += .5 * limrel;
	//          limg = busg;
		);
	):(
		limg = 1;
	);



	flt > 1 ? flt = 1;
	flt < 0 ? flt = 0;

  compg > 1 ? compg = 1;
  compg < 0.0001 ? compg = 0.0001;
  compg2 = compg * ratio + (1-ratio);
  
  mongr = min(compg2 *mix+(1-mix),mongr) ;
  monlimgr = min(limg *mix+(1-mix),monlimgr) ;

	red = max(red, 1-limg^1.5);

	compg2 *limg;
);





function eqini(f hplpap poles)
	instance(omega sinf cosf alpha b0 b1 b2 a0 a1 a2 w f Q wf width)(
	this.poles = poles;
	omega = 2*pi*f/srate;
	
	sinf   = sin(omega);
	cosf   = cos(omega);
	
	this.f = f;
//     w = (wf = (f/20000)^1.75) + (1-wf) * (width=2);
//     w = (wf = (f/20000)^3) + (1-wf) * (width=2.5);
//     w = (wf = (f/20000)^.5 ) + (1-wf) * (width=slider5);
//     alpha = sinf*sin( log(2)/w * 20 * omega/sinf );   //(if bandwidth is specified)

	Q = 1/slider5;
	alpha = sinf/(2*Q);                                   //  (if Q is specified)
	
	hplpap == 1 ? (  
		b0 =  (1 + cosf)*.5;
		b1 = -(1 + cosf);
		b2 =  (1 + cosf)*.5;
		a0 =   1 + alpha;
		a1 =  -2 * cosf;
		a2 =   1 - alpha;
	);

	hplpap == 2 ? (
		b0 =  (1 - cosf)*.5;
		b1 =   1 - cosf;
		b2 =  (1 - cosf)*.5;
		a0 =   1 + alpha;
		a1 =  -2 * cosf;
		a2 =   1 - alpha;
	);
	
	hplpap == 3 ? (
		b0 =   1 - alpha;
		b1 =  -2*cosf;
		b2 =   1 + alpha;
		a0 =   1 + alpha;
		a1 =  -2*cosf;
		a2 =   1 - alpha;
	);
	
);

function eqpole(in)
	instance(in1 in2 out out1 out2 b0 b1 b2 a0 a1 a2)(
	
//     this..testhpfpole = 10;
	
	out = (this...b0/this...a0)*in + (this...b1/this...a0)*in1 + (this...b2/this...a0)*in2
	 - (this...a1/this...a0)*out1 - (this...a2/this...a0)*out2;
	in2 = in1;
	in1 = in;
	out2 = out1;
	out1 = out;
);

function eq(in)
	instance(out)(
	
	out = this.p1.eqpole(in);
	this..poles > 1 ? out = this.p2.eqpole(out);
	this..poles > 2 ? out = this.p3.eqpole(out);
	this..poles > 3 ? out = this.p4.eqpole(out);
	this..poles > 4 ? out = this.p5.eqpole(out);
	
	out;   
);

  
function upslider()(

//     pdc_delay = floor(slider30 *srate*.05);
//     prems = pdc_delay/srate *1000;
	pdc_delay = (-slider17*.001) *srate;
	pdc_delay = (-slider17*.001) *srate;
	prems = -slider17;
	pdc_delay == 0 ? pdcpos = 0;
	slixran[17] = 2;

	sl_thr = 2^(slider1/6);
	sl_att = slider2;
	attack = 1+ (sl_att)^2.5 *10000 * srscale;
	attime = attack/srate *1000;
	
	limthr = (sl_thr*32)/(1+31* slider16);
//     limthr /= 1 + attack*.01;
	limthrdb = 20* log10(limthr/sl_thr *2);
	limrel = (100+3000*(t16=1-slider16)*t16) /(sl_att*10 +1) /srate;
	
	limrel = 50/srate;
	limrel = min(8000,160000/(1+sl_att*300)) /(t161=1+slider16)*t161 /srate;
	limrel = (min(4500, 60000/attime)/(1+slider16*slider16 *2) ) /srate;
	limrelmul = limrel * srate;
	
	limrat = slider28;
/*
A3 L.5 3000
A3 L1 2000

A10 2000 1000
A20 2000 1000
A40 1000 500
A80 500 300
A160 300 50



/*     
	sl_hold = ((1-slider3)^2 * 1000 +20)  * srscale;
	hold = srate/sl_hold;
//     holdtime = 1000/srate *hold;
	holdtime = hold/srate *1000 /4;
	holdhz = sl_hold*4;
*/     
//     hold = (slider3^(1.5+slider3*1.5) * srate/25 +12*0) * srscale;
//     hold = ((slider3*.78 +.18)^(5) * srate/10 ) * srscale;
//     hold = ((slider3*.78 +.18)^(5) * srate/20 ) + (slider2)^1 *20 *0; //40ms
	hold = ((slider3*.9001 +.1)^(4) * srate/5 ) + (slider2)^1 *20 *0; // 100ms
	holdtime = hold/srate *1000 *.5;
	holdhz = srate/hold /4;
	
//     hold2 = hold + srate/10 * slider3^2 *400;
//     slider22 == 0 ? safehz = 20000 : bassafe = srate/slider22/4;



	slider22 == 0 ? safeholdhz = srate*.5 :
	 safeholdhz = 20 + ( (1-slider22)^3 + (1-slider22)*.02 )/1.02 * 9980;
	safehold = srate/safeholdhz/4;
	
	
	holdtime < 1 ? (
		holdstr1 = floor(hold);
		holdstr2 = " spl";
	):(
		holdstr1 = holdtime;
		holdstr2 = " ms";
	);
	
	holdhz < 40 ? (
		holdstr1 = holdtime;
		holdstr2 = " ms";
	):(
		holdstr1 = holdhz;
		holdstr2 = " Hz";
	);
	
	
	holdhz < 40 ? (
		holdstr1 = holdtime;
		holdstr2 = " ms";
	):(          
		slider26 == 0 ? (
			holdhz > 1000 ? (
				holdstr1 = holdhz/1000;
				holdstr2 = " KHz";
			):(
				holdstr1 = holdhz;
				holdstr2 = " Hz";
			);          
			
		):(
			holdstr1 = floor(hold);
			holdstr2 = " spl";
		);
	);
	
	
		
//     hold = 0;


	sl_rel = slider4;
//     release = (1+ ((sl_rel^5+sl_rel/20) /1.05) *200000)  *srscale;
//     release = (4+ ((sl_rel^5+sl_rel/20) /1.05) *200000)  *srscale;
	nosafe ? relmin = srate/5000 : relmin = srate/100;
//     release = ( relmin + (sl_rel^6+sl_rel/50)/1.02 *srate *5);
	release = ( relmin + (sl_rel^5+sl_rel/20)/1.05 *srate *5);
//     release = sl_rel^3 *srate *4;
//     release = 100;
//     reltime = 1000/srate *release *2;
//     reltime = 1000/srate *release * (1+(release/200001)^.25) ;
//     reltime = 1000/srate *release * (1+ atan(release/200001 *100) ) / (1+release/200001)   ;
	reltime = 1000/srate *release  ;
	relmax = 5335;
	compexp = comp.exp = .2 + slider13^3 *20;
//     relmul = (1-(1-slider13)^3);
	relmul1 = .5- cos( (1-(t13=1-slider13)*t13) *3.14)*.5;
//     relmul = relmul1 / (1+ sl_rel^2.6 *300); // 50ms ok (rels .16)
//     relmul = relmul1 / (1+ sl_rel^3.3 *300); // 200ms ok (.36)
//     relmul = relmul1 / (1+ sl_rel^3.4 *300); // 500ms ok (.5)
//     relmul = relmul1 / (1+ sl_rel^3.5 *300); // 1000ms ok (.62)
	
	relmul = relmul1 / (1+ sl_rel^2.3 *170); 
	reldiv = (release*(1 + (slider13^2.4 + slider13/20)/1.05 *20));
//     reladd = ((1-(1-slider13^2))^.5 +slider13)/2 / release *2.2;
//     reladd = (slider13^.5)^1.5 / release *2.2;
//     reladd = (.5- cos(slider13^.5 *3 -.1)/2)^.75 / release *2.2;
//     reladd = ((.5-cos(slider13*3.14)/2)^.5 +slider13)/2 / release *2.2;
//     reladd = ((.5-cos(slider13^.8 *3.14)/2) +((1-slider13^.4) * slider13^1.3)^2
//      * 20) *2.2 / release ;
//     reladd = (((1-slider13) * slider13^.9)^1.4 * 2.7 + slider13^1.6) /10000  ;
	reladd = (((1-slider13) * slider13^.9)^1.4 * 2.7 + slider13^1.6) /
		(200 + 80000 * sl_rel^5)
	  ;
//     reladd = (0 + slider13^1.2) /10000  ;
	 
	 
	sl_relshape = slider13;

//     ratio = slider14^3 *19;
	ratio = slider14 ;
	
	width = slider5;
	
	slider7 = min(1, max(slider6 + .1*0, slider7));
	fhp = (fhpmin = 10) + slider6^3 * 9990;
	flp = 50 + slider7^3 * 19950;
	flpmax = 20000;
	
	poles = floor(slider8+.5);
	
	//whp = (whpf = (fhp/2000)^1.75) + (1-whpf) *   2   ;
	//whp = (whpf = (flp/2000)^1.75) + (1-whpf) *   2   ;
	
	hpf.eqini(fhp,1,poles);
	lpf.eqini(flp,2,poles);
	apf1.eqini(fhp,3,poles);
	apf2.eqini(flp,3,poles);
	
	stereo = floor(slider11+.5); // 0 = L/R, 1 = M/S
	
	osoff = slider20;
	autovolena = slider23;
	
	
/*
	slider12 < .6 ? (
		slider12 = 0;
		stereo = 0;
	) :
	slider12 < 1 ? (
		slider12 = 1;
		stereomode = 1;
	) :
*/
	
//     msbal = .5 + slider12^2 *4;
	
//     msbal = .5 + 20*log10(slider12)*12;
//     msbal = 2^((sidedb= slider12*18-9)/6) *1.3;
	msbal = 2^((sidedb= slider12*18-9)/6) *1.0;
	
//     sprintf(sidedb,"%.1s",sidedb);
	
	//msbal = 2;     // M/S mode mid channel attenuate
	
	
	mixexp = .5;
	mix = slider9^.5;
	mixdry = (1-slider9)^mixexp;
	amt = (slider1/-60) * slider9;
	//volout = 2^( (slider10 + (amt^3*8)*(1+(sl_rel+.3*slider6^2)*(.6+sl_att))/(1+sl_att^1.5 *4)   ) /6);
	volout = 2^( (slider10 + slider23*(
/*
		autovol = (amt^2*17)
		* (1+ (sl_rel^.8 *(1+slider13*0 ) *1.7+.2*slider3^2) *(.6+sl_satt*0) )
		/(1+sl_att^1 *.8) *slider14
*/
//          autovol = (amt^2*55) * (1+ release/600000)

/*
		autovol = (max(0,amt-.1)^2 *42) * (1+ sl_rel^.5 *.3)
			/ (1+ sl_att^1 *3.5 *(1+ slider15 ) ) // Att +shape
			 *  (1+ slider3^.25 *.3 * (1-sl_rel)) // Hold
			 
		
*/
		rat97 = .5- cos( min(1,ratio/.97) *3.14)*.5;
		rat980 = max(0, (.5- cos( min(1,ratio/.97) *3.14)*.5) * (1-max(0,ratio-.98)/.02));
		rat20 = min(20,ratval);
		
		autovol = ( autoamt= max(0,(amt-.1)/.9)^1.4 *43) * (autorel= 1+ sl_rel^.5 *.2)
			/ (autoatt= 1+ sl_att^1.2 *(3+3*(1-amt*amt)) *(1.5+ .5*slider15 ) ) // Att +shape
			 *  (autohold= 1+  slider3^.25 *.15 * (tsl=1-sl_rel)*tsl)  // Hold
//                * (autorat= (ratio^10 + min(1,ratio/.9)*.3*(1-ratio)) /1.3 ) // Ratio
//                * (autorat= (ratio^10 + ((rat97^.5) *(1-ratio^3)  *.4 ) ) // Ratio
//                * (autorat= (ratio^10 + ratio*.5)/1.5 ) // Ratio
//                * (autorat= ((max(0, ratio^2 - rat980^.5 *.25) + ratio^1 *.4 )/1.4)^(.6+ratio *1.2)  )  // Ratio
		* (autorat= ((ratio^8 + rat97 *.1 + rat97^.7 *.5 -rat980^8*.1)/1.6)^1.25  )  // Ratio
//                * (autorat=  ((rat20-1)/19)^3  *1  ) // Ratio
		
	 )) /6);
	
	sidechain > 0 ? autovol *= .4;
	
	//slink = slider8;
	
	uptgt = 1;
);


function pdcdo()
	instance()(
	pdcbuf[pdcpos] = spl0;
	(pdcbuf2=ceil(pdcbuf+pdc_delay+1))[pdcpos] = spl1;
	pdcpos += 1;
	pdcpos >= pdc_delay ? pdcpos = 0;
	spl0 = pdcbuf[pdcpos];
	spl1 = pdcbuf2[pdcpos];
);

@serialize

store_01 = file_var(0, forcestereo);
store_02 = file_var(0, verold);


@slider

verold < .81 ? (
	stereo == 2 ? slider11 = stereo = 3;
);
verold = ver;

upslider();

sidechain = slider27;
poles = slider8;
mono = slider24;
mtrsrc = slider21;
limrat = slider28;
nosafe = slider22;
shohold = slider26;
autovolena = slider23;

mslink = slider64;

detini = 0;


@block

upslidergo ? (
	upslidergo = 0;
	upslider();
);

noob == 0 ? (
//     stereo = slider11 = 2;
	upslibuf();
	upslider();
);

noob = 1;

@sample

//spl2 = spl3 = 0; // TMP

/*
sl_thr == 1 ? (
	spl0 = _hpf.Ltmp.eq(spl0);
	spl0 = spl1 = _lpf.Rtmp.eq(spl0);
);
*/

// AUTO STEREO
/*
forcestereo == 0 ? (
	(spl0 == 0) || (spl1 == 0) || (spl0 == spl1) ? (
		stereoc = 0;
		monoc += 1;
		monoc > srate ? (
			spl0 == 0 && spl1 != 0 ? mono = 1 : mono = 0;
			stereo = stereoc = monoc = slider11 = 0;
			upslidergo = 1;
		);
	):(
		monoc = 0;
		stereo == 0 && (spl0 != spl1) ? (
			stereoc += 1;
			stereoc > srate ? (
				stereoc = monoc = 0;
				stereo = slider11 = 2;
				upslidergo = 1;
			);
		);
	);
);
*/

stereo == 0 && forcedmono == 0 &&
 ((mono == 0 && spl0 == 0) || (mono == 1 && spl1 == 0)) && (spl0 != spl1) ? (
	monoc += 1;
	monoc > srate ? (
		spl0 == 0 && spl1 != 0 ? mono = 1 : mono = 0;
		forcedmono = 1;
		monoc = 0;
	);
):(
	monoc = 0;
);

//stereo == 1 && stereomode == 1 ? stereo = 2;

//fhp > 20 ? compin = hpf.L.eq(compin);
//flp < 20000 ? compin = lpf.L.eq(compin);
sidechain > 0 ? osinsrc = max(abs(spl0),abs(spl1));

sidechain == 0 ? (
	compinL = spl0;
	compinR = spl1;
) :
sidechain == 1 ? (
	compinL = spl2;
	compinR = spl2;
//     spl2 = 0;
) :
sidechain == 2 ? (
	compinL = spl3;
	compinR = spl3;
//     spl3 = 0;
) :
sidechain == 3 ? (
	compinL = spl2;
	compinR = spl3;
//     spl2 = spl3 = 0;
);
//     compin = max(abs(spl0),abs(spl1));
fhp > fhpmin ? (
	 compinL = hpf.L.eq(compinL);
	compinR = hpf.R.eq(compinR);
);
//     compin = hpf.L.eq(compin);
flp < flpmax ? (
	compinL = lpf.L.eq(compinL);
	compinR = lpf.R.eq(compinR);
);

/*
mtrrst == 1 ? (
	monsplL2 = monsplL1;
	grsplL2 = grsplL1;
	monsplL1 = 0;
	grsplL1 = 1;
	mtrrst = 0;
);
*/
/*
slider25 == 0 ? (
	osin2 = max(osin2, max(busL,busR));
):(
	osin2 = min(osin2, min(outg,outgR));
);

stereo == 2 ? (premonL = abs(spl0+spl1)*.5; premonR = abs(spl0-spl1)*.5; ) :
stereo == 1 || mono == 0 ? premonL = abs(spl0) :
mono == 1 ? premonL = abs(spl1) :
mono == 2 ? premonL = abs(spl0+spl1)*.5 :
mono == 3 ? premonL = abs(spl0-spl1)*.5;
mtrsrc == 1 && sidechain == 0 ? (
	monsplL = max(monsplL, (premonL) *comp.compg2 );
	stereo > 1 ? monsplR = max(monsplR, premonR *compR.compg2);
):(
	monsplL = max(monsplL, (premonL) );
	stereo > 1 ? monsplR = max(monsplR,premonR);
);
*/

stereo == 0 ? (
//     compin = max(abs(compinL),abs(compinR));
	mono == 0 ? compinL = abs(compinL) :
	mono == 1 ? compinL = abs(compinR) :
	mono == 2 ? compinL = abs(compinL+compinR)*.5 :
	mono == 3 ? compinL = abs(compinL-compinR);

	outg = (comp.comp3(compinL,sl_thr,sl_att,sl_rel));
//     slider25 == 1 ? osin2 = min(osin2,outg) : osin2 = max(osin2,outg);
//     osin2 = min(osin2,outg);
	pdc_delay > 0 ? pdcdo();
	
	mono == 0 ? monsplL = max(monsplL , abs(spl0) );
	mono == 1 ? monsplL = max(monsplL , abs(spl1) );
	mono == 2 ? monsplL = max(monsplL , abs(spl0+spl1)*.5 );
	mono == 3 ? monsplL = max(monsplL , abs(spl0-spl1) );

	mono == 0 ? spl0 = (spl0 *= outg * volout * mix + mixdry) :
	mono == 1 ? spl1 = (spl1 *= outg * volout * mix + mixdry) :
	mono > 1 ? (
		busM = (spl0+spl1)*.5;
		busS = (spl0-spl1);
		
		
		
		mono == 2 ? busM *= outg * volout:
		mono == 3 ? busS *= outg * volout;
		
		spl0 = (busM + busS*.5) *mix + spl0 * mixdry;
		spl1 = (busM - busS*.5) *mix + spl1 * mixdry;
	);


	
/*
	slider25 == 1 ? (
		osin2 = min(osin2, min(comp.mongr,compR.mongr));
	):(
		osin2 = min(osin2, moninL * min(comp.mongr,compR.mongr));
	);
*/
/*
	mtrsrc == 1 ? (
		osin = max(osin,osinsrc * min(comp.compg2,compR.compg2) );
	):(
		osin = max(osin,osinsrc);
	);
*/     
	
//     mtrsrc == 1 ? moninL *= comp.compg2;
);
stereo == 10 ? (
	compinL = max(abs(spl0),abs(spl1));
//     fhp > fhpmin ? compin = hpf.L.eq(compin);
//     flp < flpmax ? compin = lpf.L.eq(compin);
	outg = (comp.comp3(compinL,sl_thr,sl_att,sl_rel));
//     spl1 = spl0 = (spl0 *= outg * volout);
);
stereo > 0 ? (
/*     stereo == 1 ? (
		compinL = abs(spl0);
		compinR = abs(spl1);
	):(
		compinL = abs(spl0+spl1)/2;
		compinR = (abs(spl0-spl1)/2 +compinL/2)/1.5 *msbal;
	);
	fhp > fhpmin ? compinL = hpf.L.eq(compinL);
//     compinL = hpf.L.eq(compinL);
	flp < flpmax ? compinL = lpf.L.eq(compinL);
	fhp > fhpmin ? compinR = hpf.R.eq(compinR);
//     compinR = hpf.R.eq(compinR);
	flp < flpmax ? compinR = lpf.R.eq(compinR);
//     compin = (compinL+compinR)/2;
//     outgL = (compl.comp3(spl0,sl_thr,sl_att,sl_rel)*mix +(1-mix)) * volout;
//     outgR = (compr.comp3(spl1,sl_thr,sl_att,sl_rel)*mix +(1-mix)) * volout;
*/
	stereo == 1 ? (
		compinL = max(abs(compinL),abs(compinR));
		outg = (comp.comp3(compinL,sl_thr,sl_att,sl_rel));

		
//          moninL = max(moninL,compin=(compinL+compinR)/2 );
//          moninL = max(moninL,compin=1(compinL+compinR)/2 + max(compinL,compinR))/2 );
		
/*          
		slider25 == 0 ? (
			osin2 = max(moninL * outg, osin2);
		):(
			osin2 = min(osin2,outg);
		);
*/     
		pdc_delay > 0 ? pdcdo();
		monsplL = max(monsplL , max(abs(spl0),abs(spl1)) );
		
		
		spl0 *= (outg *volout)*mix+mixdry;
		spl1 *= (outg *volout)*mix+mixdry;
	);
	stereo == 2 ? (
		compinL = abs(compinL);
		compinR = abs(compinR) * msbal;
		outgL = (comp.comp3(compinL,sl_thr,sl_att,sl_rel));
		outgR = (compR.comp3(compinR,sl_thr,sl_att,sl_rel));
		pdc_delay > 0 ? pdcdo();
		monsplL = max(monsplL , abs(spl0) );
		monsplR = max(monsplR , abs(spl1) );
		
		
		spl0 *= (outgL *volout)*mix+mixdry;
		spl1 *= (outgR *volout)*mix+mixdry;
	);
	stereo == 3 ? (
/*
	   compinL_ = abs(compinL+compinR)/2;
//          compinR = (abs(compinL-compinR)/2 +compinL/2)/2 *msbal;
//          compinL_ = ( abs(compinL+compinR) -abs(compinL-compinR) )/2;
		compinR = (abs(compinL-compinR)/1 )/1 *msbal;
//          compinR = (abs(compinL-compinR)/2 ) *msbal;
		compinL = compinL_ - compinR/2 *0;
*/
//          compinL_ = max(abs(compinL),abs(compinR)) * max(0, min((compinL/compinR),(compinR/compinL)) );
//          compinL_ = abs(compinL+compinR)/2;

		maxa = max(abs(compinL),abs(compinR));

slider63 == 1 ? (
		compinR_ = MIN( maxa , ABS(compinL-compinR)) ;
		compinL = maxa * (1-compinR_/maxa);
//          compinL = compinL_;
		compinR = compinR_ * 1.2 * msbal;
);
slider63 == 0 ? (
		compinR_ = (compinL-compinR);
		compinL = (compinL+compinR)*.5;
		compinR = compinR_ * 1.2 * msbal;
);
slider63 == 2 ? (
		compinL_ = (compinL+compinR)*.5;
		compinR = min(maxa, abs(compinL-compinR)*2 )*.5  *msbal;
		compinL = compinL_;
);
slider63 == 3 ? (
		mid = abs(compinL+compinR)*.5 *1;
		side = abs(compinL-compinR)*.5;
		side2 = min(maxa, side*2) ;
		side2 = max(maxa*.5, side*2);
//          compinL_ = (compinL+compinR)*.5;
		compinL__ = max(0, maxa - abs(compinL-compinR)*2);
//          compinL_ = (compinL__*.1 + mid*.9  );
		compinL_ = mid ;
//          compinL_ = compinL__;

//          compinR = (min(maxa, side *2 )*.5  + side*.5)/1.4  *msbal;
//          compinR = min(maxa, side  )  *msbal;
//          compinR = (side*2*0 + side*2 );
//          compinR = (abs(compinL)-abs(compinR))/2;
//          compinR = side^1 + maxa*.5;
		compinR = (tcm=(side2)/maxa)*tcm *.5 * maxa  *msbal  +maxa*.4;
//          compinR = side*.25 + side2*.25 + maxa*.5;
		compinL = compinL_;
);
slider63 == 4 ? (
		mid = abs(compinL+compinR)*.5;
		side = abs(compinL-compinR)*.5;
		mid2 = max(0, maxa -side*2);
		mid3 = max(0, mid/maxa *2 -1);
		side2 = min(maxa, side*2) ;
		side2 = max(maxa*.5, side*2);

//          compinL_ = mid2 ;
//          compinL_ = maxa - maxa * (1-(mid2/maxa))^3   ;
//          compinR = ((side2)/maxa)^2 /2 * maxa  *msbal  +maxa*.4;
//          compinR = maxa - (mid2/maxa)^.5 /4 ;
		compinR = (maxa - maxa * (tml=.5-cos(mid3 *3.14)*.5)*tml*tml*tml) *msbal;
		compinL_ = maxa - maxa * (tmr=.5+cos(mid3 *3.14)*.5)*tmr*tmr*tmr;


		compinL = compinL_ ;
);




			
		outg = (comp.comp3(compinL,sl_thr,sl_att,sl_rel));
		automono == 0 ? outgR = (compR.comp3(compinR,sl_thr,sl_att,sl_rel));
		
		pdc_delay > 0 ? pdcdo();
		
		monsplL = max(monsplL , abs(spl0+spl1)*.5 );
		monsplR = max(monsplR , abs(spl0-spl1) );
		
		
		busL = (spl0+spl1)*.5;
//          busR = (spl0-spl1)/2 *msbal *.5 ;
		busR = (spl0-spl1)*.5 *msbal ;
		
		


		slider63 == 0 ? outg *= (outgR * mslink + (1-mslink));
//          mslink = 0;
//          busL *= (outg * ((outgR+1)/2) *volout );
//          busL *= (outg *volout );
//          busL *= (min(outg,outgR) *volout );

		mslink1 = 1;
		ougli = mslink1 * min(outg,outgR) + (1-mslink1) * outg;
		mslink2 = mslink;
		ougliR = mslink2 * min(outg,outgR) + (1-mslink2) * outgR;
//          ougliR = outgR;

//          ougli = ougliR = 1;

		busL *= (ougli *volout );
//          busR *= (ougliR *volout ) /msbal;
		busR *= (ougliR *volout ) /msbal;
		
//          spl0 = (busL + busR/msbal)*mix + spl0 * mixdry;
		spl0 = (busL + busR) *mix + spl0 * mixdry;
		spl1 = (busL - busR) *mix + spl1 * mixdry;
		
//          spl0 *= outgR;
//          spl1 *= outgR;
		
		
	);
//     spl0 *= sterceng = 1- (1-compl.compg) * (1-compr.compg) *.5;
//     spl1 *= sterceng;
		
);
//stereo < 2 ? osin2 = max(osin2, osin * outg);


//     grsplL = min(grsplL, comp.mongr);
grsplL = min(grsplL,comp.compg2);
stereo > 1 ? grsplR = min(grsplR,compR.compg2);
	


/*
mtrsrc == 1 ? (
	osin = max(osin,osinsrc * min(comp.compg2,compR.compg2) );
):(
	osin = max(osin,osinsrc);
);
*/



/*
spl2 = outg- 2^(-3/6);
spl3 = outgR- 2^(-3/6);

spl3 = compinL-.1;
spl3 = comp.flt +.0*1;
*/
//spl2 = abs(compinL);
//spl3 = abs(compinL) + abs(compinR);
//spl2 = mid3;

//spl0 = spl1 = outmp;







@gfx 420 375


function line(val)(
	mtrxold = mtrxl;
	gfx_line(mtrxl=mtrx+ (2^((str+=val)/6))^grexp *mtrw , mtry-mtrlino,mtrxl,mtry2+mtrlino);
	gfx_x = mtrxl-9;  gfx_y = mtry2+8;
	gfx_drawnumber(str,0);
);

function rrectfil(x y w h r)
	instance()(
	gfx_rect(x+r,y,w-r*2,h ,1);
	gfx_rect(x,y+r,w,h-r*2 ,1);
	gfx_circle(x+r,y+r,r ,1);
	gfx_circle(x+w-r,y+r,r ,1);
	gfx_circle(x+r,y+h-r,r ,1);
	gfx_circle(x+w-r,y+h-r,r ,1);
);

function area(x y w h r)
  instance(noy rr gg bb aa)(
  this.x = x = floor(x);
  this.y = y = floor(y);
  this.w = w = ceil(w);
  this.h = h = ceil(h);
  rr = gfx_r;
  gg = gfx_g;
  bb = gfx_b;
  aa = gfx_a;
  
  x = ceil(x);
  y = ceil(y);
  w = ceil(w);
  h = ceil(h);
  
  
  gfx_set(0,.0,0,1,0);
  rrectfil(x,y,w,h,r);
  gfx_set(rr,gg,bb,aa);

  gfx_line(x+r+1,y , x+w-r-1,y );
  gfx_line(x+r+1,y+h , x+w-r-1,y+h );
  gfx_line(x,y+r+1 , x,y+h-r-1 );
  gfx_line(x+w,y+r+1 , x+w,y+h-r-1 );
  gfx_arc(x+r,y+r , r,-1.57,0 ,0);
  gfx_arc(x+r,y+h-r , r,-3.14, -1.571 ,0);
  gfx_arc(x+w-r,y+r , r,0,1.57 ,0);
  gfx_arc(x+w-r,y+h-r , r,1.571,3.14 ,0);
  
  
);

//mouse_cap > 1 ? gfxini = 0;

gfx_w != gfx_wold || gfx_h != gfx_hold || gfxnoob == 0 ? gfxini = 0;

//gfxini = 0;
gfxini == 0 ? (
	gfxini = 1;
	
	mtrini = osini = tgtini = titini = backini = detini = waveini = arcini = 0;
	uptgt = 1;
	 
	gfx_wold = gfx_w;
	gfx_hold = gfx_h;
	
	hmin = 260;
	wmin = 350;
	
	gfx_w < wmin ? (
		gfxw = wmin;
		gfxscalew = gfx_w/gfxw;
	):(
		gfxw = gfx_w;
		gfxscalew = 1;
	);
	gfx_h < hmin ? (
		gfxh = hmin;
		gfxscaleh = gfx_h/gfxh;
	):(
		gfxh = gfx_h;
		gfxscaleh = 1;
	);
	gfxscale = min(gfxscalew,gfxscaleh);

	mtrw = gfxw -60;
	pade = 4;
	wran = max(wmin, gfxw) -pade*2;
//     hran = max(hmin, gfxh) -mtry-mtrh;
	hran = max(hmin, gfxh) -55;
//     hranmin = hmin-mtry-mtrh;
	hranmin = hmin-55;
	
	
	// METERING
	dety = ceil(hran/hmin *9);
	dety2 = ceil(dety+ gfx_texth *1.5 + hran/100 +1);
	deth = dety + ceil(dety2-dety) *2;
	mtrx = 30;
//     mtrh = ceil(hran * .02) *2;
	mtry = ceil(dety2 + (dety2-dety) +5 +hran/200);
/*
	mtrh = 11 + (hran-hranmin) *.1;
	mtrya = floor( mtry + hran/hranmin  );
//     mtryb = ceil(mtry+mtrh/2);
	mtryb = ceil(mtry + mtrh/2 + (mtrya-mtry)/2 );
	//mono == 1 ? hm = 20 : hm = 9;
//     mtrhs = floor(mtryb-mtry - ceil(hran/300) );
	mtrhs = floor(mtryb-mtrya - (mtrya-mtry)*1  );
//     mtrhs = floor(  );
*/
	mtrya = mtry + mtrpad = floor(hran/hranmin);
	mtrh = 8 + mtrpad*3 + floor((hran-hranmin)*.05) *2;
	mtrhs = (mtrh - mtrpad *3 )*.5;
	mtryb = mtrya+mtrhs+mtrpad;
	


	mtrx2 = mtrx+mtrw;
	mtry2 = mtry+mtrh;
	grexp = .35;
	mtrlino = 5;
	//decay = 1.1;
	decay = 1;    // GR
	decayx = mtrw/20;
	pad = 2;
	str = 0;
	
	// OSCILLOSCOPE
	osx = 20; 
//     osy = 70;
	osy = mtry+mtrh+23;
	osw = gfxw - 40;
	osh = 40 + (hran-hranmin) *.4;
	osx2 = osx+osw;
	osy2 = osy+osh;
	ospd = 4;
	
	
	// MOUSE
	
//     hovamin = .15;
	hovamax = .8;
	hovaspd = .015;
	mour = 15 + (hran-hranmin)/30;
	hovr = 60;
	
	txtdim = .6;
	potrmax = 20;
//     potr = floor( min(potrmax, min(hran/360*potrmax , wran/600*potrmax)) );
	potr = floor( min(potrmax, min(hran/420*potrmax , wran/680*potrmax)) );
	pots = max(35, potr*1.5 + wran/340 * 20);
//     potlw = 5;
	potlw = potr/4;
//     potlh = 14;
	potlh = potr*.75 -1;
	
	tgtx = osx;
//      tgty = osy+osh*osh1+mour +16;
	 th = 6;
	 tgtw = osw-th;
	 tgth = 55 + (hran-hranmin) *.35;
	 tr = th*.5;
	 ty1 = tr;
	 ty2 = ty1 + tgth;
	
	
	// POT LINE
	
	gfx_setimgdim(5,-1,-1); gfx_setimgdim(5,potr*2,potr*2);
	gfx_dest = 5;
	gr = .0;
	gfx_set(gr,gr,gr,1);
	gfx_rect(ceil(potr-potlw*.5), 3 , potlw,potlh);
	gr = .9;
	gfx_set(gr,gr,gr,1);
	gfx_line(potr,4,potr,10);
	
	gfx_dest = -1;
	
	

/* BLITS
 2 oscilloscope
 3 target curve
 4 top functions
 5 knob line
 6 main title
 7 main title layout
 8 waveform
 
 9 background
 10 stereo mode

*/
);

backini == 0 ? (
	backini = 1;
	// Background
	gfx_setimgdim(9,-1,-1); gfx_setimgdim(9,gfxw,gfxh);
	gfx_dest = 9;
	
//     gfx_x = gfxy = pade;
	gfx_gradrect(pade,pade,w= gfxw-pade*2,h= gfxh-pade*2 , .06,.11,.16,1 , 
		0,0,-.05/w,-.08/w , 0,-.05/h,0,-.3/h);
	
	
	gr = .5;
	gfx_set(gr,gr,gr,1);
	loop(4,
		line(-3);
	);
	loop(3,
		line(-6);
	);
	loop(2,
		line(-12);
	);

	gr = 0;
	gfx_set(gr,gr,gr,1);
	gfx_rect(mtrx-pad,mtry-pad,mtrw+pad*2,mtrh+pad*2);
	gr = .3;
	gfx_set(gr,gr,gr,1);
	gfx_rect(mtrx-pad,mtry-pad,mtrw+pad*2,mtrh+pad*2 ,0);
	
);





titini == 0 ? (
	titini = 1;
	gfx_dest = 6;
	gfx_setimgdim(6,-1,-1);  gfx_setimgdim(6,600,400);
	gfx_setimgdim(7,-1,-1);  gfx_setimgdim(7,600,400);
	
	gfx_setfont(1,"Verdana",72,'bi');

	gr = .05;
	gfx_set(gr,gr,gr,1);
//     gfx_x = gfxw*.15;
	gfx_x = 200;
	gfx_y = 204;
	gfx_drawstr("CompLab",261,gfx_x,gfx_y);
	gr = .07;
	gfx_set(gr,gr,.3,1);
	gfx_x = 204;
	gfx_y = 200;
	gfx_drawstr("CompLab",261,gfx_x,gfx_y);
	

	gfx_dest = 7;
	
	gfx_set(1,1,1,.9);
	gfx_x = -80 *0;
	gfx_y = (180-tgty) *0 -37;
	
	gfx_blit(6,1,-.1);

	gfx_setfont(2,"Verdana",16,'');

	gfx_x = x= 200;
	gfx_y = y= 180;
	gfx_set(.4,.3,.2,1,1);
	gfx_drawstr("m r e l w o o d    p l u g i n s",261,gfx_x,gfx_y);

/*
	gfx_drawstr("m r e l w o o d",257,gfx_x,gfx_y);
	gfx_x = x ;
	gfx_y = y + 14;
	gfx_drawstr("p l u g i n s",257,gfx_x,gfx_y);

*/

	gfx_setfont(0);
	
	gfx_setimgdim(10,-1,-1); gfx_setimgdim(10,370,100);
	gfx_dest = 10;
	
	gfx_x = 1; gfx_y = 2;
//     sth = ceil(gfx_texth * 1.45);
	sth = ceil(gfx_texth * 1.35);
	gfx_set(.7,1,1,1,0);
	gfx_drawstr("Stereo M/S ");
	gfx_x = 1; gfx_y = ceil(sth+2);
	gfx_set(1,.8,1,1,0);
	gfx_drawstr("Stereo L/R ");
	gfx_x = 1; gfx_y = ceil(sth*2+2);
	gfx_set(1,1,1,.85,0);
	gfx_drawstr("Stereo L+R ");
	gfx_x = 1; gfx_y = ceil(sth*5+8);
	
	gr = .8;
	(gfx_set(gr,1,gr,1); gfx_drawstr("Mono (L) .." ); );
	stx2 = gfx_x = 92;
	(gfx_set(gr,gr,1,1); gfx_drawstr(" Mono (R) .." ); );
	stx3 = gfx_x = 188;
	(gfx_set(1,gr,gr-.2,1); gfx_drawstr(" Mono (M) .." ); );
	stx4 = gfx_x = 286;
	(gfx_set(1,1,gr-.1,1); gfx_drawstr(" Mono (S)" ); );
	
	
);

mouse_y > 0 && mouse_y < mtry && mouse_x > 0 && mouse_x < gfxw ? detini = 0;


detini == 0 || mouhvr == 11 ? (
	detini = 1;
	gfx_setimgdim(4,-1,-1); gfx_setimgdim(4,gfxw,mtry);
	gfx_dest = 4;
	
	
	gfx_y = dety;
	gfx_x = osx;
	sidechain > 0 ? (
		gr = .9;
		gfx_set(.5,gr,1,1);
		gfx_drawstr("Sidechain")
	):(
		gr = .6;
		gfx_set(gr-.2,gr,1,1);
		gfx_drawstr("Detector");
	);
	
//     my8a = gfx_y += gfx_texth+5;
	gfx_y = my8a = dety2;
	
	gfx_x = mx8a = osx;
	
	mouhvr == 8 ? (
		m8gr < .9 ? m8gr += .025;
		detini = 0;
	):(
		m8gr != txtdim ? (
			m8gr += sign(txtdim-m8gr) * .025;
			detini = 0;
		);
	);
	gfx_set(m8gr,m8gr,m8gr,1);
	gfx_drawstr("Steep: ");
	gfx_drawnumber(slider8+.5,0);
	mx8b = gfx_x +6;
	my8b = gfx_y + gfx_texth + 5;
	
	
	
	gfx_x += max(0, (gfxw-200) * .1);
	
	gfx_y = dety;
	mx7a = gfx_x;
	my7a = gfx_y -5;
	mouhvr == 7 ? (
		m7gr < .9 ? m7gr += .025;
		detini = 0;
	):(
		m7gr != txtdim ? (
			m7gr += sign(txtdim-m7gr) * .025;
			detini = 0;
		);
	);
	gfx_set(m7gr,m7gr,m7gr,1);
	gfx_drawstr("LPf: ");
	gfx_drawstr( sprintf(lpval,"%d",flp) );
	gfx_drawstr(" Hz ");
	mx7b = gfx_x;
	//gfx_x += max(0, (gfxw-200) * .2);
	gfx_x = mx7a;
	gfx_y = dety2;
	
	
	mx6a = gfx_x;
	my6a = my7b = gfx_y;
	mouhvr == 6 ? (
		detini = 0;
		m6gr < .9 ? m6gr += .025;
	):(
		m6gr != txtdim ? (
			m6gr += sign(txtdim-m6gr) * .025;
			detini = 0;
		);
	);
	gfx_set(m6gr,m6gr,m6gr,1);
	gfx_drawstr("HPf: ");
	gfx_drawstr( sprintf(hpval,"%d",fhp) );
	gfx_drawstr(" Hz ");
	mx6b = gfx_x;
	my6b = gfx_y + (gfx_texth +4);
	slixran[6] = slixran[7] = mtrw;
	slixran[8] = mtrw/4 /5;
	
	
	
	
	
stshow = 1;
stshow == 0 ? (
	gfx_y = dety;
	gfx_x = mtrw-50;;
	mx11a = gfx_x;
	my11a = gfx_y -5;
	mouhvr == 11 ? (
		detini = 0;
		m11gr < .9 ? m11gr += .025;
	):(
		m11gr != txtdim ? (
			m11gr += sign(txtdim-m11gr) * .025;
			detini = 0;
		);
	);
/*
	forcestereo == 0 ? (
		stera < .7 ? steradir = 1;
		stera > .9 ? steradir = -1;
		stera += .008 * steradir;
		detini = 0;
		
	):(
		stera < 1 ? (stera += .1; detini = 0; );
		stera > 1 ? (stera = 1; detini = 0; );
	);
*/

	gfx_set(m11gr,m11gr,m11gr,1);
	stereo < .5 ? (
		gfx_x -= 30;
		gr = .75;
		mono == 0 ? (gfx_set(gr,1,gr,1); gfx_drawstr(" Mono (L) >>" ); ):
		mono == 1 ? (gfx_set(gr,gr,1,1); gfx_drawstr("<< Mono (R) >>" ); ):
		mono == 2 ? (gfx_set(1,gr,gr-.1,1); gfx_drawstr("<< Mono (Mid) >>" ); ):
		mono == 3 ? (gfx_set(1,1,gr-.1,1); gfx_drawstr(" << Mono (Side)" ); );
	) :
	stereo < 1.5 ? (gfx_set(1,1,1,1); gfx_drawstr("Stereo L+R "); ) :
	stereo < 2.5 ? (gfx_set(1,gr=.8,gr,1); gfx_drawstr("Stereo L/R "); ) :
	stereo < 3.5 ? (
		gfx_r = m11gr - .2;
		gfx_g = min(1, m11gr + .15);
		gfx_b = m11gr - .2;
		gfx_set(.7,1,1,1);
		gfx_drawstr("Stereo M/S ");
	);
);

stshow == 1 ? (
	mx11a = gfx_x;
	my11a = gfx_y -5;

	(mouhvr == 11 || drag == 11 || drag == 24) && dragst < 5 ? dragst_ += .5 ;
	dragst = ceil(dragst_);
	drag == 11 || drag == 24 ? (
		detini = 0;
		snap11 = 1;
	);
	gfx_set(1,1,1,.7+dragst*.06);
	wd = 10; hd = 5;
	area(saxd=(sax=mtrw-64)-dragst*2,say=dety-5-dragst,saw=87+dragst*4,sah=sth+2+dragst*2 , 5-dragst);
	mx11a = sax;
	my11a = say;
	gfx_blit(10,1,0
	 , saxd-(mtrw-61),ceil(max(0,3-slider11)*sth-2-dragst),saw,sah
	 , saxd,say,saw,sah);

	gfx_blit(10,1,0
//      , saxd-(mtrw-52)+slider24*98,saym=say+sth*4-5,saw,sah-(say+sah-saym)
//      , saxd,say+slider11*sth,saw,sah-(say+sah-saym));
/*
	 , saxd-(mtrw-52)+slider24*98,3+sth*4
	 ,saw,sahm=(say+sah)-(saym=floor(say+slider11*sth)-1)
	 , saxd,saym+dragst,saw,sahm);
*/
	 , saxd-(mtrw-52)+slider24*98,saym=3+sth*5-dragst
	 ,saw,sahm=(say+sah)-(saym2=floor(say+slider11*sth)-1)
	 , saxd,saym2,saw,sahm);
	slixran[24] = 80;
	
	mouhvr == 11 || drag == 11 || drag == 24 ? (
		gfx_set(1,1,1,1,0);
		gr0 = 1- (gr = .1);
		gra0 = 1- (gra = .5);
		gfx_gradrect(saxd+1,floor(say+1),saw-2,ceil(h=sah*.3) , gr,gr,gr,gra , 0,0,0,0 , 0,0,0,-gra0/h);
		gfx_gradrect(saxd+1,ceil(say+sah*.7+1),saw-2,h , gr,gr,gr,0 , 0,0,0,0 , 0,0,0,gra/h);
	);
);     
	
	
	mx11b = osx+osw;
	
	
	my11b = my12a = gfx_y = dety2;

	
	
	gfx_x = mx12a = mx11a -30;
	mouhvr == 12 && stereo >= 2 ? (
		m12gr < .9 ? m12gr += .025;
		detini = 0;
	):(
		m12gr != (a2= txtdim-.3*(stereo<2)) ? (
			m12gr += sign(a2-m12gr) * .025;
			detini = 0;
		);
	);
	gfx_set(m12gr,m12gr,m12gr,1);
	stereo == 2 ? gfx_drawstr("R pre-gain: ") : gfx_drawstr("S pre-gain: ");
	
	gfx_drawnumber( sidedb,1 );
	//gfx_drawstr( sidedb,1 );
	
	mx12b = gfx_x;
	my12b = gfx_y +gfx_texth+4;
	
	slixran[11] = mtrw/4/3;
	slixran[12] = mtrw;
	
	slixran[1] = mtrw/48;
	
);

mouhvr != 11 && dragst > 0 ? (dragst_ -= .5; detini = 0; );


gfx_dest = -1;
gfx_a = 1;

gfx_x = gfx_y = 0;
gfx_set(1,1,1,1,0);
gfx_blit(9,1,0); // background

gfx_x = 0;
gfx_y = tgty;
gfx_set(1,1,1,1,1);
//gfx_blit(7,1,0 , 0,0,400,400 , -302,tgty+tgth-220 + 80*osh1,gfxw,400 , 200,200); // title
gfx_blit(7,1,.0 , 0,0,400,400 , x=-45,25 + gfxh*.53,gfxw-13-x,gfxh-70 , 00,00); // title

//h470: 273 ... h264: 161
//h++= 206
//y++= 112

//+gfxh*0,54

gfx_x = 0;
gfx_y = 0;
gfx_blit(4,1,0); // top functions





/*
gfx_line(xl=x+ (2^(-6/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-9/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-12/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-15/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-18/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-21/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-24/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-27/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-30/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-36/6))^grexp *w , y-lino,xl,y2+lino);
gfx_line(xl=x+ (2^(-42/6))^grexp *w , y-lino,xl,y2+lino);
*/

//comp.mongr == 0 ? comp.mongr = 1;
//compR.mongr == 0 ? compR.mongr = 1;

//compl.xposin = (2^(compl.monin/6))^grexp ;
//compl.xposgr = (2^(compl.mongr/6))^grexp ;
//comp.xposinL = x+ compin^grexp *w;
//compl.xposgr = x+ compl.mongr^grexp *w;

/*
gr = .05;
gfx_set(gr,gr,gr,1);
gfx_rect(mtrx-pad,mtry-pad,mtrw+pad*2,mtrh+pad*2);
gr = .3;
gfx_set(gr,gr,gr,1);
gfx_rect(mtrx-pad,mtry-pad,mtrw+pad*2,mtrh+pad*2 , 0);
*/

gr = .7;
gfx_set(gr,gr,gr,1);
gfx_x = mtrx-pad*2-gfx_texth;
//gfx_y = mtry-3;
gfx_y = mtry+(mtryb-mtry)*.5 - gfx_texth *.6 -1;
stereo == 3 ? (
	gfx_set(.45,.8,.45,1);
	gfx_drawstr("M");
) :
stereo == 1 || stereo == 2 ? gfx_drawstr("L"):
stereo < .5 ? (
	gfx_y += mtrh * .2 + gfx_texth/3;
	gr = .7;
	mono < .5 ? (gfx_set(gr,.9,gr,1); gfx_drawstr("L" ); ):
	mono < 1.5 ? (gfx_set(gr,gr,1,1); gfx_drawstr("R" ); ):
	mono < 2.5 ? (gfx_set(.8,gr,gr-.2,1); gfx_drawstr("M" ); ):
	mono < 3.5 ? (gfx_set(1,1,gr-.1,1); gfx_drawstr("S" ); );
);
gfx_x = mtrx-pad*2-gfx_texth;
//gfx_y = mtryb+pad/2-0;
gfx_y = mtryb+(mtryb-mtry)*.5 - gfx_texth *.4;
//gfx_y += mtrh*.55 +1;
stereo == 3 ? (
	gfx_set(.5,.85,.5,1);
	gfx_drawstr("S");
) :
stereo == 1 || stereo == 2 ? gfx_drawstr("R");





moninL = monsplL;
//moninL = premonL;
grmonL = grsplL;
monsplL = 0;
grsplL = 1;

//mtrrst = 0;

//moninL = max(monsplL1,monsplL2);
//stereo > 1 ? moninR = max(monsplR1,monsplR2);
stereo > 1 ? (
	moninR = monsplR;
//     moninR = premonR;
	grmonR = grsplR;
	monsplR = 0;
	grsplR = 1;
);



xposgr_ = floor(mtrx+ (grmonL^grexp)  *(mtrw) );
xposgr < xposgr_ ? (
	mtrholdgr > 1 ? (
		xposgr = xposgr_;
		xposgr += min(decayx, xposgr_-xposgr;)
	):(
//               xposgr = xposgrold;
		mtrholdgr += 1;
	);
):(
	mtrholdgr = 0;
	xposgr = xposgr_ ;
);

xposlimgr =  floor(mtrx+ comp.monlimgr^grexp  *mtrw);
xposlimgrold < xposlimgr ? (
	mtrholdlimgr > 1 ? (
		xposlimgrold = xposlimgr;
	):(
		xposlimgr = xposlimgrold;
		mtrholdlimgr += 1;
	);
):(
	mtrholdlimgr = 0;
	xposlimgrold = xposlimgr ;
);          
		
//xposgr = mtrx+ moninL^grexp *mtrw;



stereo <= 1 ? (
	sidechain == 0 ? osin = moninL;
	osin2 = grmonL;
//     slider25 == 0 ? osin2 *= moninL;
/*
	slider25 == 0 ? (
//          osin2 = max(moninL*outg,moninR*outgR);
		osin2 = comp.mongr;
	):(
		osin2 = comp.mongr;
	);
*/     

//     gfx_set(.0,.35,.2,.7);
	gfx_set(.0,.3,.4,.8);
	xposin = max(mtrx,max(mtrx+ moninL^grexp *mtrw , xposin - decayx));
	stereo == 0 ? gfx_rect(mtrx,mtry,xposin-mtrx,mtrh) : (
		gfx_rect(mtrx,mtrya,xposin-mtrx,mtrhs);
		gfx_rect(mtrx,mtryb,xposin-mtrx,mtrhs);
	);

//     gfx_set(.1,.8,.6,.4);
	gfx_set(.9,.0,.0,.5,1);

	stereo == 0 ? (
		gfx_rect(xposgr,mtry,mtrx2-xposgr,mtrh);

		// Limiter
		gfx_set(.7,.0,0,1,1);
		gfx_rect(xposlimgr,mtry,(xposgr-xposlimgr),mtrh);
		
	):(
		gfx_rect(xposgr,mtrya,mtrx2-xposgr,mtrhs);
		gfx_rect(xposgr,mtryb,mtrx2-xposgr,mtrhs);

		// Limiter
		gfx_set(.7,.0,0,1,1);
		gfx_rect(xposlimgr,mtrya,(xposgr-xposlimgr),mtrhs);
		gfx_rect(xposlimgr,mtryb,(xposgr-xposlimgr),mtrhs);
//          moninR > 0 ? moninR -= decay : moninR = 0;
//          osin = max(moninL,moninR);
		
	);
	
//     moninL > 0 ? moninL -= decay : moninL = 0;
//     (comp.mongr < 1) ? (comp.mongr += decay) : (comp.mongr = 1);
	
):(  // stereo == 2

/*
	slider25 == 0 ? osin2 = max(moninL*outg,moninR*outgR) :
		osin2 = min(outg,outgR);
*/     

	// INPUT LEVEL METERS
	xposin = max(mtrx,max(mtrx+ moninL^grexp *mtrw , xposin - decayx));
	xposinR = max(mtrx,max(mtrx+ (moninR/msbal)^grexp *mtrw , xposinR - decayx));
//     xposinL = mtrx+ moninL^grexp *mtrw;
//     xposinR = mtrx+ moninR^grexp *mtrw;
	stereo == 2 ? gfx_set(.0,.3,.4,.8) : gfx_set(.2,.4,.1,.7);
	gfx_rect(mtrx,mtrya,xposin-mtrx,mtrhs);
	stereo == 2 ? gfx_set(.1,.35,.0,.7) : gfx_set(.2,.4,.35,.7);
	gfx_rect(mtrx,mtryb,xposinR-mtrx,mtrhs);
	

//     xposgr2 = mtrx+ min(1,min((compR.mongr)^grexp, xposgr2 +1)) *mtrw;
//     xposlimgr2 = mtrx+ (compR.monlimgr^grexp)  *mtrw;
	
	xposgr2_ = floor(mtrx+ (grmonR^grexp)  *(mtrw) );
	xposgr2 < xposgr2_ ? (
		mtrholdgr2 > 1 ? (
			xposgr2 = xposgr2_;
			xposgr2 += min(decayx, xposgr2_-xposgr2;)
		):(
//               xposgr2 = xposgr2old;
			mtrholdgr2 += 1;
		);
	):(
		mtrholdgr2 = 0;
		xposgr2 = xposgr2_ ;
	);
	
	xposlimgr2 =  floor(mtrx+ compR.monlimgr^grexp  *mtrw);
	xposlimgr2old < xposlimgr2 ? (
		mtrholdlimgr2 > 1 ? (
			xposlimgr2old = xposlimgr2;
		):(
			xposlimgr2 = xposlimgr2old;
			mtrholdlimgr2 += 1;
		);
	):(
		mtrholdlimgr2 = 0;
		xposlimgr2old = xposlimgr2 ;
	);
	

//     gfx_set(.1,.8,.6,.4);

	// GAIN REDUCTION METERS
	gfx_set(.9,.0,.0,.5,1);
	gfx_rect(xposgr,mtrya,mtrx2-xposgr,mtrhs);
	stereo >= 2 ? gfx_set(.7,.2,.0,.5,1) : gfx_set(1,.0,.0,.4,1);
	gfx_rect(xposgr2,mtryb,mtrx2-xposgr2,mtrhs);
	
	stereo == 2 && xposgr2 < xposinR ? (
		gfx_set(.5,0,1,.2);
		gfx_rect(xposgr2,mtryb,xposinR-xposgr2,mtrhs);
	);


	// LIMITER METERS
//     gfx_set(.6,.0,.3,.5,1);
//     gfx_set(.4,.0,.2,.6,1);
	gfx_set(.7,.0,0,1,1);
	gfx_rect(xposlimgr,mtrya,(xposgr-xposlimgr-2*0),mtrhs);
	gfx_rect(xposlimgr2,mtryb,xposgr2-xposlimgr2-2*0,mtrhs);
	
	osin = max(moninL,moninR) /msbal;
	slider25 == 0 ? osin2 = max(moninL*grmonL,moninR*grmonR)/msbal :
//          osin2 = min(outg,outgR);
		osin2 = min(grmonL,grmonR);
	
//     moninL > 0 ? moninL -= decay : moninL = 0;
//     moninR > 0 ? moninR -= decay : moninR = 0;
	
	
);





// Threshold line (Vertical)
gfx_set(1,.15,.0,.8);
gfx_rect(thrx=mtrx+mtrw* sl_thr^grexp,thry=mtry-9,thrw=5,thrh=mtrh+17);


// Threshold value
gr = .4;
gfx_set(1,gr,gr,1);

sprintf(thrstr,"%.1f", thrdb=20*log10(sl_thr) );
gfx_measurestr(thrstr, thrw,thrh );
//gfx_x = mtrx+mtrw - thrw;
gfx_x = osx+osw - thrw +2;
gfx_y = mtry+mtrh +8;
gfx_drawnumber(thrdb,1);


function xy(x y)(
	gfx_x = x;
	gfx_y = y;
);



/*
slider25 == 1 ? (
	
	osin2 = min(comp.mongr,compR.mongr);
):(
	osin2 = osin * min(comp.mongr,compR.mongr);
);

osin2 = grspl;
*/


// OSCILLOSCOPE

//osini = 0;
osini == 0 ? (
	gfx_dest = 2;
	gfx_setimgdim(2,-1,-1); gfx_setimgdim(2,osw*2,osh);
	gfx_set(0,0,0,1,0);
	gfx_rect(0,0,osw*2,osh);
	osw2 = osw;
	osini = 1;
);

osoff == 0 ? (
	osh1 < 1 ? osh1 += .04 : osh1 = 1;
	osin == 0 ? (
		osinc += 1;
		osinc > 120 ? oskip = 1;
	):(
		osinc = 0;
		hov == 1 ? oskip = 0;
	);

		
	oskip == 0 ? (
	//     hov == 0 ? oskip += 1;
		gfx_dest = 2;
		slider25 == 0 ? osin2 = moninL : osin2 = outg;
		
	//     stereo < 2 ? osin = moninL : osin = max(moninL,moninR);
	
	/*
		slider25 == 0 ? (
			osin2 = outg;
	//          osin = osin^.5;
		):(
			osin = osin^.5;
	//          osin2 = osin ;
			
		);
	*/
		
		yosprev_ = yos_;
		yos2prev_ = yos2_;
		yos_ = osh - min(1,abs(osin)^(grexp) ) * osh;
		yos2_ = osh - min(1,abs(osin2)^(grexp)) * osh;
		ylimlast = ylim;
		ylim = max(yos2_, osh - min(1,min(comp.monlimgr,compR.monlimgr)) * osh);
		
		xos += ospd;
		xos > osw && osw2clear == 0 ? (
	
			osw2clear = 1;
			gfx_set(0,0,0,1);
			gfx_rect(osw,0,osw,osh);
		);
		xos > osw*2  ? (
			osw2 = xos-osw;
			xoslast = 1;
			osw2clear = 0;
			
			gfx_set(0,0,0,1);
			gfx_rect(0,0,osw,osh);
			
	//          yosprev_ = yos_ + (yosprev_ - yos_) * ((osw*2 - xosprev) / ospd);
		);
	
		xos2 = xos+osw;
		xos2 > osw*2 ? xos2 -= osw*2;
		
		
	//     gfx_set(.5,.6,.4,1);
	//     xos > osw ? gfx_r = 1;
		xoslast == 1 ? (
			xos = ospd;
			xoslast = 0;
		):(
			xoslast = xos-ospd;
		);

		// Limiter     
		gfx_set(1,.0,.3,.2);
		gfx_triangle(xoslast,yos2prev_,xos,yos2_ , xos,ylim,xoslast,ylimlast);
		// Compressor
		gfx_set(.8,.1,.1,1);
//          gfx_line(xoslast,yos2prev_,xos,yos2_);
		gfx_line(xoslast,ylimlast,xos,ylim);
	//     gfx_set(.0,1,.6,.5);
		// Input/Output
		gfx_set(.0,.5,.8,.7+.3*slider25);
		gfx_line(xoslast,yosprev_,xos,yos_);
		
//          osin = 0;
//          slider25 == 0 ? osin2 = compinL : osin2 = outg;
		
	):(
		oskip = 0;
	);
):(
	osh1 > .15 ? osh1 -= .02;
	osh1 < .15 ? (
		osh1 = .15;
		upslider();
	);
);


/*
limdecay = 1;

(comp.mongr < 1) ? (comp.mongr += decay) : (comp.mongr = 1);
(compR.mongr < 1) ? (compR.mongr += decay) : (compR.mongr = 1);

(comp.monlimgr += limdecay) > 1 ? comp.monlimgr = 1;
(compR.monlimgr += limdecay) > 1 ? compR.monlimgr = 1;
*/

comp.mongr = comp.monlimgr = 1;
compR.mongr = compR.monlimgr = 1;

// COMPRESSOR SHAPE TARGET GRAPH

function tgtline(x1_ y1_ x2_ y2_)
	instance(x1 y1 x1b y1b x2 y2 x2b y2b ang ttan trad)(
	
	ttan = (y2-y1 +.0001) / (x2-x1 +.0001) ;
	
	trad = atan(ttan);
	
//     ang = (x2-x1) / (y2-y1) ;
	x1 = x1_ + (sintrad = sin(trad)) * tr;
	x1b = x1_ - (x1-x1_);
	
	x2 = x2_ + (x1-x1_);
	x2b = x2_ - (x1-x1_);
	
	y1 = y1_ - (costrad = cos(trad)) * tr;
	y1b = y1_ + (y1_-y1) +1;
	
	y2 = y2_ - (y1_-y1);
	y2b = y2_ + (y1_-y1) +1;
	
/*
	x1 += costrad;
	x1b += costrad;
	y1 += sintrad;
	y1b += sintrad;
*/
	
	gfx_triangle(x1,y1,x2,y2 , x2b,y2b,x1b,y1b);
//     abs(x2-x1) < tr || abs(
	gfx_circle(x1_,y1_,tr ,1);
	gfx_circle(x2_,y2_,tr ,1);
);

function label(x y align lbl val)
	instance(gr valstr xb yb wb hb)(
	
	yb = y-1; hb = gfx_texth *2 +4;
	align == 256 ? (xb = x-2; wb = 47 ; ) :
	align == 257 ? (xb = x-32; wb = 61; ) :
	align == 258 ? (xb = x-50; wb = 51; ) :
	align == 262 ? (xb = x-50; wb = 51; yb -= 4 );

	gfx_set(0,0,0,.5,0);
	gfx_rect(xb,yb,wb,hb);

	lbl == "PreComp:" && red17 > 0 ? (
		gfx_set(.9,.0,.2,1);
	):(
		gr = .5;
		gfx_set(gr,gr+.1,gr,1);
	);
	xy(x,y);
	gfx_drawstr(lbl, align,gfx_x,gfx_y);

	gfx_x = x;
	gfx_y += gfx_texth*1.3 + (align==262)* 4;

	lbl == "PreComp:" && red17 > 0 ? (
		gfx_set(1,.3,.3,1);
	):(
		gr = 1;
		gfx_set(gr,gr,gr,1);
	);
	
	val == -99 ? ( // HOLD
		
		gfx_drawnumber(holdstr1,(holdhz < 40)+(holdhz>1000)*(1-slider26));
			
		gfx_a = holdhz > 40 ? .8 : .5;
		gfx_drawstr(holdstr2);
	):(     
		val < 10 && val > -10 ? (
			gfx_drawstr( sprintf(valstr,"%.1f",val+.001) , align,gfx_x,gfx_y);
		):(
			gfx_drawstr( sprintf(valstr,"%.f",val) , align,gfx_x,gfx_y);
		);
	);
);

function pot(x y lbl val digit rot)
	instance(gr lblw lblh valw valh valstr y1 y2)(

	gfx_set(0,0,0,1);
	gfx_circle(x,y,potr+6 ,1);
	gr = .8;
	gfx_set(gr,gr,gr,1);
	gfx_circle(x,y,potr );
	gr = .5;
	gfx_set(gr,gr,gr,1);
	gfx_circle(x,y,potr-2);
	gfx_set(.17,.15,.15,1);
	gfx_circle(x,y,potr -3,1);
	
	gfx_measurestr(lbl,lblw,lblh);
	
	valstr = 0;
	digit == 0 ? sprintf(valstr,"%.f",(val + .01 * sign(val))) :
	digit == 1 ? sprintf(valstr,"%.1f",(val + .01 * sign(val))) :
	digit == -1 ? valstr = val;
	gfx_measurestr(valstr,valw,valh);
	valw = min(40,valw);
	valh = gfx_texth;

	gfx_set(0,0,0,.9);
	gfx_rect(x-lblw*.6,y2= y+potr+5 , lblw*1.2,lblh*1.4);
	gfx_set(0,0,0,.9);
	gfx_rect(x-potr*.9 ,y1= y-potr-5-valh*1.4 , potr*2 ,valh*1.4);

	gr = .7;     
	gfx_set(gr,gr,gr,1);
	gfx_x = x-lblw*.5;
	gfx_y = y2+lblh*.3;
	gfx_drawstr(lbl);

	gr = .95;
	gfx_set(gr,gr,gr,1);
	gfx_x = x-valw *.5 *0;
	gfx_y = y1 +valh*.2;
//     gfx_drawnumber(val,1);
	gfx_drawstr(valstr, 257,gfx_x,gfx_y);

	
	gfx_x = x-potr;
	gfx_y = y-potr;
	gfx_set(1,1,1,1);
	gfx_blit(5,1, -2.5 + rot *5);
	
	

);

function tgtsine_orig(x1 y1 x2 y2 shape)
	instance(wx wy y0 yold smoo one ex )(
this.tx1 = x1;
this.ty1 = y1;
this.tx2 = x2;
this.ty2 = y2;
	gfx_set(.7,.14,.07,1);

	wx = x1 ;
//     x2 < x1 +5 ? smoo = 0 : smoo = 2;
//     smoo = min (2, x2-x1-2);
	wyold = wy = y1;
//     yend = y2 + 3* sign(y2-y1);
	yend = min(y1,y2 +1);
//     while(wx < x2+smoo)(
//     while(wy > yend)(
	while(
		x2 > x1 ? one = (wx-x1)/(x2-x1) :
			one = (x1-wx)/(x1-x2) ;

//          ex = (.8-1.8*shape*one^2 +.0*shape) + 2*one^1
//               - 1* shape* (1- abs(shape-.5)^2);
		ex = 1.2 +.4*(1-one)*shape -.2*(1-shape)*(to=1-one)*to
		 + (1-shape)*one*one *2 +.3*one*one *shape
		 - 1.3*(one*.2+.8)*shape* (1- abs(shape-.5)^3);

		wy = y1 - (.5- cos( one *3.14)*.5)
			^ex * (y1-y2);

		gfx_line(wx,wy+3,wx,wy-3);
/*
		loop( abs(wyold - wy) ,
			wyold < yend ? gfx_line(wx-3,wyold,wx+3,wyold);
			y1 > y2 ? wyold -= 1 : wyold += 1;
		);
*/
		loop( (wyold - wy) ,
			wyold < (y1+3) ? gfx_line(wx-3,wyold,wx+3,wyold);
//               y1 > y2 ? wyold -= 1 : wyold += 1;
			wyold -= 1;
		);

		
		wx += sign(x2-x1);

		(wx >= min(x1,x2) && wx <= max(x1,x2)) ;
	);
);          
		
function tgtsine(x1 y1 x2 y2 shape)
	instance(wx wy wyold y0 yold smoo one ex )(
this.tx1 = x1;
this.ty1 = y1;
this.tx2 = x2;
this.ty2 = y2;
	gfx_set(.7,.14,.07,1);
	
	x1 > x2 ? x1 += 2;

	wx = x1 ;
//     x2 < x1 +5 ? smoo = 0 : smoo = 2;
//     smoo = min (2, x2-x1-2);
	wyold = wy = y1;
//     yend = y2 + 3* sign(y2-y1);
	yend = min(y1,y2 +1);
//     while(wx < x2+smoo)(
//     while(wy > yend)(
	while(
		x2 > x1 ? one = (wx-x1)/(x2-x1) :
			one = (x1-wx)/(x1-x2) ;

//          ex = (.8-1.8*shape*one^2 +.0*shape) + 2*one^1
//               - 1* shape* (1- abs(shape-.5)^2);
		ex = 1.2 +.4*(1-one)*shape -.2*(1-shape)*(to=1-one)*to
		 + (1-shape)*one*one *2 +.3*one*one *shape
		 - 1.3*(one*.2+.8)*shape* (1- abs(shape-.5)^3);

		wy = y1 - (.5- cos( one *3.14)*.5)
			^ex * (y1-y2);

		gfx_line(wx,wy+3,wx,wy-3);
/*
		loop( abs(wyold - wy) ,
			wyold < yend ? gfx_line(wx-3,wyold,wx+3,wyold);
			y1 > y2 ? wyold -= 1 : wyold += 1;
		);
*/
		loop( (wyold - wy) ,
			wyold < (y1+3) ? gfx_line(wx-3,wyold,wx+3,wyold);
//               y1 > y2 ? wyold -= 1 : wyold += 1;
			wyold -= 1;
		);

		
		wx += sign(x2-x1);

		(wx >= min(x1,x2)-2 && wx <= max(x1,x2)+1) ;
	);
);          
		

osh1 > osh1min && osh1 < 1 ? uptgt = 1;

tgty = osy+osh*osh1+mour +16;


uptgt > 0 ? (
	uptgt = 0;

	tx1 = tr+1;
	tx2 = tx1 + osw*.07 * (.2+.8* (1-(-slider17/100)) );

	gfx_setimgdim(3,-1,-1); gfx_setimgdim(3,osw,tgth*2);


	waveini == 0 ? (
		waveini = 1;
		gfx_setimgdim(8,-1,-1); gfx_setimgdim(8,osw,tgth*2);
		gfx_dest = 8;
		
		// WAVEFORM
//          gr = .25;
		gr = 1;
		gfx_set(gr,gr,gr,1);
		x = gfx_x = 0;
		y0 = y = gfx_y = tgth *.7;
		wvh = tgth *.6;
		loop(tgtw,
			
			x > (x0= tx2-5) ? (
				y = y0 -sin((x-x0)*.5) / (1+(x-x0)/100 ) * wvh;
			);
			
			gfx_lineto(x+=2,y ,0);
		);
	);

	gfx_dest = 3;
	
	gfx_set(1,1,1,.5,0);
	gfx_x = 0;
	gfx_y = 0;
	gfx_blit(8,1,0);
	
	ty12 = ty2-(ty2-ty1)*.45 +tgty -slider13*mour - slider13*sl_rel * mour*.5;
	ty15 = ty2-(ty2-ty1)*.45 +tgty -slider15*mour;
	
	tx3 = tx2 + slider2 * (slixran[2] = osw * .2);

	tx4 = tx3 +25 + slider3 * (slixran[3] = osw * .25);
//     tx5 = tx4 +0 + (reltime/relmax + (1-slider4^2)*.001)^.1 * (slixran[4] = osw * .35);
	tx5 = tx4 +10 + ((slider4)) * (slixran[4] = osw * .45);
	tx6 = tx1 + tgtw-3;
	
	tgtw > 0 && __tgtw == 0 ? __tgtw = tgtw;
	pot10x = floor(tgtw-5 - wran/680 * potr);
//     pot10y = pot9y = pot14y = tgth*1.3;
	pot10y = pot9y = pot14y = tgth + 15;
	pot9x = pot10x-pots;
	pot14x = pot9x-pots;
	
	slixran[9] = tgtw;
	slixran[10] = tgtw/60;
	slixran[14] = tgtw;
	slixran[13] = tgth;
	slixran[15] = tgth;
	 
	
	
	
	
//     gfx_set(1,.2,.1,1);
	gfx_set(.7,.14,.07,1);
	t1.tgtline(tx1,ty1,tx2-2,ty1);

	tx3 > (tx2 +1) ? t2.tgtsine(tx3,ty2-1*0,tx2-1,ty1+floor(slider2+.5) , slider15) :
		t2.tgtline(tx2-1,ty1+1,tx3+1,ty2-1);

	t3.tgtline(tx3+2,ty2,tx4-2*0,ty2);

/*
	slider13 == 0 ? (
		t4.tgtline(tx4,ty2-1,tx5,ty1+1);
	):(
		// RELEASE ARC
*/
/*
		arcini == 0 ? (
			arcini = 1;
			arang = atan( (tx5-tx4)/(ty2-ty1) ) ;
			xangc = tx4 +(tx5-tx4)/2;
			yangc = ty1 +(ty2-ty1)/2;
			
			rang_ = 1000 / (1+slider13*(4.5-(1-sl_rel)^3 *2.5));
			_ang = rcir_ / cos(arang-2*pi); // tmp
	 //         xange = xangc + rcir_ / cos(arang-2*pi);
			xange = xangc + rang_ * cos(arang);
	//          yange = yangc + rcir_ * asin(arang-2*pi);
			yange = yangc + rang_ * sin(arang);
			
			angAC = atan(((tx5-tx4)/2) / ((ty2-ty1)/2));
			lenAC = ((tx5-tx4)/2) / sin(angAC);
			(n3ang) = atan(lenAC/rang_);
			rang = rang_/cos(n3ang);
			
			strtang = arang+pi-n3ang +1.57;
			stopang = (strtang + n3ang*2) ;
		);

//          gfx_set(1,.2,.1,1);
//          gfx_set(.7,.14,.07,1);
		gfx_set(.8,.16,.08,1);
		
		zz = 0;
		while(zz <= th)(
			rnd = (.2- sin(zz/th * 3.14))^.8 * (.01 + .04* slider13);
//               gfx_circle(xange,yange,rang-th/2 +zz ,0,0);
			gfx_arc(xange,yange,rang-th/2+zz , strtang+rnd,stopang-rnd , 0);
			zz += 1;
		);
*/
		// RELEASE SINE

//     );
//     gfx_set(.7,.14,.07,1);
	
	t4.tgtsine(tx4,ty2,tx5,ty1 , slider13*.5+.5);

	t5.tgtline(tx5+2,ty1,tx6,ty1);
	
	ratval = "";
	ratio == 1 ? ratval = "Lim" : ratval = min(20,1/(1-ratio));
	pot3.pot(pot14x,pot14y, "Ratio",ratval,1-2*(ratio==1),slider14*slider14);
	pot1.pot(pot10x,pot10y, "Vol",slider10,1,(slider10+60)/90);
	pot2.pot(pot9x,pot9y, "Mix",slider9*100,0,slider9);
);     




gfx_dest = -1;

function mou(x y x2 y2 id)
	instance(hovadir hova)(
	mp = 2;
	settings == 0 ? (
		x2 == 0 ? (
			x2 = x+mour;
			x = x-mour;
			y2 = y+mour;
			y = y-mour;
			
		);
		mouse_x > x-mp && mouse_x < x2+mp && mouse_y > y-mp && mouse_y < y2+mp ? (
			mouhvr == 0 && drag == 0 ? (
				mouhvr = id;
				hovadir = 1;
			);
			drag == 0 && mouse_cap > 0 && capold == 0 ? (
				drag = id;
			);
		):(
			mouhvr == id && drag != id ? mouhvr = 0;
			mouse_x > x-hovr && mouse_x < x2+hovr && mouse_y > y-hovr && mouse_y < y2+hovr ? (
				hovc += hova-1;
				hova >= .5 ? (
					hovadir = 0;
				);
				hova <= hovamin ? hovadir = 1;
			):(
				hovadir = 0;
			);
		);
		id <= 5 || id == 15 || id == 17 || id == 34 ? (
			hova != hovadir ? (
		//               hova += hovspd * (hovadir*2-1);
				hova > hovamin ? hova += hovaspd * sign(hovadir-hova);
				hova > 1 ? hova = 1;
			);
			hova < hovamin ? hova += hovaspd;
			drag == id || (id == 34 && (drag == 3 || drag == 13)) ? (hova = 1) : (hova = min(hova,hovamax));
			hova > 0 ? (
				gr = .6;
				gfx_set(gr,gr,gr,hova,1);
				gfx_circle((xl=(x+x2)*.5)-1,yl=(y+y2)*.5,mour ,0);
				
				id == 34 ? (
					arrwsz = 4;
					gfx_triangle(xl,y=yl-mour-8 , xl-arrwsz,y+arrwsz , xl+arrwsz,y+arrwsz);
					gfx_triangle(xl,y=yl+mour+8 , xl-arrwsz,y-arrwsz , xl+arrwsz,y-arrwsz);
					gfx_triangle(x=xl+mour+8,yl , x-arrwsz,yl-arrwsz , x-arrwsz,yl+arrwsz);
					gfx_triangle(x=xl-mour-8,yl , x+arrwsz,yl-arrwsz , x+arrwsz,yl+arrwsz);
				);
				gfx_set(1,1,1,1,0);
			);
		);
		
		id == 90 ? (
			mouhvr == 90 && hova < 1 ? (
				hova = min(1, hova += hovaspd*4);
			):(
				hova > 0 ? hova = max(0, hova -= hovaspd*4);
			);
		);
	);
);





xy(osx,osy);
//gfx_x = osx;
//gfx_y = osy;
//osoff == 0 ? (
osh1 > osh1min ? (
	oscut = (max(osx, osx-xos-2));
	oscut2 = (max(osx, osx2-xos-2));
//     gfx_a = osh1;
	gfx_set(1,1,1,osh1,0);
//     gfx_blit(2,1,0 , 0,0,osw,osh , osx2-xos-2,osy,osw,osh*osh1);
//     gfx_blit(2,1,0 , osw,0,osw2,osh , osx-xos2-2,osy,osw2,osh*osh1);
	gfx_blit(2,1,0 , max(0,xos-osx2+osx),0,min(xos,osw),osh , max(osx,osx2-xos-1),osy,min(xos,osw),osh*osh1);
	gfx_blit(2,1,0 , max(osw,xos2),0,min(xos2,osw2),osh , max(osx,osx2-xos2),osy,min(osw2,xos2),osh*osh1);
//     gfx_set(0,0,0,1);
//     gfx_rect(0,osy-20,osx,(osh+40) *osh1);
);
gr = .2;
gfx_set(gr,gr,gr,1);
gfx_rect(osx-1,osy-1,osw+2,(osh+2)*osh1, 0);

// Horizontal threshold line
//gfx_set(1,.1,0,.4*osh1);
gfx_set(1,.5,.3,.4*osh1);
gfx_set(1,.6,.4,.4*osh1);
gfx_set(.7,.5,.5,.4*osh1);
gfx_line(osx-8, y=osy+osh*osh1*(1-sl_thr^.5) , osx+osw+7,y);
xy(tgtx,tgty);



gfx_a = 1;
gfx_blit(3,1,0); // target curve




// MOUSE CAPTURES


mouse_x > 0 && mouse_x < gfxw && mouse_y > 0 && mouse_y < gfxh ? (
	hovamin = .5;
	hov = 1;
):(
	hovamin = hov = 0;
);

//m1.mou(thrx-mour+3,thry,thrx+mour+3,thry+mour , 1);
m1.mou(thrx+2,mtryb-2,0,0 , 1);
m17.mou(tx2+tgtx,ty1+tgty ,0,0 , 17);
m15.mou((tx3*.6+.4*tx2)+tgtx,(ty15) ,0,0, 15);
m2.mou(tx3+tgtx,ty2+tgty ,0,0, 2);
m3.mou(tx4+tgtx,ty2+tgty ,0,0, 3);
m4.mou(tx5+tgtx,ty1+tgty ,0,0, 4);
m35.mou((tx4*.6+.4*tx5)+tgtx,(ty12) ,0,0, 34);
m6.mou(mx6a,my6a,mx6b,my6b , 6);
m7.mou(mx7a,my7a,mx7b,my7b , 7);
m8.mou(mx8a,my8a,mx8b,my8b , 8);
m11.mou(mx11a,my11a,mx11b,my11b , 11); // Stereo
m12.mou(mx12a,my12a,mx12b,my12b , 12);

m9.mou(x=pot9x+tgtx-potr,y=tgty+pot9y-potr*1.5,x+potr*2,y+potr*3 , 9); // Mix
m10.mou(x=pot10x+tgtx-potr,y=tgty+pot10y-potr*1.5,x+potr*2,y+potr*3 , 10); // Volume
m14.mou(x=pot14x+tgtx-potr,y=tgty+pot14y-potr*1.5,x+potr*2,y+potr*3 , 14); // Volume

//label(tx2-mour*.5,ty1-mour+tgty-gfx_texth,257, "PreComp:",prems);
label(tx3+osx-10,ty2+mour+tgty,257, "Attack:",attime);
label(tx4+osx,ty2+mour+tgty,256, "Hold:",-99);
label(tx5+mour*3 -(tx5>osw*.45)*mour*4,ty1-mour+tgty-gfx_texth,257, "Release:",reltime);
label((tx4*.6+.4*tx5)+mour*2.0,ty12+mour*.8,256, "Shape:",slider13*10);
label((tx3*.6+.4*tx2)*.5+mour*2.0,ty15+mour*.7,262, "Shape:",slider15*20-10);
label(tx2+mour*2 - max(0,tx2+60-tx5),osy+osh+10,257, "PreComp:",-prems);

red17 > 0 ? (
	gr = .4;
	xy(osw*.3,osy+osh-gfx_texth*1.5);
	gfx_set(1,gr,gr,1);
	gfx_drawstr("Restart playback to reset PDC.");
);



gr = .1;
gfx_set(gr,gr,gr,.6*osh1);
gfx_rect(osx+4,osy+3,56,gfx_texth *1.3);
gfx_rect(osx+75,osy+3,81,gfx_texth *1.3);
xy(osx,osy+4);

/*
gfx_drawstr("Red:");
gr = .6;
gfx_set(gr,gr,gr,.8);
*/
osoff == 0 ? (
	mx1 = gfx_x;
	
	gfx_set(.8,.2,.2,.8);
	slider25 == 0 ? gfx_a = 1 : gfx_a = .6;
	gfx_drawstr(" Output ");
	mx2 = gfx_x;
	gfx_set(.8,.2,.2,.8);
	slider25 == 1 ? gfx_a = 1 : gfx_a = .6;
	gfx_drawstr("  Reduction ");
	mx3 = gfx_x;
);


mx67b=mx67+64;
my67b=my67+gfx_texth *1.4;
gr = .1;
gfx_set(gr,gr,gr,.6);
gfx_rect( (mx67=osx)+4,(my67= osy+osh*osh1-gfx_texth*1.5)-2 ,mx67b-mx67,my67b-my67);
xy(mx67+4,max(my67,osy-3));
gr = .3;
gfx_set(gr,gr,gr*(3-osoff*2),1);
gfx_drawstr(" Enable ");


function button(lbl lbl2 val red id)
	instance(x x2 y y2 w h lblw lblh grey gr gr0 aran valstr valw lblw lblw2 lblh)(
	aran = 1-gfx_a;
	x = gfx_x;
	gfx_measurestr(lbl,lblw,lblh);
	gfx_measurestr(lbl2,lblw2,0);
	val != -999 ? gfx_measurestr( sprintf(valstr,"%.f",val) ,valw,0) : valw = 0;
	
	x2 = x + max(lblw,lblw2) +16;
	y = gfx_y;
	lbl2 == 0 ? y2 = y + gfx_texth * 1.9
	: y2 = y + gfx_texth * 2.9;
	w = x2 - x;
	h = y2 - y + (lbl2 != 0) * 2;
	drag == id ? grey = .8
	: grey = gfx_a + aran/3 * this.hova;
	gr = grey;
	gfx_set(gr,gr,gr,1);
	red > 0 ? (
		gfx_r = red * 1 + (1-red) * gr;
		gfx_g = red * 0 + (1-red) * gr;
		gfx_b = red * .2 + (1-red) * gr;
//          gfx_a = red * 1 + (1-red) * (1-aran);
	);
	gfx_roundrect(x +butpad, y+butpad,w-butpad*2,h-butpad*2 , 4);
	gr = .1;
	gfx_set(gr,gr,gr,1);
	gfx_roundrect(x, y,w,h , 4);
	xy(x+butpad*4 , y+butpad*2);
	gr = grey;
	gfx_set(gr,gr,gr,1);
	gfx_drawstr(lbl);
	
	lbl2 != 0 ? (
//          xy(x+w -valw - butpad*5 , gfx_y);
		xy(x+butpad*4 , y+butpad*2 + gfx_texth*1.2);


		gr = .8;
		gfx_set(gr,gr,gr,1);
		gfx_drawstr("+");
		gfx_x += 2;
		
		gfx_drawstr(valstr );//, 260,gfx_x,gfx_y);
		gr = grey;
		gfx_set(gr,gr,gr,1);
		gfx_x += 2;

		gfx_drawstr(lbl2);
		xy(x+w - butpad*4 , gfx_y);
//          gfx_drawstr("dB",258,gfx_x,gfx_y);
		
//          xy(x+w - butpad*3 , (y+y2)/2 +butpad);
		
	);
	
	this.mou(x,y,x2,y2 , id);
);

// BUTTONS
butpad = 2;


//tx5 > gfxw/2 ? gfx_x = setbx = attlimb.x + attlimb.w + 20 :
tx5 > osw*.82 ? gfx_x = setbx = attlimb.x + attlimb.w + 60 :
//     gfx_x = setbx = gfxw - 88;
	gfx_x = setbx = osx2 - 78;
gfx_y = setby = osy+osh*osh1 + 4;
gfx_a = .3;
settingsb.button("Settings",0,-999,0, 90);

tx5 < osw*.6 ? gfx_x = osw-settingsb.w-40-osw*.05 : gfx_x = osx +osw*.21;
gfx_y = osy+osh*osh1 + 2;
gfx_a = .5;
slixran[16] = mtrw*.5;
//attlimb.button("Att","Lim",slider16*10, red, 16);
attlimb.button("AttLim","dB",limthrdb, red, 16);
red > 0 ? red -= .1;


limdsp < limdspg || lima > 0 ? (
	xy(attlimb.x + attlimb.w  , attlimb.y+attlimb.h*(.15+.75*(attlimb.x>osw*.5)) +1);
	
	
	limdsp < .9 && (limdsp < limdspg || lima < .3) ? (
		lima = 1;
		limdspg = limdsp;
		limdsp = 1;
		
		

	):(
		p=0;
//          lima = limaold;
	);
	
	gr = .4;
	gfx_set(gr,gr,gr,lima);
	
	sprintf(limdspstr,"%.1f", 20* log10(limdspg));
	gfx_drawstr( limdspstr ,260,gfx_x,gfx_y);
	lima > 0 ? lima -= .02;
	limaold = lima;
):(
	limdspg = limdsp = 1;
);




osoff == 0 ? (
	mou(mx1,osy-5,mx2,osy+gfx_texth+5 , 65);
	mou(mx2,osy-5,mx3,osy+gfx_texth+5 , 66);
);
mou(mx67,my67,mx67b,osy+osh+3 , 20);


// DOUBLE-CLICKS

mouse_cap > 0 && capold == 0 && drag > 0 ? (
	dblstate += 1;
	dblstate >= 2 ? (
		dblclk = drag;
		drag = dblstate = dblc = 0;
	);
);
dblstate > 0 ? (
	(dblc += 1) > 15 ? (
		dblclk = dblstate = dblc = 0;
	);
);

dblclk > 0 ? (
	dblclk == 11 ? dblclk = 0;
	dblclk == 34 ? dblclk = 13;
	slider(dblclk) = slize[dblclk];
	upslider();
	
	dblclk = 0;
);




// MOUSE DRAGS

drag > 0 ? (
	slixran[id] == 0 ? slixran[id] = mtrw*.5;
	
	mouse_cap > 1 ? precise = .3 : precise = 1;
	mouse = (moux= mouse_x-mouxold) + (mouy= mouyold-mouse_y);
	mouse != 0 ? hadmou = 1;
	
	dragma = slima[drag];
	dragmi = slimi[drag];
	dragze = slize[drag];
	
	
	drag == 1 ? dragspd = (1-sl_thr^grexp)*1.5 +.5;
	
//     drag == 2 || drag == 3 || drag == 4 || drag == 13 || drag == 15 ? arcini = 0;
	
	
	
	drag == 8 || drag == 11 ? (
		stshow == 1 ? (
			drag == 11 ? (
				slider11 < .5 && abs(moux) > abs(mouy)*2 && abs(moux) > 1 ? (
					slider11 = stereo = floor(slider11+.5);
					drag = 24;
				):(
					mouse = -mouy;
				);
			);
		);
		
/*
		drag == 11 ? (
			forcestereo == 0 && stereo > 0 ? drag = 0;
			mouse_cap == 1 ? forcestereo = 1 :
			mouse_cap > 1 ? forcestereo = 0;
		);
*/               
		mouse_cap == 0 && hadmou > 0 ? drag = 0;
	);

	drag == 16 ? (
		mouse *= -1;
	);
	

	drag == 20 ? (
		(slider(drag) += 1) > slima[drag] ? slider(drag) = slimi[drag];
		osoff = slider20;
		drag = 0;
		osoff == 0 ? osini = 0;
	);
	
	drag == 22 ? (
		mouse *= -1;
	);

	drag == 24 ? (
		abs(mouy) > abs(moux)*2 && abs(mouy) > 1 ?(
			drag = 11;
			slider24 = mono = floor(slider24+.5);
		):(
			mouse = -moux;
		);
	);
		

	
	drag == 34 ? (
//          moux != 0 && mouy == 0 ? (
		abs(moux) > abs(mouy) ? (
			drag = 3;
			nodrag4 = 1;
		) :
		abs(moux) < abs(mouy) ? (
			drag = 13;
		);
	);

	drag >= 65 && drag <= 66 ? (
		slider25 = drag - 65;
//          drag = 0;
	);
	
	drag == 90 ? (
		settings = 1;
		drag = 0;
	);
	_dragmou = mouse;
/*
	drag == 4 ? (
		slider3 > slimi[3] && slider3 < slima[3] ? dragspd = .5 : dragspd = 1;
	);
*/
//     dragspd = 1;
	slider(drag) += (mouse) / slixran[drag] * dragspd * precise;
		
	slider(drag) = min(slima[drag],max(slimi[drag],slider(drag)));
	
//     sliderchange(slider(drag));
	slider_automate(slider(drag));
	drag == 11 ? (slider_automate(slider24); );
	drag == 24 ? (slider_automate(slider11); mono = slider24);

	drag == 3 && nodrag4 == 0 ? (
		dragstrt == 0 ? (
			sli3old = slider3;
			sli3strt = slider3;
			sli4strt = slider4;
			dragstrt = 1;
		);
		slider3 > slimi[3] && slider3 < slima[3] ? (
//               slider4 -= mouse/slixran[4] ;
//               slider4 = sli4strt - (slider3-sli3strt) * ((reltime / (1000/srate) -1)/300000)^(1/4);
			slider4 -= (slider3-sli3old)*.2;
			sli3old = slider3;   
			
			slider4 = min(slima[4],max(slimi[4],slider4));
			
			slider_automate(slider4);
		);
		slibuf[4] = slider4;
		
	);
	
	drag == 17 ? (
		(sli17 = min(sli17,slider17)) < slider17 ? red17 = 1;
		uptgt = 1;
		mouse > 0 ? memset(pdcbuf,0,2000);
	);
	
/*

	drag == 4 ? (
		slider4 == slimi[4] || slider4 == slima[4] ? (
			slider3 += mouse/slixran[3] * .5;
			slider3 = min(slima[3],max(slimi[3],slider3));
		);
	);
*/
//     drag == 11 ? stereo = slider11;
	
	slibuf[drag] = slider(drag);

	upslider();
);




(drag == 8 || drag == 11) && mouse_cap == 0 && capold > 0 ? (
	(slider(drag) += 1) > slima[drag] ? slider(drag) = slimi[drag];
	drag = 0;
	slider_automate(slider(drag));
	
	upslider();
);



// SETTINGS WINDOW


setw = 300;
setx = (gfxw-setw) *.5;
sety = 10;
seth = gfxh-sety*2;
setxtdim = .5;
setxtbri = .5;



settings > 0 ? (
	setclose == 0 ? (
		seta = min(1, seta += .1);
		mouse_cap > 0 ? (
			(mouse_x < setx || mouse_x > setx+setw || mouse_y < sety || mouse_y > sety+seth) ? (
				seta == 1 && drag != 22 ? setclose = 1;
			):(
				setting == 0 ? (

				
					mouse_y > smy1a && mouse_y < smy1b ? (
						sidechain = min(3, floor( (mouse_x-setx)/(setw2 *.25) ));
						slider27 = sidechain;
						slider_automate(slider27);
						
						detini = 0;
					) :

					mouse_y > smy2a && mouse_y < smy2b && mouse_x < setx+setw2*.8 ? (
						slider29 = min(1, floor( (mouse_x-setx)/(setw2 *.25) ));
						slider_automate(slider29);
					) :
					// STEEPNESS SETTING
					mouse_y > smy3a && mouse_y < smy3b ? (
						poles = min(5, ceil( (mouse_x-setx)/(setw2 *.2) ));
						slider8 = poles;
						slider_automate(slider8);
						upslidergo = 1;
					) :

					mouse_y > smy4a && mouse_y < smy4b && mouse_x < setx+setw2*.75 ? (
						mtrsrc = min(1, floor( (mouse_x-setx)/(setw2 *.25) ));
						slider21 = mtrsrc;
						slider_automate(slider21);
					) :

					mouse_y > smy5a && mouse_y < smy5b && mouse_x < setx+setw2*.6 ? (
						limrat = min(1, floor( (mouse_x-setx)/(setw2 *.25) ));
						slider28 = limrat;
						slider_automate(slider28);
					);


					mouse_y > smy6a && mouse_y < smy6b && mouse_x < setx+setw2*.6 ? (
						//slider22 = min(2, floor( (mouse_x-setx)/(setw-setx) *4 ));
//                              drag = 22;
						nosafe = min(1, floor( (mouse_x-setx)/(setw2 *.25) ));
						slider22 = nosafe;
						slider_automate(slider22);
						
					) :

					mouse_y > smy7a && mouse_y < smy7b && mouse_x < setx1+setw2 ? (
						shohold = min(1, floor( (mouse_x-setx)/(setw2 *.5) ));
						slider26 = shohold;
						slider_automate(slider26);
					) :

					mouse_y > smy8a && mouse_y < smy8b && mouse_x < setx+setw2*.6 ? (
						autovolena = min(1, floor( (mouse_x-setx)/(setw2 *.25) ));
						slider23 = autovolena;
						slider_automate(slider23);
					);

					upslidergo = 1;


					setting = 1;
				);
			);
		);
	):(
		seta -= .1;
		seta <= 0 ? setclose = settings = 0;
		
	);
	
	gr = .05;
	gfx_set(gr,gr,gr,.7*seta);
	gfx_rect(0,0,gfx_w,gfx_h);
	
	
	gr = .1;
	gfx_set(gr,gr,gr*2,seta);
	rrectfil(setx,sety,setw,seth, 8);
	gr = .5;
	gfx_set(gr,gr,gr,seta);
	gfx_roundrect(setx,sety,setw,seth, 8);

	setx1 = setx + 20;
//     setypad = gfx_texth *2.5;
	setypad = gfx_texth * (2 +  max(0, min(200, gfxh-300) )/80 );
	setw2 = setw - (setx1-setx)*2;
	
	gfx_x = setx1;
	gfx_y = sety +10;
	gfx_drawstr("CompLab ");
	verstr = 0;
	gfx_drawstr( sprintf(verstr,"%.1f",ver +.001) );
	gfx_drawstr("     mrelwood plugins");
	
	gfx_y += gfx_texth *1.7;
	gr = .9;
	gfx_set(gr,gr,gr,seta);
//     gfx_x = setx + setw *.25;
//     gfx_drawstr("S e t t i n g s");
	gfx_x = setx1 + gfx_texth*.5;
	gfx_drawstr("- - -   S e t t i n g s   - - -");

	gfx_y += setypad;
	gfx_x = setx1;
	gr = .8;
	gfx_set(gr,gr,gr,seta);
	gfx_drawstr("  Sidechain source");
	smy1a = (gfx_y += gfx_texth *1.7) -gfx_texth;
	gfx_x = setx1;
	gfx_a = setxtdim + setxtbri * (sidechain == 0 );
	gfx_drawstr("Input");
	gfx_x = setx1 + setw2/4 *1;
	gfx_a = setxtdim + setxtbri * (sidechain == 1 );
	gfx_drawstr("Ch 3");
	gfx_x = setx1 + setw2/4 *2;
	gfx_a = setxtdim + setxtbri * (sidechain == 2 );
	gfx_drawstr("Ch 4");
	gfx_x = setx1 + setw2/4 *3;
	gfx_a = setxtdim + setxtbri * (sidechain == 3 );
	gfx_drawstr("Ch 3+4");
	smy1b = gfx_y + gfx_texth * 2;
	
	gfx_y += setypad;
	gfx_x = setx1;
	gr = .8;
	gfx_set(gr,gr,gr,seta);
	gfx_drawstr("  Mono output channels");
	smy2a = (gfx_y += gfx_texth *1.7) -gfx_texth;
	gfx_x = setx1;
	gfx_a = setxtdim + setxtbri * (slider29 == 0 );
	gfx_drawstr("Orig.");
	gfx_x = setx1 + setw2*.25;
	gfx_a = setxtdim + setxtbri * (slider29 == 1 );
	gfx_drawstr("Dual mono 1-2");
	smy2b = gfx_y + gfx_texth * 2;

	gfx_y += setypad;
	gfx_x = setx1;
	gr = .8;
	gfx_set(gr,gr,gr,seta);
	gfx_drawstr("  Detector HP/LP dB/oct");
	smy3a = (gfx_y += gfx_texth *1.7) -gfx_texth;
	gfx_x = setx1;
	gfx_a = setxtdim + setxtbri * (poles == 1 );
	gfx_drawstr("6");
	gfx_x = setx1 + setw2/5 *1;
	gfx_a = setxtdim + setxtbri * (poles == 2 );
	gfx_drawstr("12");
	gfx_x = setx1 + setw2/5 *2;
	gfx_a = setxtdim + setxtbri * (poles == 3 );
	gfx_drawstr("18");
	gfx_x = setx1 + setw2/5 *3;
	gfx_a = setxtdim + setxtbri * (poles == 4 );
	gfx_drawstr("24");
	gfx_x = setx1 + setw2/5 *4;
	gfx_a = setxtdim + setxtbri * (poles == 5 );
	gfx_drawstr("30");
	smy3b = gfx_y + gfx_texth * 2;
	
	
	gfx_y += setypad;
	gfx_x = setx1;
	gr = .8;
	gfx_set(gr,gr,gr,seta);
	gfx_drawstr("  Horizontal meter source");
	smy4a = (gfx_y += gfx_texth *1.7) -gfx_texth;
	gfx_x = setx1;
	gfx_a = setxtdim + setxtbri * (mtrsrc == 0 );
	gfx_drawstr("Input");
	gfx_x = setx1 + setw2/4;
	gfx_a = setxtdim + setxtbri * (mtrsrc == 1 );
	gfx_drawstr("Input + GR");
	smy4b = gfx_y + gfx_texth * 2;
	
	gfx_y += setypad;
	gfx_x = setx1;
	gr = .8;
	gfx_set(gr,gr,gr,seta);
	gfx_drawstr("  Att-Limiter follows Ratio");
	smy5a = (gfx_y += gfx_texth *1.7) -gfx_texth;
	gfx_x = setx1;
	gfx_a = setxtdim + setxtbri * (limrat == 0 );
	gfx_drawstr("No");
	gfx_x = setx1 + setw2/4;
	gfx_a = setxtdim + setxtbri * (limrat == 1 );
	gfx_drawstr("Yes");
	smy5b = gfx_y + gfx_texth * 2;
	
	
	
	gfx_y += setypad;
	gfx_x = setx1;
	gr = .8;
	gfx_set(gr,gr,gr,seta);
/*
	gfx_drawstr("Bass safe hold (Hz)");
	smy4a = (gfx_y += gfx_texth *1.7) -gfx_texth;
	slixran[22] = (setw - (setx1-setx)*3);
	xposbs = setx1 + slixran[22] * (1-slider22);
	gfx_x = setx1;
	gfx_a = setxtdim;
	while(gfx_x < setx + setw - (setx1-setx)) (
		gfx_drawstr("- ");
	);
	gfx_a = setxtdim + setxtbri;
	gfx_x = xposbs;
	slider22 == 0 ? gfx_drawstr("Off") : gfx_drawnumber(safeholdhz,0);
*/
//     gfx_drawstr("  Safer min release time");
	gfx_drawstr("  Min release time");
	smy6a = (gfx_y += gfx_texth *1.7) -gfx_texth;
	gfx_x = setx1;
	gfx_a = setxtdim + setxtbri * (nosafe == 0 );
	gfx_drawstr("Safe");
	gfx_x = setx1 + setw2/4;
	gfx_a = setxtdim + setxtbri * (nosafe == 1 );
	gfx_drawstr("Unsafe");

	smy6b = gfx_y + gfx_texth * 2;
	
	gfx_y += setypad;
	gfx_x = setx1;
	gr = .8;
	gfx_set(gr,gr,gr,seta);
	gfx_drawstr("  'Hold' display");
	smy7a = (gfx_y += gfx_texth *1.7) -gfx_texth;
	gfx_x = setx1;
	gfx_a = setxtdim + setxtbri * (shohold == 0 );
	gfx_drawstr("Safe Hz + ms");
	gfx_x = setx1 + setw2*.5;
	gfx_a = setxtdim + setxtbri * (shohold == 1 );
	gfx_drawstr("Samples + ms");
	smy7b = gfx_y + gfx_texth * 2;
	
	
	gfx_y += setypad;
	gfx_x = setx1;
	gr = .8;
	gfx_set(gr,gr,gr,seta);
	gfx_drawstr("  Auto volume");
	smy8a = (gfx_y += gfx_texth *1.7) -gfx_texth;
	gfx_x = setx1;
	gfx_a = setxtdim + setxtbri * (autovolena == 0 );
	gfx_drawstr("No");
	gfx_x = setx1 + setw2/4;
	gfx_a = setxtdim + setxtbri * (autovolena == 1 );
	gfx_drawstr("Yes");
	smy8b = gfx_y + gfx_texth * 2;
	
	
	(blinkc += .1) > 6.28 ? blinkc -= 6.28;
	blinka = .5- cos(blinkc)*.5;
	smy5b > gfx_h + 5 ? (
		gfx_x = setx + setw - (setx1-setx);
		gfx_y = gfx_h - gfx_texth *2;
		gfx_a = setxtdim + setxtbri * blinka;
		gfx_drawstr("v v v v", 258,gfx_x,gfx_y);
	):(
		gfx_x = setx1 -5;
		gfx_y += setypad;
		gfx_a = (blinka > .5) * (setxtdim + setxtbri*.5);
//          gfx_drawstr("|");
		gfx_rect(gfx_x+4,gfx_y,gfx_texth*.8,gfx_texth,1);
	);
	
	

);







mouxold = mouse_x;
mouyold = mouse_y;
mouse_cap == 0 ? (
	snap11 == 1 ? (
		slider11 = stereo = floor(slider11+.5);
		slider24 = mono = floor(slider24+.5);
		slider_automate(slider11);
		slider_automate(slider24);
		snap11 = 0;
	);
	dragspd = 1;
	drag = nodrag4 = dragstrt = setting = 0;
	capold > 0 ? (
		slider8 = poles;
		slider11 = stereo;
	);
	capold == 0 ? hadmou = 0;
/*
	hadmou > 0 && capold == 0 ? (
		hadmouc += 1;
		hadmouc > 30 ? (
			hadmou = hadmouc = drag = 0;
		);
	);
*/
);
capold = mouse_cap;

//monsplL1 = monsplR = 0;


/*
mtrsrc == 1 && sidechain == 0 ? (
	monsplL1 = abs(compinL) *comp.compg2 ;
	monsplR = abs(compinR) *compR.compg2 ;
):(
	monsplL1 = abs(compinL) ;
	monsplR = abs(compinR) ;
);
*/

gfxnoob < 10 ? gfxnoob += 1;


